/*!
 * AXNOS Paint version 2.4.0 (2026-01-11T10:33:35.901Z)
 * (c) 2022「悪の巣」部屋番号13番：「趣味の悪い大衆酒場[Mad end dance hall]」
 * Licensed under MPL 2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["AXNOSPaint"] = factory();
	else
		root["AXNOSPaint"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./extensions/prod.js":
/*!****************************!*\
  !*** ./extensions/prod.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExTool: () => (/* binding */ ExTool),
/* harmony export */   isExtenstions: () => (/* binding */ isExtenstions)
/* harmony export */ });
// @description webpackビルド制御（プロダクション版）

var isExtenstions = false;
class ExTool {
    member = [];
    constructor() { }
} 

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/alert.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/alert.css ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* アラート */

#axp_alert_div_modalContainer {
    background-color: rgba(0, 0, 0, 0.3);
    width: 100%;
    height: 100%;
    z-index: 10000;
    display: flex;
    position: fixed;
    align-items: center;
    justify-content: center;
}

#axp_alert_div_alertBox {
    width: 50%;
    min-width: 350px;
    max-width: 600px;
    min-height: 100px;
    max-height: 400px;
    border: 1px solid #fff;
    background-color: #fff;
    background-repeat: no-repeat;
}

#axp_alert_div_modalContainer>#alertBox {
    position: fixed;
}

#axp_alert_div_alertBox h1 {
    margin: 0;
    font: bold 1em Raleway, arial;
    background-color: #555;
    color: #FFF;
    border-bottom: 1px solid #555;
    padding: 5px 0 5px 5px;
}

#axp_alert_div_alertBox p {
    height: auto;
    padding-left: 5px;
    padding-top: 30px;
    text-align: center;
    vertical-align: middle;
    color: #000;
}

#axp_alert_div_alertBox #axp_alert_button_closeBtn {
    margin: 10px auto 10px auto;
    padding: 7px;
    border: 0 none;
    width: 100px;
    text-transform: uppercase;
    text-align: center;
    color: #FFF;
    background-color: #555;
    border-radius: 0px;
    text-decoration: none;
    outline: 0 !important;
}

#axp_alert_div_alertBox #axp_alert_button_cancelBtn {
    margin: 10px auto 10px auto;
    padding: 7px;
    border: 0 none;
    width: 100px;
    text-transform: uppercase;
    text-align: center;
    color: #FFF;
    background-color: #555;
    border-radius: 0px;
    text-decoration: none;
    outline: 0 !important;
}
`, "",{"version":3,"sources":["webpack://./src/css/alert.css"],"names":[],"mappings":"AAAA,SAAS;;AAET;IACI,oCAAoC;IACpC,WAAW;IACX,YAAY;IACZ,cAAc;IACd,aAAa;IACb,eAAe;IACf,mBAAmB;IACnB,uBAAuB;AAC3B;;AAEA;IACI,UAAU;IACV,gBAAgB;IAChB,gBAAgB;IAChB,iBAAiB;IACjB,iBAAiB;IACjB,sBAAsB;IACtB,sBAAsB;IACtB,4BAA4B;AAChC;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,SAAS;IACT,6BAA6B;IAC7B,sBAAsB;IACtB,WAAW;IACX,6BAA6B;IAC7B,sBAAsB;AAC1B;;AAEA;IACI,YAAY;IACZ,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,sBAAsB;IACtB,WAAW;AACf;;AAEA;IACI,2BAA2B;IAC3B,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,yBAAyB;IACzB,kBAAkB;IAClB,WAAW;IACX,sBAAsB;IACtB,kBAAkB;IAClB,qBAAqB;IACrB,qBAAqB;AACzB;;AAEA;IACI,2BAA2B;IAC3B,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,yBAAyB;IACzB,kBAAkB;IAClB,WAAW;IACX,sBAAsB;IACtB,kBAAkB;IAClB,qBAAqB;IACrB,qBAAqB;AACzB","sourcesContent":["/* アラート */\n\n#axp_alert_div_modalContainer {\n    background-color: rgba(0, 0, 0, 0.3);\n    width: 100%;\n    height: 100%;\n    z-index: 10000;\n    display: flex;\n    position: fixed;\n    align-items: center;\n    justify-content: center;\n}\n\n#axp_alert_div_alertBox {\n    width: 50%;\n    min-width: 350px;\n    max-width: 600px;\n    min-height: 100px;\n    max-height: 400px;\n    border: 1px solid #fff;\n    background-color: #fff;\n    background-repeat: no-repeat;\n}\n\n#axp_alert_div_modalContainer>#alertBox {\n    position: fixed;\n}\n\n#axp_alert_div_alertBox h1 {\n    margin: 0;\n    font: bold 1em Raleway, arial;\n    background-color: #555;\n    color: #FFF;\n    border-bottom: 1px solid #555;\n    padding: 5px 0 5px 5px;\n}\n\n#axp_alert_div_alertBox p {\n    height: auto;\n    padding-left: 5px;\n    padding-top: 30px;\n    text-align: center;\n    vertical-align: middle;\n    color: #000;\n}\n\n#axp_alert_div_alertBox #axp_alert_button_closeBtn {\n    margin: 10px auto 10px auto;\n    padding: 7px;\n    border: 0 none;\n    width: 100px;\n    text-transform: uppercase;\n    text-align: center;\n    color: #FFF;\n    background-color: #555;\n    border-radius: 0px;\n    text-decoration: none;\n    outline: 0 !important;\n}\n\n#axp_alert_div_alertBox #axp_alert_button_cancelBtn {\n    margin: 10px auto 10px auto;\n    padding: 7px;\n    border: 0 none;\n    width: 100px;\n    text-transform: uppercase;\n    text-align: center;\n    color: #FFF;\n    background-color: #555;\n    border-radius: 0px;\n    text-decoration: none;\n    outline: 0 !important;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/axnospaint.css":
/*!**********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/axnospaint.css ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* AXNOS Paintメイン */

body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100vh;
  /* iPad */
  height: 100svh;
  display: flex;
  flex-direction: column;
  /* Pull-to-Refresh防止 */
  overscroll-behavior-y: none;
  /* 注意　HTML5版も影響をうける */
  overflow: hidden;
}

#axp_main {
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  color: #fff;
  background-color: #000;
  font-size: 15px;
  width: 100%;
  margin: 0 auto;
  padding: 0;
  display: none;
  flex-grow: 1;
  flex-direction: column;
  overflow: hidden;
  font-family: sans-serif;
}

/* 詳細度0.0.0でツールの要素全体に指定 */
:where(#axp_main) * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* メインのタブ制御 */
#axp_main_div_tab {
  display: flex;
  align-items: flex-end;
  min-height: 30px;
}

/* 見出し枠 */
#axp_main_div_tab_menu {
  list-style-type: none;
  display: flex;
}

/* 見出し */
#axp_main_div_tab_menu>div {
  display: block;
  width: 98px;
  margin: 0;
  padding: 2px 0;
  text-align: center;
  border-top: 2px solid #000;
  border-left: 0px solid #000;
  border-right: 2px solid #000;
  border-radius: 10px 10px 0 0;
  background: #333;
  box-sizing: border-box;
  cursor: pointer;
}

/* 見出しにカーソルを当てた時 */
#axp_main_div_tab_menu>div:hover {
  background: #555;
}

/* 選択されている見出し */
#axp_main_div_tab_menu>div[data-selected="true"] {
  background: #777;
}

/* ハンバーガーメニュー */
#axp_main_label_hamburger {
  /* 通常は非表示 */
  display: none;
  height: 100%;
  width: 30px;
  cursor: pointer;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  margin: 0 8px;
}

/* ハンバーガーメニューチェックボックス */
#axp_main_checkbox_hamburger {
  display: none;
}

/* ブラウザの横幅が599px以下の場合 */
@media (max-width: 599px) {

  /* ハンバーガーメニュー表示 */
  #axp_main_label_hamburger {
    display: flex;
  }

  #axp_main_div_tab_menu {
    position: absolute;
    background: #333;
    top: 0;
    margin-top: 30px;
    left: 0;
    flex-direction: column;
    width: 100%;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    z-index: 6000;
  }

  #axp_main_checkbox_hamburger~div>div {
    height: 0;
    margin: 0;
    padding: 0;
    border: 0;
    transition: height 400ms cubic-bezier(0.23, 1, 0.32, 1);
  }

  #axp_main_checkbox_hamburger:checked~div>div {
    border: 1px solid #333;
    height: 2.5em;
    padding: 0.5em;
    transition: height 400ms cubic-bezier(0.23, 1, 0.32, 1);
  }

  #axp_main_div_tab_menu>div {
    display: flex;
    justify-content: center;
    margin: 0;
    padding: 0.5em 0;
    width: 100%;
    border-radius: 10px 10px 10px 10px;
  }
}

/* タブ横のテキスト */
#axp_main_div_headerText {
  padding: 4px 10px 0;
  color: #fff;
  overflow: hidden;
  white-space: pre;
  flex-grow: 1;
  cursor: pointer;
  text-overflow: ellipsis;
}

/* タブ横のテキストクリック時、全文表示 */
#axp_main_div_headerText:active {
  overflow: visible;
  white-space: normal;
}

/* タブにより切り替わる画面 */
#axp_main_div_tabContent>article {
  display: none;
  flex-grow: 1;
  flex-direction: column;
  overflow: hidden;
}

/* inputのフォントサイズ指定 */
#axp_main_div_tabContent input {
  font-size: 13px;
}

/* タブ：キャンバス */
#axp_canvas {
  width: 100%;
  overflow: hidden;
  position: relative;
  flex-grow: 1;
}

/* キャンバス外の灰色部分 */
#axp_canvas_div_grayBackground {
  width: 100%;
  height: 100%;
  background-color: #777;
}

/* メインキャンバス */
#axp_canvas_canvas_main {
  position: absolute;
  image-rendering: pixelated;
  z-index: 100;
}

/* 補助線 */
#axp_canvas_div_grid {
  /* イベントを受け取らない（重要） */
  pointer-events: none;
  image-rendering: auto;
  position: absolute;
  z-index: 600;
}

/* 座標表示用領域 */
#axp_canvas_div_pointerPosition {
  position: absolute;
  right: 0;
  bottom: 0;
  font-family: monospace;
  font-size: 18px;
  font-weight: 500;
  color: #fff;
  background: rgba(0, 0, 0, 0.7);
  box-shadow: #000;
  z-index: 800;
}

/* デバッグ情報 */
#axp_canvas_div_debugInfo {
  position: absolute;
  top: 0;
  left: 0;
  font-family: monospace;
  font-size: 1em;
  background: rgba(0, 0, 0, 0.7);
  box-shadow: #000;
  z-index: 900;
  height: 50%;
  max-height: 95%;
  resize: both;
  overflow: hidden;
}

#axp_canvas_div_debugInfo>div:nth-of-type(1) {
  font-family: monospace;
  color: #fff;
  font-size: 1em;
  height: 24px;
  overflow: hidden;
}

#axp_canvas_div_debugInfo>div:nth-of-type(2) {
  font-family: monospace;
  font-size: 1em;
  color: #fff;
  background: rgba(0, 0, 0, 0);
  min-width: 360px;
  height: calc(100% - 24px);
  overflow-x: hidden;
  overflow-y: scroll;
}

/* カーソル位置に表示するペンの太さ表示*/
#axp_canvas_div_penCursor {
  pointer-events: none;
  position: absolute;
  border: solid 2px rgba(0, 0, 0, 0.3);
  z-index: 700;
}


#axp_main_div_tabContent,
#axp_config,
#axp_config_div_menu {
  display: flex;
  flex-grow: 1;
  flex-direction: column;
  overflow: hidden;
}

/* タブ：設定 */
#axp_config_div_content {
  flex-grow: 1;
}

/* タブ：投稿 */
#axp_post {
  flex-grow: 1;
  overflow: auto;
}

/* フッター領域 */
#axp_footer {
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  background-color: #222;
  color: #ddd;
  display: flex;
  flex-basis: 31px;
}

#axp_footer_div_message {
  background-color: rgba(0, 0, 0, 0);
  font-size: 15px;
  font-family: sans-serif;
  padding: 4px;
}

#axp_footer_div_icon {
  margin-left: 8px;
  margin-top: 2px;
}`, "",{"version":3,"sources":["webpack://./src/css/axnospaint.css"],"names":[],"mappings":"AAAA,mBAAmB;;AAEnB;EACE,SAAS;EACT,UAAU;EACV,WAAW;EACX,aAAa;EACb,SAAS;EACT,cAAc;EACd,aAAa;EACb,sBAAsB;EACtB,sBAAsB;EACtB,2BAA2B;EAC3B,qBAAqB;EACrB,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,yBAAyB;EACzB,iBAAiB;EACjB,WAAW;EACX,sBAAsB;EACtB,eAAe;EACf,WAAW;EACX,cAAc;EACd,UAAU;EACV,aAAa;EACb,YAAY;EACZ,sBAAsB;EACtB,gBAAgB;EAChB,uBAAuB;AACzB;;AAEA,yBAAyB;AACzB;EACE,sBAAsB;EACtB,SAAS;EACT,UAAU;AACZ;;AAEA,aAAa;AACb;EACE,aAAa;EACb,qBAAqB;EACrB,gBAAgB;AAClB;;AAEA,SAAS;AACT;EACE,qBAAqB;EACrB,aAAa;AACf;;AAEA,QAAQ;AACR;EACE,cAAc;EACd,WAAW;EACX,SAAS;EACT,cAAc;EACd,kBAAkB;EAClB,0BAA0B;EAC1B,2BAA2B;EAC3B,4BAA4B;EAC5B,4BAA4B;EAC5B,gBAAgB;EAChB,sBAAsB;EACtB,eAAe;AACjB;;AAEA,kBAAkB;AAClB;EACE,gBAAgB;AAClB;;AAEA,eAAe;AACf;EACE,gBAAgB;AAClB;;AAEA,eAAe;AACf;EACE,WAAW;EACX,aAAa;EACb,YAAY;EACZ,WAAW;EACX,eAAe;EACf,sBAAsB;EACtB,uBAAuB;EACvB,mBAAmB;EACnB,aAAa;AACf;;AAEA,uBAAuB;AACvB;EACE,aAAa;AACf;;AAEA,uBAAuB;AACvB;;EAEE,iBAAiB;EACjB;IACE,aAAa;EACf;;EAEA;IACE,kBAAkB;IAClB,gBAAgB;IAChB,MAAM;IACN,gBAAgB;IAChB,OAAO;IACP,sBAAsB;IACtB,WAAW;IACX,uBAAuB;IACvB,mBAAmB;IACnB,gBAAgB;IAChB,aAAa;EACf;;EAEA;IACE,SAAS;IACT,SAAS;IACT,UAAU;IACV,SAAS;IACT,uDAAuD;EACzD;;EAEA;IACE,sBAAsB;IACtB,aAAa;IACb,cAAc;IACd,uDAAuD;EACzD;;EAEA;IACE,aAAa;IACb,uBAAuB;IACvB,SAAS;IACT,gBAAgB;IAChB,WAAW;IACX,kCAAkC;EACpC;AACF;;AAEA,aAAa;AACb;EACE,mBAAmB;EACnB,WAAW;EACX,gBAAgB;EAChB,gBAAgB;EAChB,YAAY;EACZ,eAAe;EACf,uBAAuB;AACzB;;AAEA,uBAAuB;AACvB;EACE,iBAAiB;EACjB,mBAAmB;AACrB;;AAEA,iBAAiB;AACjB;EACE,aAAa;EACb,YAAY;EACZ,sBAAsB;EACtB,gBAAgB;AAClB;;AAEA,oBAAoB;AACpB;EACE,eAAe;AACjB;;AAEA,aAAa;AACb;EACE,WAAW;EACX,gBAAgB;EAChB,kBAAkB;EAClB,YAAY;AACd;;AAEA,gBAAgB;AAChB;EACE,WAAW;EACX,YAAY;EACZ,sBAAsB;AACxB;;AAEA,aAAa;AACb;EACE,kBAAkB;EAClB,0BAA0B;EAC1B,YAAY;AACd;;AAEA,QAAQ;AACR;EACE,oBAAoB;EACpB,oBAAoB;EACpB,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;AACd;;AAEA,YAAY;AACZ;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,sBAAsB;EACtB,eAAe;EACf,gBAAgB;EAChB,WAAW;EACX,8BAA8B;EAC9B,gBAAgB;EAChB,YAAY;AACd;;AAEA,WAAW;AACX;EACE,kBAAkB;EAClB,MAAM;EACN,OAAO;EACP,sBAAsB;EACtB,cAAc;EACd,8BAA8B;EAC9B,gBAAgB;EAChB,YAAY;EACZ,WAAW;EACX,eAAe;EACf,YAAY;EACZ,gBAAgB;AAClB;;AAEA;EACE,sBAAsB;EACtB,WAAW;EACX,cAAc;EACd,YAAY;EACZ,gBAAgB;AAClB;;AAEA;EACE,sBAAsB;EACtB,cAAc;EACd,WAAW;EACX,4BAA4B;EAC5B,gBAAgB;EAChB,yBAAyB;EACzB,kBAAkB;EAClB,kBAAkB;AACpB;;AAEA,sBAAsB;AACtB;EACE,oBAAoB;EACpB,kBAAkB;EAClB,oCAAoC;EACpC,YAAY;AACd;;;AAGA;;;EAGE,aAAa;EACb,YAAY;EACZ,sBAAsB;EACtB,gBAAgB;AAClB;;AAEA,UAAU;AACV;EACE,YAAY;AACd;;AAEA,UAAU;AACV;EACE,YAAY;EACZ,cAAc;AAChB;;AAEA,WAAW;AACX;EACE,kBAAkB;EAClB,yBAAyB;EACzB,iBAAiB;EACjB,sBAAsB;EACtB,WAAW;EACX,aAAa;EACb,gBAAgB;AAClB;;AAEA;EACE,kCAAkC;EAClC,eAAe;EACf,uBAAuB;EACvB,YAAY;AACd;;AAEA;EACE,gBAAgB;EAChB,eAAe;AACjB","sourcesContent":["/* AXNOS Paintメイン */\n\nbody {\n  margin: 0;\n  padding: 0;\n  width: 100%;\n  height: 100vh;\n  /* iPad */\n  height: 100svh;\n  display: flex;\n  flex-direction: column;\n  /* Pull-to-Refresh防止 */\n  overscroll-behavior-y: none;\n  /* 注意　HTML5版も影響をうける */\n  overflow: hidden;\n}\n\n#axp_main {\n  touch-action: none;\n  -webkit-user-select: none;\n  user-select: none;\n  color: #fff;\n  background-color: #000;\n  font-size: 15px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 0;\n  display: none;\n  flex-grow: 1;\n  flex-direction: column;\n  overflow: hidden;\n  font-family: sans-serif;\n}\n\n/* 詳細度0.0.0でツールの要素全体に指定 */\n:where(#axp_main) * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n\n/* メインのタブ制御 */\n#axp_main_div_tab {\n  display: flex;\n  align-items: flex-end;\n  min-height: 30px;\n}\n\n/* 見出し枠 */\n#axp_main_div_tab_menu {\n  list-style-type: none;\n  display: flex;\n}\n\n/* 見出し */\n#axp_main_div_tab_menu>div {\n  display: block;\n  width: 98px;\n  margin: 0;\n  padding: 2px 0;\n  text-align: center;\n  border-top: 2px solid #000;\n  border-left: 0px solid #000;\n  border-right: 2px solid #000;\n  border-radius: 10px 10px 0 0;\n  background: #333;\n  box-sizing: border-box;\n  cursor: pointer;\n}\n\n/* 見出しにカーソルを当てた時 */\n#axp_main_div_tab_menu>div:hover {\n  background: #555;\n}\n\n/* 選択されている見出し */\n#axp_main_div_tab_menu>div[data-selected=\"true\"] {\n  background: #777;\n}\n\n/* ハンバーガーメニュー */\n#axp_main_label_hamburger {\n  /* 通常は非表示 */\n  display: none;\n  height: 100%;\n  width: 30px;\n  cursor: pointer;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  margin: 0 8px;\n}\n\n/* ハンバーガーメニューチェックボックス */\n#axp_main_checkbox_hamburger {\n  display: none;\n}\n\n/* ブラウザの横幅が599px以下の場合 */\n@media (max-width: 599px) {\n\n  /* ハンバーガーメニュー表示 */\n  #axp_main_label_hamburger {\n    display: flex;\n  }\n\n  #axp_main_div_tab_menu {\n    position: absolute;\n    background: #333;\n    top: 0;\n    margin-top: 30px;\n    left: 0;\n    flex-direction: column;\n    width: 100%;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    z-index: 6000;\n  }\n\n  #axp_main_checkbox_hamburger~div>div {\n    height: 0;\n    margin: 0;\n    padding: 0;\n    border: 0;\n    transition: height 400ms cubic-bezier(0.23, 1, 0.32, 1);\n  }\n\n  #axp_main_checkbox_hamburger:checked~div>div {\n    border: 1px solid #333;\n    height: 2.5em;\n    padding: 0.5em;\n    transition: height 400ms cubic-bezier(0.23, 1, 0.32, 1);\n  }\n\n  #axp_main_div_tab_menu>div {\n    display: flex;\n    justify-content: center;\n    margin: 0;\n    padding: 0.5em 0;\n    width: 100%;\n    border-radius: 10px 10px 10px 10px;\n  }\n}\n\n/* タブ横のテキスト */\n#axp_main_div_headerText {\n  padding: 4px 10px 0;\n  color: #fff;\n  overflow: hidden;\n  white-space: pre;\n  flex-grow: 1;\n  cursor: pointer;\n  text-overflow: ellipsis;\n}\n\n/* タブ横のテキストクリック時、全文表示 */\n#axp_main_div_headerText:active {\n  overflow: visible;\n  white-space: normal;\n}\n\n/* タブにより切り替わる画面 */\n#axp_main_div_tabContent>article {\n  display: none;\n  flex-grow: 1;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n/* inputのフォントサイズ指定 */\n#axp_main_div_tabContent input {\n  font-size: 13px;\n}\n\n/* タブ：キャンバス */\n#axp_canvas {\n  width: 100%;\n  overflow: hidden;\n  position: relative;\n  flex-grow: 1;\n}\n\n/* キャンバス外の灰色部分 */\n#axp_canvas_div_grayBackground {\n  width: 100%;\n  height: 100%;\n  background-color: #777;\n}\n\n/* メインキャンバス */\n#axp_canvas_canvas_main {\n  position: absolute;\n  image-rendering: pixelated;\n  z-index: 100;\n}\n\n/* 補助線 */\n#axp_canvas_div_grid {\n  /* イベントを受け取らない（重要） */\n  pointer-events: none;\n  image-rendering: auto;\n  position: absolute;\n  z-index: 600;\n}\n\n/* 座標表示用領域 */\n#axp_canvas_div_pointerPosition {\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  font-family: monospace;\n  font-size: 18px;\n  font-weight: 500;\n  color: #fff;\n  background: rgba(0, 0, 0, 0.7);\n  box-shadow: #000;\n  z-index: 800;\n}\n\n/* デバッグ情報 */\n#axp_canvas_div_debugInfo {\n  position: absolute;\n  top: 0;\n  left: 0;\n  font-family: monospace;\n  font-size: 1em;\n  background: rgba(0, 0, 0, 0.7);\n  box-shadow: #000;\n  z-index: 900;\n  height: 50%;\n  max-height: 95%;\n  resize: both;\n  overflow: hidden;\n}\n\n#axp_canvas_div_debugInfo>div:nth-of-type(1) {\n  font-family: monospace;\n  color: #fff;\n  font-size: 1em;\n  height: 24px;\n  overflow: hidden;\n}\n\n#axp_canvas_div_debugInfo>div:nth-of-type(2) {\n  font-family: monospace;\n  font-size: 1em;\n  color: #fff;\n  background: rgba(0, 0, 0, 0);\n  min-width: 360px;\n  height: calc(100% - 24px);\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n\n/* カーソル位置に表示するペンの太さ表示*/\n#axp_canvas_div_penCursor {\n  pointer-events: none;\n  position: absolute;\n  border: solid 2px rgba(0, 0, 0, 0.3);\n  z-index: 700;\n}\n\n\n#axp_main_div_tabContent,\n#axp_config,\n#axp_config_div_menu {\n  display: flex;\n  flex-grow: 1;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n/* タブ：設定 */\n#axp_config_div_content {\n  flex-grow: 1;\n}\n\n/* タブ：投稿 */\n#axp_post {\n  flex-grow: 1;\n  overflow: auto;\n}\n\n/* フッター領域 */\n#axp_footer {\n  touch-action: none;\n  -webkit-user-select: none;\n  user-select: none;\n  background-color: #222;\n  color: #ddd;\n  display: flex;\n  flex-basis: 31px;\n}\n\n#axp_footer_div_message {\n  background-color: rgba(0, 0, 0, 0);\n  font-size: 15px;\n  font-family: sans-serif;\n  padding: 4px;\n}\n\n#axp_footer_div_icon {\n  margin-left: 8px;\n  margin-top: 2px;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/common.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/common.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* 共通クラス */

/* 要素非表示 */
.axpc_NONE {
    display: none;
}

/* 要素非表示（レイアウト変更なし） */
.axpc_HIDDEN {
    visibility: hidden;
}

/* テキスト縁取り */
.axpc_text_border {
    text-shadow:
        black 2px 0px, black -2px 0px,
        black 0px -2px, black 0px 2px,
        black 2px 2px, black -2px 2px,
        black 2px -2px, black -2px -2px,
        black 1px 2px, black -1px 2px,
        black 1px -2px, black -1px -2px,
        black 2px 1px, black -2px 1px,
        black 2px -1px, black -2px -1px;
    /*
    text-shadow: 1px 1px 0 #000, -1px -1px 0 #000,
        -1px 1px 0 #000, 1px -1px 0 #000,
        0px 1px 0 #000, 0-1px 0 #000,
        -1px 0 0 #000, 1px 0 0 #000;
    */
}

/* キャンバスの透過メッシュ */
.axpc_background_mesh {
    background: rgb(204, 204, 204);
    background-image: repeating-conic-gradient(from 0deg, transparent 0deg 90deg, #fff 90deg 180deg);
    background-size: 16px 16px;
    background-position: 0 0, 8px 8px, 8px 8px, 16px 16px;
}

/* サブウィンドウ共通 */
.axpc_subwindow {
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    position: absolute;
    z-index: 2000;
    left: 0;
    top: 0;
    height: 100%;
    width: 100%;
    overflow: hidden;
    background-color: rgba(0, 0, 0, 0);
}

.axpc_subwindow>div {
    background-color: #333;
    color: #fff;
    border-color: #000;
    border-style: solid;
    border-width: 2px;
    border-color: #aaa;
    box-shadow: 4px 4px 8px #777;
    border-radius: 5px;
    width: 188px;
    height: auto;
    padding: 8px;
}

/* 色作成 補助線設定のカラー選択枠 */
.axpc_colorRect {
    height: 32px;
    width: 32px;
    cursor: pointer;
    border-radius: 5px;
    margin: 1px;
    border-width: 2px;
    border-style: solid;
    border-color: #aaa;
}`, "",{"version":3,"sources":["webpack://./src/css/common.css"],"names":[],"mappings":"AAAA,UAAU;;AAEV,UAAU;AACV;IACI,aAAa;AACjB;;AAEA,qBAAqB;AACrB;IACI,kBAAkB;AACtB;;AAEA,YAAY;AACZ;IACI;;;;;;;;uCAQmC;IACnC;;;;;KAKC;AACL;;AAEA,iBAAiB;AACjB;IACI,8BAA8B;IAC9B,gGAAgG;IAChG,0BAA0B;IAC1B,qDAAqD;AACzD;;AAEA,cAAc;AACd;IACI,kBAAkB;IAClB,yBAAyB;IACzB,iBAAiB;IACjB,kBAAkB;IAClB,aAAa;IACb,OAAO;IACP,MAAM;IACN,YAAY;IACZ,WAAW;IACX,gBAAgB;IAChB,kCAAkC;AACtC;;AAEA;IACI,sBAAsB;IACtB,WAAW;IACX,kBAAkB;IAClB,mBAAmB;IACnB,iBAAiB;IACjB,kBAAkB;IAClB,4BAA4B;IAC5B,kBAAkB;IAClB,YAAY;IACZ,YAAY;IACZ,YAAY;AAChB;;AAEA,qBAAqB;AACrB;IACI,YAAY;IACZ,WAAW;IACX,eAAe;IACf,kBAAkB;IAClB,WAAW;IACX,iBAAiB;IACjB,mBAAmB;IACnB,kBAAkB;AACtB","sourcesContent":["/* 共通クラス */\n\n/* 要素非表示 */\n.axpc_NONE {\n    display: none;\n}\n\n/* 要素非表示（レイアウト変更なし） */\n.axpc_HIDDEN {\n    visibility: hidden;\n}\n\n/* テキスト縁取り */\n.axpc_text_border {\n    text-shadow:\n        black 2px 0px, black -2px 0px,\n        black 0px -2px, black 0px 2px,\n        black 2px 2px, black -2px 2px,\n        black 2px -2px, black -2px -2px,\n        black 1px 2px, black -1px 2px,\n        black 1px -2px, black -1px -2px,\n        black 2px 1px, black -2px 1px,\n        black 2px -1px, black -2px -1px;\n    /*\n    text-shadow: 1px 1px 0 #000, -1px -1px 0 #000,\n        -1px 1px 0 #000, 1px -1px 0 #000,\n        0px 1px 0 #000, 0-1px 0 #000,\n        -1px 0 0 #000, 1px 0 0 #000;\n    */\n}\n\n/* キャンバスの透過メッシュ */\n.axpc_background_mesh {\n    background: rgb(204, 204, 204);\n    background-image: repeating-conic-gradient(from 0deg, transparent 0deg 90deg, #fff 90deg 180deg);\n    background-size: 16px 16px;\n    background-position: 0 0, 8px 8px, 8px 8px, 16px 16px;\n}\n\n/* サブウィンドウ共通 */\n.axpc_subwindow {\n    touch-action: none;\n    -webkit-user-select: none;\n    user-select: none;\n    position: absolute;\n    z-index: 2000;\n    left: 0;\n    top: 0;\n    height: 100%;\n    width: 100%;\n    overflow: hidden;\n    background-color: rgba(0, 0, 0, 0);\n}\n\n.axpc_subwindow>div {\n    background-color: #333;\n    color: #fff;\n    border-color: #000;\n    border-style: solid;\n    border-width: 2px;\n    border-color: #aaa;\n    box-shadow: 4px 4px 8px #777;\n    border-radius: 5px;\n    width: 188px;\n    height: auto;\n    padding: 8px;\n}\n\n/* 色作成 補助線設定のカラー選択枠 */\n.axpc_colorRect {\n    height: 32px;\n    width: 32px;\n    cursor: pointer;\n    border-radius: 5px;\n    margin: 1px;\n    border-width: 2px;\n    border-style: solid;\n    border-color: #aaa;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/config.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/config.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* 設定タブ */
#axp_config_div_content {
    display: flex;
    margin: 0;
    padding: 0;
    height: 100%;
}

/* 左側：ナビゲーションメニュー */
#axp_config_div_nav {
    width: 200px;
    height: 100%;
    overflow: auto;
    position: sticky;
    top: 0;
    background-color: #eee;
    padding: 10px;
    /* iPad跳ね返り防止 */
    overscroll-behavior: none;
}

/* ナビボタン */
#axp_config_div_nav button {
    width: 160px;
    height: 40px;
    border-radius: 6px;
    border: 0;
    background-color: #eee;
    color: #111;
    cursor: pointer;
    margin: 1px 0;
    padding-left: 8px;
    font-size: 1em;
    font-weight: bold;
    text-align: left;
}

#axp_config_div_nav button.axpc_ACTIVE {
    background: #E09C35;
}

/* 本文：外枠 */
.axpc_config_chapter {
    width: calc(100% - 200px);
    height: 100%;
    padding: 10px;
    background-color: #eee;
    overflow-y: scroll;
}

/* ブラウザの横幅が599px以下の場合 */
@media (max-width: 599px) {
    #axp_config_div_nav {
        /* ナビゲーションメニュー非表示 */
        display: none;
    }

    .axpc_config_chapter {
        width: 100%;
    }
}

/* 本文：セクション */
.axpc_config_section {
    margin-bottom: 50px;
    color: #111;
}

/* 本文：セクション見出し */
.axpc_config_sectionHeader {
    background: #ddf;
    margin-top: 8px;
    padding: 8px 8px;
    font-weight: bolder;
}

/* 設定用共通グループ（クラスが設定されていると、自動的にaxpc_config_div_headerをもつdiv要素を作成） */
.axpc_config_group {
    padding: 16px;
    border: 2px #ddd solid;
}

/* 外部リンク部分のはみ出し回避 */
.axpc_config_group a {
    overflow-wrap: anywhere;
}

/* 設定用共通見出し */
.axpc_config_groupHeader {
    background: #ddd;
    margin-top: 8px;
    padding: 4px 16px;
}

/* キャンバス履歴テーブル */
#axp_config_ul_canvasSizeHistory {
    margin-top: 8px;
    width: 200px;
    margin: 0 0 8px 0;
    padding: 0;
    list-style-type: none;
    border: 1px solid #aaa;
    max-height: 220px;
    overflow-y: auto;
}

#axp_config_ul_canvasSizeHistory>li {
    padding: 2px 10px;
    height: 25px;
    text-align: center;
    cursor: pointer;
}

#axp_config_ul_canvasSizeHistory>li:nth-child(even) {
    background: #ddd;
}

/* 注意：evenより優先度高 */
#axp_config_ul_canvasSizeHistory>li[data-selected="true"] {
    background: #f7a312 !important;
}

/* ショートカットテーブル */
.axpc_config_table {
    border: 2px solid #aaa;
    border-collapse: collapse;
}

.axpc_config_table td:nth-child(1) {
    font-family: 'Consolas', monospace;
    font-size: 12pt;
}

.axpc_config_table th {
    padding: 0 8px;
    background-color: #ddf;
}

.axpc_config_table td {
    padding: 0 8px;
    border: 1px solid #aaa;
}

/* 設定用のカラーパレット表示（モックアップ）*/
#axp_config_div_paletteScroll {
    max-width: 228px;
    max-height: 228px;
    overflow: auto;
    background: #ccc;
}

/* 設定用カラーパレット枠 */
#axp_config_div_paletteBox {
    display: flex;
    flex-wrap: wrap;
    align-content: flex-start;
    background: #333;
    padding: 4px;
}

/* 設定用カラーパレット単色 */
.axpc_config_colorRect {
    height: 20px;
    width: 20px;
    margin: 1px;
    border-radius: 3px;
}

/* 拡大率 */
#axp_config_div_scale {
    width: 200px;
}

#axp_config_div_scaleButton {
    width: 100%;
    display: grid;
    grid-template-columns: 1fr 30px 1fr;
}

#axp_config_button_addScale {
    width: 100%;
}

#axp_config_button_deleteScale,
#axp_config_button_resetScale {
    margin-top: 8px;
    width: 100%;
}

/* 拡大率テーブル */
#axp_config_ul_scale {
    margin-top: 8px;
    width: 200px;
    margin: 0;
    padding: 0;
    list-style-type: none;
    border: 1px solid #aaa;
    max-height: 352px;
    overflow-y: scroll;
}

#axp_config_ul_scale>li {
    padding: 2px 10px;
    height: 25px;
    text-align: center;
    cursor: pointer;
}

#axp_config_ul_scale>li:nth-child(even) {
    background: #ddd;
}

#axp_config_ul_scale>li[data-value="100"] {
    border: 1px solid #333;
}

/* 注意：evenより優先度高 */
#axp_config_ul_scale>li[data-selected="true"] {
    background: #f7a312 !important;
}

/* カラータグ */
#axp_config_div_colorTag {
    width: 300px;
    display: grid;
    grid-template-rows: repeat(4, 34px);
    grid-template-columns: 1fr 1fr;
    margin-bottom: 8px;
    gap: 4px 10px;
}

.axpc_config_div_colorTag {
    border-radius: 5px;
    border: #222 solid 2px;
    width: 154px;
}

.axpc_config_text_colorTag {
    width: 130px;
    height: 30px;
    font-size: 13px;
    text-align: left;
    border-radius: 5px;
    padding-left: 4px;
}

/* キーカスタマイズ用拡大率セレクトボックス */
.axpc_config_select_scaleTable {
    width: 24px;
}

/* キーカスタマイズ用数値入力 */
.axpc_config_number_sizeValue,
.axpc_config_number_scaleValue {
    width: 60px;
}

/* バージョン情報 */
#axp_config_div_versionInfo {
    -webkit-user-select: all;
    user-select: all;
}`, "",{"version":3,"sources":["webpack://./src/css/config.css"],"names":[],"mappings":"AAAA,SAAS;AACT;IACI,aAAa;IACb,SAAS;IACT,UAAU;IACV,YAAY;AAChB;;AAEA,mBAAmB;AACnB;IACI,YAAY;IACZ,YAAY;IACZ,cAAc;IACd,gBAAgB;IAChB,MAAM;IACN,sBAAsB;IACtB,aAAa;IACb,eAAe;IACf,yBAAyB;AAC7B;;AAEA,UAAU;AACV;IACI,YAAY;IACZ,YAAY;IACZ,kBAAkB;IAClB,SAAS;IACT,sBAAsB;IACtB,WAAW;IACX,eAAe;IACf,aAAa;IACb,iBAAiB;IACjB,cAAc;IACd,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;IACI,mBAAmB;AACvB;;AAEA,UAAU;AACV;IACI,yBAAyB;IACzB,YAAY;IACZ,aAAa;IACb,sBAAsB;IACtB,kBAAkB;AACtB;;AAEA,uBAAuB;AACvB;IACI;QACI,mBAAmB;QACnB,aAAa;IACjB;;IAEA;QACI,WAAW;IACf;AACJ;;AAEA,aAAa;AACb;IACI,mBAAmB;IACnB,WAAW;AACf;;AAEA,gBAAgB;AAChB;IACI,gBAAgB;IAChB,eAAe;IACf,gBAAgB;IAChB,mBAAmB;AACvB;;AAEA,kEAAkE;AAClE;IACI,aAAa;IACb,sBAAsB;AAC1B;;AAEA,mBAAmB;AACnB;IACI,uBAAuB;AAC3B;;AAEA,aAAa;AACb;IACI,gBAAgB;IAChB,eAAe;IACf,iBAAiB;AACrB;;AAEA,gBAAgB;AAChB;IACI,eAAe;IACf,YAAY;IACZ,iBAAiB;IACjB,UAAU;IACV,qBAAqB;IACrB,sBAAsB;IACtB,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;IACI,iBAAiB;IACjB,YAAY;IACZ,kBAAkB;IAClB,eAAe;AACnB;;AAEA;IACI,gBAAgB;AACpB;;AAEA,kBAAkB;AAClB;IACI,8BAA8B;AAClC;;AAEA,gBAAgB;AAChB;IACI,sBAAsB;IACtB,yBAAyB;AAC7B;;AAEA;IACI,kCAAkC;IAClC,eAAe;AACnB;;AAEA;IACI,cAAc;IACd,sBAAsB;AAC1B;;AAEA;IACI,cAAc;IACd,sBAAsB;AAC1B;;AAEA,yBAAyB;AACzB;IACI,gBAAgB;IAChB,iBAAiB;IACjB,cAAc;IACd,gBAAgB;AACpB;;AAEA,gBAAgB;AAChB;IACI,aAAa;IACb,eAAe;IACf,yBAAyB;IACzB,gBAAgB;IAChB,YAAY;AAChB;;AAEA,iBAAiB;AACjB;IACI,YAAY;IACZ,WAAW;IACX,WAAW;IACX,kBAAkB;AACtB;;AAEA,QAAQ;AACR;IACI,YAAY;AAChB;;AAEA;IACI,WAAW;IACX,aAAa;IACb,mCAAmC;AACvC;;AAEA;IACI,WAAW;AACf;;AAEA;;IAEI,eAAe;IACf,WAAW;AACf;;AAEA,YAAY;AACZ;IACI,eAAe;IACf,YAAY;IACZ,SAAS;IACT,UAAU;IACV,qBAAqB;IACrB,sBAAsB;IACtB,iBAAiB;IACjB,kBAAkB;AACtB;;AAEA;IACI,iBAAiB;IACjB,YAAY;IACZ,kBAAkB;IAClB,eAAe;AACnB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,sBAAsB;AAC1B;;AAEA,kBAAkB;AAClB;IACI,8BAA8B;AAClC;;AAEA,UAAU;AACV;IACI,YAAY;IACZ,aAAa;IACb,mCAAmC;IACnC,8BAA8B;IAC9B,kBAAkB;IAClB,aAAa;AACjB;;AAEA;IACI,kBAAkB;IAClB,sBAAsB;IACtB,YAAY;AAChB;;AAEA;IACI,YAAY;IACZ,YAAY;IACZ,eAAe;IACf,gBAAgB;IAChB,kBAAkB;IAClB,iBAAiB;AACrB;;AAEA,yBAAyB;AACzB;IACI,WAAW;AACf;;AAEA,kBAAkB;AAClB;;IAEI,WAAW;AACf;;AAEA,YAAY;AACZ;IACI,wBAAwB;IACxB,gBAAgB;AACpB","sourcesContent":["/* 設定タブ */\n#axp_config_div_content {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    height: 100%;\n}\n\n/* 左側：ナビゲーションメニュー */\n#axp_config_div_nav {\n    width: 200px;\n    height: 100%;\n    overflow: auto;\n    position: sticky;\n    top: 0;\n    background-color: #eee;\n    padding: 10px;\n    /* iPad跳ね返り防止 */\n    overscroll-behavior: none;\n}\n\n/* ナビボタン */\n#axp_config_div_nav button {\n    width: 160px;\n    height: 40px;\n    border-radius: 6px;\n    border: 0;\n    background-color: #eee;\n    color: #111;\n    cursor: pointer;\n    margin: 1px 0;\n    padding-left: 8px;\n    font-size: 1em;\n    font-weight: bold;\n    text-align: left;\n}\n\n#axp_config_div_nav button.axpc_ACTIVE {\n    background: #E09C35;\n}\n\n/* 本文：外枠 */\n.axpc_config_chapter {\n    width: calc(100% - 200px);\n    height: 100%;\n    padding: 10px;\n    background-color: #eee;\n    overflow-y: scroll;\n}\n\n/* ブラウザの横幅が599px以下の場合 */\n@media (max-width: 599px) {\n    #axp_config_div_nav {\n        /* ナビゲーションメニュー非表示 */\n        display: none;\n    }\n\n    .axpc_config_chapter {\n        width: 100%;\n    }\n}\n\n/* 本文：セクション */\n.axpc_config_section {\n    margin-bottom: 50px;\n    color: #111;\n}\n\n/* 本文：セクション見出し */\n.axpc_config_sectionHeader {\n    background: #ddf;\n    margin-top: 8px;\n    padding: 8px 8px;\n    font-weight: bolder;\n}\n\n/* 設定用共通グループ（クラスが設定されていると、自動的にaxpc_config_div_headerをもつdiv要素を作成） */\n.axpc_config_group {\n    padding: 16px;\n    border: 2px #ddd solid;\n}\n\n/* 外部リンク部分のはみ出し回避 */\n.axpc_config_group a {\n    overflow-wrap: anywhere;\n}\n\n/* 設定用共通見出し */\n.axpc_config_groupHeader {\n    background: #ddd;\n    margin-top: 8px;\n    padding: 4px 16px;\n}\n\n/* キャンバス履歴テーブル */\n#axp_config_ul_canvasSizeHistory {\n    margin-top: 8px;\n    width: 200px;\n    margin: 0 0 8px 0;\n    padding: 0;\n    list-style-type: none;\n    border: 1px solid #aaa;\n    max-height: 220px;\n    overflow-y: auto;\n}\n\n#axp_config_ul_canvasSizeHistory>li {\n    padding: 2px 10px;\n    height: 25px;\n    text-align: center;\n    cursor: pointer;\n}\n\n#axp_config_ul_canvasSizeHistory>li:nth-child(even) {\n    background: #ddd;\n}\n\n/* 注意：evenより優先度高 */\n#axp_config_ul_canvasSizeHistory>li[data-selected=\"true\"] {\n    background: #f7a312 !important;\n}\n\n/* ショートカットテーブル */\n.axpc_config_table {\n    border: 2px solid #aaa;\n    border-collapse: collapse;\n}\n\n.axpc_config_table td:nth-child(1) {\n    font-family: 'Consolas', monospace;\n    font-size: 12pt;\n}\n\n.axpc_config_table th {\n    padding: 0 8px;\n    background-color: #ddf;\n}\n\n.axpc_config_table td {\n    padding: 0 8px;\n    border: 1px solid #aaa;\n}\n\n/* 設定用のカラーパレット表示（モックアップ）*/\n#axp_config_div_paletteScroll {\n    max-width: 228px;\n    max-height: 228px;\n    overflow: auto;\n    background: #ccc;\n}\n\n/* 設定用カラーパレット枠 */\n#axp_config_div_paletteBox {\n    display: flex;\n    flex-wrap: wrap;\n    align-content: flex-start;\n    background: #333;\n    padding: 4px;\n}\n\n/* 設定用カラーパレット単色 */\n.axpc_config_colorRect {\n    height: 20px;\n    width: 20px;\n    margin: 1px;\n    border-radius: 3px;\n}\n\n/* 拡大率 */\n#axp_config_div_scale {\n    width: 200px;\n}\n\n#axp_config_div_scaleButton {\n    width: 100%;\n    display: grid;\n    grid-template-columns: 1fr 30px 1fr;\n}\n\n#axp_config_button_addScale {\n    width: 100%;\n}\n\n#axp_config_button_deleteScale,\n#axp_config_button_resetScale {\n    margin-top: 8px;\n    width: 100%;\n}\n\n/* 拡大率テーブル */\n#axp_config_ul_scale {\n    margin-top: 8px;\n    width: 200px;\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    border: 1px solid #aaa;\n    max-height: 352px;\n    overflow-y: scroll;\n}\n\n#axp_config_ul_scale>li {\n    padding: 2px 10px;\n    height: 25px;\n    text-align: center;\n    cursor: pointer;\n}\n\n#axp_config_ul_scale>li:nth-child(even) {\n    background: #ddd;\n}\n\n#axp_config_ul_scale>li[data-value=\"100\"] {\n    border: 1px solid #333;\n}\n\n/* 注意：evenより優先度高 */\n#axp_config_ul_scale>li[data-selected=\"true\"] {\n    background: #f7a312 !important;\n}\n\n/* カラータグ */\n#axp_config_div_colorTag {\n    width: 300px;\n    display: grid;\n    grid-template-rows: repeat(4, 34px);\n    grid-template-columns: 1fr 1fr;\n    margin-bottom: 8px;\n    gap: 4px 10px;\n}\n\n.axpc_config_div_colorTag {\n    border-radius: 5px;\n    border: #222 solid 2px;\n    width: 154px;\n}\n\n.axpc_config_text_colorTag {\n    width: 130px;\n    height: 30px;\n    font-size: 13px;\n    text-align: left;\n    border-radius: 5px;\n    padding-left: 4px;\n}\n\n/* キーカスタマイズ用拡大率セレクトボックス */\n.axpc_config_select_scaleTable {\n    width: 24px;\n}\n\n/* キーカスタマイズ用数値入力 */\n.axpc_config_number_sizeValue,\n.axpc_config_number_scaleValue {\n    width: 60px;\n}\n\n/* バージョン情報 */\n#axp_config_div_versionInfo {\n    -webkit-user-select: all;\n    user-select: all;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/icon.css":
/*!****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/icon.css ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/caution.png */ "./resource/caution.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/information.png */ "./resource/information.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/ng.png */ "./resource/ng.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/window_colormaker.png */ "./resource/window_colormaker.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_4___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/window_all_down.png */ "./resource/window_all_down.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_5___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/window_all_up.png */ "./resource/window_all_up.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_6___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/window_pen.png */ "./resource/window_pen.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_7___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/window_layer.png */ "./resource/window_layer.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_8___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/window_palette.png */ "./resource/window_palette.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_9___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/window_subtool.png */ "./resource/window_subtool.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_10___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/eye_on.png */ "./resource/eye_on.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_11___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/eye_off.png */ "./resource/eye_off.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_12___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/lock.png */ "./resource/lock.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_13___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/unlock.png */ "./resource/unlock.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_14___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/mask_on.png */ "./resource/mask_on.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_15___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/flip_h.png */ "./resource/flip_h.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_16___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/flip_v.png */ "./resource/flip_v.png"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_4___);
var ___CSS_LOADER_URL_REPLACEMENT_5___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_5___);
var ___CSS_LOADER_URL_REPLACEMENT_6___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_6___);
var ___CSS_LOADER_URL_REPLACEMENT_7___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_7___);
var ___CSS_LOADER_URL_REPLACEMENT_8___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_8___);
var ___CSS_LOADER_URL_REPLACEMENT_9___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_9___);
var ___CSS_LOADER_URL_REPLACEMENT_10___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_10___);
var ___CSS_LOADER_URL_REPLACEMENT_11___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_11___);
var ___CSS_LOADER_URL_REPLACEMENT_12___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_12___);
var ___CSS_LOADER_URL_REPLACEMENT_13___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_13___);
var ___CSS_LOADER_URL_REPLACEMENT_14___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_14___);
var ___CSS_LOADER_URL_REPLACEMENT_15___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_15___);
var ___CSS_LOADER_URL_REPLACEMENT_16___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_16___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* アイコン */

.axpc_icon_msg_caution {
    background-repeat: no-repeat;
    flex: 0 0 24px;
    width: 24px;
    height: 24px;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
}

.axpc_icon_msg_information {
    background-repeat: no-repeat;
    flex: 0 0 24px;
    width: 24px;
    height: 24px;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});
}

.axpc_icon_msg_ng {
    background-repeat: no-repeat;
    flex: 0 0 24px;
    width: 24px;
    height: 24px;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_2___});
}

.axpc_icon_msg_color {
    background-repeat: no-repeat;
    flex: 0 0 24px;
    width: 24px;
    height: 24px;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_3___});
}

/* ツールウィンドウ */
.axpc_icon_window_all_down {
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_4___});
    background-position: center;
}

.axpc_icon_window_all_up {
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_5___});
    background-position: center;
}

.axpc_icon_window_pen {
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_6___});
    background-position: center;
}

.axpc_icon_window_layer {
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_7___});
    background-position: center;
}

.axpc_icon_window_colormaker {
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_3___});
    background-position: center;
}

.axpc_icon_window_palette {
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_8___});
    background-position: center;
}

.axpc_icon_window_subtool {
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_9___});
    background-position: center;
}

/* レイヤー */
.axpc_icon_eyeON {
    background: center no-repeat url(${___CSS_LOADER_URL_REPLACEMENT_10___});
}

.axpc_icon_eyeOFF {
    background: #555 center no-repeat url(${___CSS_LOADER_URL_REPLACEMENT_11___});
}

.axpc_icon_lockON {
    background-color: #aa3;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_12___});
}

.axpc_icon_lockOFF {
    background-color: #555;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_13___});
}

.axpc_icon_maskON {
    background: #ff4 center no-repeat url(${___CSS_LOADER_URL_REPLACEMENT_14___});
}

.axpc_icon_maskOFF {
    background: #555 center no-repeat url(${___CSS_LOADER_URL_REPLACEMENT_14___});
}

.axpc_icon_flipH {
    background: center no-repeat url(${___CSS_LOADER_URL_REPLACEMENT_15___});
}

.axpc_icon_flipV {
    background: center no-repeat url(${___CSS_LOADER_URL_REPLACEMENT_16___});
}

/* 設定の見出し調整用 */
.axpc_icon_span {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    vertical-align: middle;
    width: 28px;
    height: 28px;
}

/* ハンバーガーメニュー */
.axpc_icon_humburger,
.axpc_icon_humburger::before,
.axpc_icon_humburger::after {
    display: block;
    background-color: #fff;
    position: absolute;
    height: 4px;
    width: 30px;
    transition: transform 400ms cubic-bezier(0.23, 1, 0.32, 1);
    border-radius: 2px;
}

.axpc_icon_humburger::before {
    content: '';
    margin-top: -8px;
}

.axpc_icon_humburger::after {
    content: '';
    margin-top: 8px;
}

/* ハンバーガーメニュー ボタン変化 */
#axp_main_checkbox_hamburger:checked+#axp_main_label_hamburger .axpc_icon_humburger::before {
    margin-top: 0px;
    transform: rotate(45deg);
}

#axp_main_checkbox_hamburger:checked+#axp_main_label_hamburger .axpc_icon_humburger {
    background: rgba(255, 255, 255, 0);
}

#axp_main_checkbox_hamburger:checked+#axp_main_label_hamburger .axpc_icon_humburger::after {
    margin-top: 0px;
    transform: rotate(-45deg);
}`, "",{"version":3,"sources":["webpack://./src/css/icon.css"],"names":[],"mappings":"AAAA,SAAS;;AAET;IACI,4BAA4B;IAC5B,cAAc;IACd,WAAW;IACX,YAAY;IACZ,yDAAmD;AACvD;;AAEA;IACI,4BAA4B;IAC5B,cAAc;IACd,WAAW;IACX,YAAY;IACZ,yDAAuD;AAC3D;;AAEA;IACI,4BAA4B;IAC5B,cAAc;IACd,WAAW;IACX,YAAY;IACZ,yDAA8C;AAClD;;AAEA;IACI,4BAA4B;IAC5B,cAAc;IACd,WAAW;IACX,YAAY;IACZ,yDAA6D;AACjE;;AAEA,aAAa;AACb;IACI,4BAA4B;IAC5B,yDAA2D;IAC3D,2BAA2B;AAC/B;;AAEA;IACI,4BAA4B;IAC5B,yDAAyD;IACzD,2BAA2B;AAC/B;;AAEA;IACI,4BAA4B;IAC5B,yDAAsD;IACtD,2BAA2B;AAC/B;;AAEA;IACI,4BAA4B;IAC5B,yDAAwD;IACxD,2BAA2B;AAC/B;;AAEA;IACI,4BAA4B;IAC5B,yDAA6D;IAC7D,2BAA2B;AAC/B;;AAEA;IACI,4BAA4B;IAC5B,yDAA0D;IAC1D,2BAA2B;AAC/B;;AAEA;IACI,4BAA4B;IAC5B,yDAA0D;IAC1D,2BAA2B;AAC/B;;AAEA,SAAS;AACT;IACI,qEAA6D;AACjE;;AAEA;IACI,0EAAmE;AACvE;;AAEA;IACI,sBAAsB;IACtB,0DAAgD;AACpD;;AAEA;IACI,sBAAsB;IACtB,0DAAkD;AACtD;;AAEA;IACI,0EAAmE;AACvE;;AAEA;IACI,0EAAmE;AACvE;;AAEA;IACI,qEAA6D;AACjE;;AAEA;IACI,qEAA6D;AACjE;;AAEA,cAAc;AACd;IACI,oBAAoB;IACpB,mBAAmB;IACnB,uBAAuB;IACvB,sBAAsB;IACtB,WAAW;IACX,YAAY;AAChB;;AAEA,eAAe;AACf;;;IAGI,cAAc;IACd,sBAAsB;IACtB,kBAAkB;IAClB,WAAW;IACX,WAAW;IACX,0DAA0D;IAC1D,kBAAkB;AACtB;;AAEA;IACI,WAAW;IACX,gBAAgB;AACpB;;AAEA;IACI,WAAW;IACX,eAAe;AACnB;;AAEA,qBAAqB;AACrB;IACI,eAAe;IACf,wBAAwB;AAC5B;;AAEA;IACI,kCAAkC;AACtC;;AAEA;IACI,eAAe;IACf,yBAAyB;AAC7B","sourcesContent":["/* アイコン */\n\n.axpc_icon_msg_caution {\n    background-repeat: no-repeat;\n    flex: 0 0 24px;\n    width: 24px;\n    height: 24px;\n    background-image: url('../../resource/caution.png');\n}\n\n.axpc_icon_msg_information {\n    background-repeat: no-repeat;\n    flex: 0 0 24px;\n    width: 24px;\n    height: 24px;\n    background-image: url('../../resource/information.png');\n}\n\n.axpc_icon_msg_ng {\n    background-repeat: no-repeat;\n    flex: 0 0 24px;\n    width: 24px;\n    height: 24px;\n    background-image: url('../../resource/ng.png');\n}\n\n.axpc_icon_msg_color {\n    background-repeat: no-repeat;\n    flex: 0 0 24px;\n    width: 24px;\n    height: 24px;\n    background-image: url('../../resource/window_colormaker.png');\n}\n\n/* ツールウィンドウ */\n.axpc_icon_window_all_down {\n    background-repeat: no-repeat;\n    background-image: url('../../resource/window_all_down.png');\n    background-position: center;\n}\n\n.axpc_icon_window_all_up {\n    background-repeat: no-repeat;\n    background-image: url('../../resource/window_all_up.png');\n    background-position: center;\n}\n\n.axpc_icon_window_pen {\n    background-repeat: no-repeat;\n    background-image: url('../../resource/window_pen.png');\n    background-position: center;\n}\n\n.axpc_icon_window_layer {\n    background-repeat: no-repeat;\n    background-image: url('../../resource/window_layer.png');\n    background-position: center;\n}\n\n.axpc_icon_window_colormaker {\n    background-repeat: no-repeat;\n    background-image: url('../../resource/window_colormaker.png');\n    background-position: center;\n}\n\n.axpc_icon_window_palette {\n    background-repeat: no-repeat;\n    background-image: url('../../resource/window_palette.png');\n    background-position: center;\n}\n\n.axpc_icon_window_subtool {\n    background-repeat: no-repeat;\n    background-image: url('../../resource/window_subtool.png');\n    background-position: center;\n}\n\n/* レイヤー */\n.axpc_icon_eyeON {\n    background: center no-repeat url('../../resource/eye_on.png');\n}\n\n.axpc_icon_eyeOFF {\n    background: #555 center no-repeat url('../../resource/eye_off.png');\n}\n\n.axpc_icon_lockON {\n    background-color: #aa3;\n    background-image: url('../../resource/lock.png');\n}\n\n.axpc_icon_lockOFF {\n    background-color: #555;\n    background-image: url('../../resource/unlock.png');\n}\n\n.axpc_icon_maskON {\n    background: #ff4 center no-repeat url('../../resource/mask_on.png');\n}\n\n.axpc_icon_maskOFF {\n    background: #555 center no-repeat url('../../resource/mask_on.png');\n}\n\n.axpc_icon_flipH {\n    background: center no-repeat url('../../resource/flip_h.png');\n}\n\n.axpc_icon_flipV {\n    background: center no-repeat url('../../resource/flip_v.png');\n}\n\n/* 設定の見出し調整用 */\n.axpc_icon_span {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    vertical-align: middle;\n    width: 28px;\n    height: 28px;\n}\n\n/* ハンバーガーメニュー */\n.axpc_icon_humburger,\n.axpc_icon_humburger::before,\n.axpc_icon_humburger::after {\n    display: block;\n    background-color: #fff;\n    position: absolute;\n    height: 4px;\n    width: 30px;\n    transition: transform 400ms cubic-bezier(0.23, 1, 0.32, 1);\n    border-radius: 2px;\n}\n\n.axpc_icon_humburger::before {\n    content: '';\n    margin-top: -8px;\n}\n\n.axpc_icon_humburger::after {\n    content: '';\n    margin-top: 8px;\n}\n\n/* ハンバーガーメニュー ボタン変化 */\n#axp_main_checkbox_hamburger:checked+#axp_main_label_hamburger .axpc_icon_humburger::before {\n    margin-top: 0px;\n    transform: rotate(45deg);\n}\n\n#axp_main_checkbox_hamburger:checked+#axp_main_label_hamburger .axpc_icon_humburger {\n    background: rgba(255, 255, 255, 0);\n}\n\n#axp_main_checkbox_hamburger:checked+#axp_main_label_hamburger .axpc_icon_humburger::after {\n    margin-top: 0px;\n    transform: rotate(-45deg);\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/input_button.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/input_button.css ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* ボタン共通 */
.axpc_button {
    font-family: monospace, sans-serif;
    cursor: pointer;
    height: 30px;
    padding: 0px 0px;
    text-decoration: none;
    text-align: center;
    border-top: 2px solid #777;
    border-left: 2px solid #777;
    border-right: 2px solid #333;
    border-bottom: 2px solid #333;
    border-radius: 5px;
    color: #eee;
    background: #555;
    font-size: 14px;
}

.axpc_button:hover {
    /*
    background: #888;
    */
    border: 2px solid #bbb;
}

.axpc_button:active {
    background: linear-gradient(#222, #444);
    border: 2px solid #333;
}

.axpc_button[data-selected="true"] {
    background: #aaa;
}

.axpc_button:disabled {
    background: #aaa;
}

.axpc_button_width260 {
    margin-top: 4px;
    width: 260px;
}`, "",{"version":3,"sources":["webpack://./src/css/input_button.css"],"names":[],"mappings":"AAAA,UAAU;AACV;IACI,kCAAkC;IAClC,eAAe;IACf,YAAY;IACZ,gBAAgB;IAChB,qBAAqB;IACrB,kBAAkB;IAClB,0BAA0B;IAC1B,2BAA2B;IAC3B,4BAA4B;IAC5B,6BAA6B;IAC7B,kBAAkB;IAClB,WAAW;IACX,gBAAgB;IAChB,eAAe;AACnB;;AAEA;IACI;;KAEC;IACD,sBAAsB;AAC1B;;AAEA;IACI,uCAAuC;IACvC,sBAAsB;AAC1B;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,eAAe;IACf,YAAY;AAChB","sourcesContent":["/* ボタン共通 */\n.axpc_button {\n    font-family: monospace, sans-serif;\n    cursor: pointer;\n    height: 30px;\n    padding: 0px 0px;\n    text-decoration: none;\n    text-align: center;\n    border-top: 2px solid #777;\n    border-left: 2px solid #777;\n    border-right: 2px solid #333;\n    border-bottom: 2px solid #333;\n    border-radius: 5px;\n    color: #eee;\n    background: #555;\n    font-size: 14px;\n}\n\n.axpc_button:hover {\n    /*\n    background: #888;\n    */\n    border: 2px solid #bbb;\n}\n\n.axpc_button:active {\n    background: linear-gradient(#222, #444);\n    border: 2px solid #333;\n}\n\n.axpc_button[data-selected=\"true\"] {\n    background: #aaa;\n}\n\n.axpc_button:disabled {\n    background: #aaa;\n}\n\n.axpc_button_width260 {\n    margin-top: 4px;\n    width: 260px;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/input_checkbox.css":
/*!**************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/input_checkbox.css ***!
  \**************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* チェックボックス共通 */
.axpc_checkbox {
    height: 24px;
}

.axpc_checkbox label {
    display: flex;
    align-items: center;
    cursor: pointer;
}

.axpc_checkbox input {
    height: 24px;
    width: 24px;
    margin-right: 4px;
}`, "",{"version":3,"sources":["webpack://./src/css/input_checkbox.css"],"names":[],"mappings":"AAAA,eAAe;AACf;IACI,YAAY;AAChB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,eAAe;AACnB;;AAEA;IACI,YAAY;IACZ,WAAW;IACX,iBAAiB;AACrB","sourcesContent":["/* チェックボックス共通 */\n.axpc_checkbox {\n    height: 24px;\n}\n\n.axpc_checkbox label {\n    display: flex;\n    align-items: center;\n    cursor: pointer;\n}\n\n.axpc_checkbox input {\n    height: 24px;\n    width: 24px;\n    margin-right: 4px;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/input_number.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/input_number.css ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* 数値入力共通 */
.axpc_number {
    min-height: 30px;
    margin: 4px 0;
}

.axpc_number input {
    width: 85px;
    height: 30px;
    padding-left: 4px;
}`, "",{"version":3,"sources":["webpack://./src/css/input_number.css"],"names":[],"mappings":"AAAA,WAAW;AACX;IACI,gBAAgB;IAChB,aAAa;AACjB;;AAEA;IACI,WAAW;IACX,YAAY;IACZ,iBAAiB;AACrB","sourcesContent":["/* 数値入力共通 */\n.axpc_number {\n    min-height: 30px;\n    margin: 4px 0;\n}\n\n.axpc_number input {\n    width: 85px;\n    height: 30px;\n    padding-left: 4px;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/input_radio.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/input_radio.css ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* ラジオボタン生成・装飾共通 */

.axpc_radio {
    font-size: 12px;
}

.axpc_radio input {
    display: none;
}

.axpc_radio input[type="radio"]:checked+label {
    font-weight: bold;
    color: #000;
    border: 2px solid #bf9701;
    background-color: #f7a312;
}

.axpc_radio label {
    color: #777;
    border: 2px solid #ddd;
    text-align: center;
    display: inline-block;
    padding: 5px 0px;
    width: 100px;
    border-radius: 0px;
}

.axpc_radio label:hover {
    color: #aaa;
    border: 2px solid #aaa;
    cursor: pointer;
}

.axpc_radio button {
    color: #777;
    border: 2px solid #000;
    text-align: center;
    display: inline-block;
    padding: 5px 0px;
    width: 100px;
    margin: 2px;
    border-radius: 50px;
}

.axpc_radio button:hover {
    color: #aaa;
    border: 2px solid #aaa;
    cursor: pointer;
}

.axpc_radio button:active {
    color: #000;
    border: 2px solid #444;
}

/* ソースデータ。このspan要素をもとにradio要素をjsで生成する */
.axpc_radio span {
    display: none;
}`, "",{"version":3,"sources":["webpack://./src/css/input_radio.css"],"names":[],"mappings":"AAAA,kBAAkB;;AAElB;IACI,eAAe;AACnB;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,iBAAiB;IACjB,WAAW;IACX,yBAAyB;IACzB,yBAAyB;AAC7B;;AAEA;IACI,WAAW;IACX,sBAAsB;IACtB,kBAAkB;IAClB,qBAAqB;IACrB,gBAAgB;IAChB,YAAY;IACZ,kBAAkB;AACtB;;AAEA;IACI,WAAW;IACX,sBAAsB;IACtB,eAAe;AACnB;;AAEA;IACI,WAAW;IACX,sBAAsB;IACtB,kBAAkB;IAClB,qBAAqB;IACrB,gBAAgB;IAChB,YAAY;IACZ,WAAW;IACX,mBAAmB;AACvB;;AAEA;IACI,WAAW;IACX,sBAAsB;IACtB,eAAe;AACnB;;AAEA;IACI,WAAW;IACX,sBAAsB;AAC1B;;AAEA,uCAAuC;AACvC;IACI,aAAa;AACjB","sourcesContent":["/* ラジオボタン生成・装飾共通 */\n\n.axpc_radio {\n    font-size: 12px;\n}\n\n.axpc_radio input {\n    display: none;\n}\n\n.axpc_radio input[type=\"radio\"]:checked+label {\n    font-weight: bold;\n    color: #000;\n    border: 2px solid #bf9701;\n    background-color: #f7a312;\n}\n\n.axpc_radio label {\n    color: #777;\n    border: 2px solid #ddd;\n    text-align: center;\n    display: inline-block;\n    padding: 5px 0px;\n    width: 100px;\n    border-radius: 0px;\n}\n\n.axpc_radio label:hover {\n    color: #aaa;\n    border: 2px solid #aaa;\n    cursor: pointer;\n}\n\n.axpc_radio button {\n    color: #777;\n    border: 2px solid #000;\n    text-align: center;\n    display: inline-block;\n    padding: 5px 0px;\n    width: 100px;\n    margin: 2px;\n    border-radius: 50px;\n}\n\n.axpc_radio button:hover {\n    color: #aaa;\n    border: 2px solid #aaa;\n    cursor: pointer;\n}\n\n.axpc_radio button:active {\n    color: #000;\n    border: 2px solid #444;\n}\n\n/* ソースデータ。このspan要素をもとにradio要素をjsで生成する */\n.axpc_radio span {\n    display: none;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/input_range.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/input_range.css ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* レンジスライダー共通 */

.axpc_range {
    position: relative;
}

.axpc_range_label {
    pointer-events: none;
    z-index: 9999;
    position: absolute;
    top: 0;
    color: #fff;
    font-size: 12px;
    padding-left: 4px;
    padding-top: 1px;
    line-height: 14px;
}

.axpc_range_value {
    pointer-events: none;
    position: absolute;
    z-index: 9999;
    top: 0;
    width: 100px;
    color: #fff;
    font-size: 16px;
    font-family: "Arial Black", Arial, sans-serif;
    padding-left: 4px;
    padding-top: 15px;
    line-height: 14px;
}

.axpc_range input[type="range"] {
    appearance: none;
    position: relative;
    overflow: hidden;
    height: 32px;
    width: 100px;
    cursor: pointer;
    border-radius: 8px;
    border: 3px solid #444;
}

/* webkit */
/* 背景 */
.axpc_range input[type="range"]::-webkit-slider-runnable-track {
    background: linear-gradient(#000, #555);
}

.axpc_range input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 32px;
    height: 32px;
    /* つまみ */
    background: #999;
    border: 4px solid #777;
    border-radius: 8px;
    /* バー */
    box-shadow: -100vw 0 0 99vw #777;
}

/* moz */
/* 背景 */
.axpc_range input[type="range"]::-moz-range-track {
    height: 32px;
    background: linear-gradient(#000, #555);
}

.axpc_range input[type="range"]::-moz-range-thumb {
    height: 32px;
    width: 32px;
    /* つまみ */
    background: #999;
    border: 4px solid #777;
    border-radius: 8px !important;
    /* バー */
    box-shadow: -100vw 0 0 100vw #777;
    box-sizing: border-box;
}

#axp_layer_form_alpha input,
#axp_layer_form_alpha div {
    /* レイヤー不透明度width再指定 */
    width: 129px !important;
}

#axp_palette_form_column input,
#axp_palette_form_column div {
    /* パレット横幅width再指定 */
    width: 110px !important;
}

.axpc_range_width228 input,
.axpc_range_width228 div {
    /* 設定パレット横幅width再指定 */
    width: 228px !important;
}

#axp_tool_form_gridH *,
#axp_tool_form_gridV * {
    /* 設定パレット横幅width再指定 */
    width: 118px !important;
}`, "",{"version":3,"sources":["webpack://./src/css/input_range.css"],"names":[],"mappings":"AAAA,eAAe;;AAEf;IACI,kBAAkB;AACtB;;AAEA;IACI,oBAAoB;IACpB,aAAa;IACb,kBAAkB;IAClB,MAAM;IACN,WAAW;IACX,eAAe;IACf,iBAAiB;IACjB,gBAAgB;IAChB,iBAAiB;AACrB;;AAEA;IACI,oBAAoB;IACpB,kBAAkB;IAClB,aAAa;IACb,MAAM;IACN,YAAY;IACZ,WAAW;IACX,eAAe;IACf,6CAA6C;IAC7C,iBAAiB;IACjB,iBAAiB;IACjB,iBAAiB;AACrB;;AAEA;IACI,gBAAgB;IAChB,kBAAkB;IAClB,gBAAgB;IAChB,YAAY;IACZ,YAAY;IACZ,eAAe;IACf,kBAAkB;IAClB,sBAAsB;AAC1B;;AAEA,WAAW;AACX,OAAO;AACP;IACI,uCAAuC;AAC3C;;AAEA;IACI,gBAAgB;IAChB,WAAW;IACX,YAAY;IACZ,QAAQ;IACR,gBAAgB;IAChB,sBAAsB;IACtB,kBAAkB;IAClB,OAAO;IACP,gCAAgC;AACpC;;AAEA,QAAQ;AACR,OAAO;AACP;IACI,YAAY;IACZ,uCAAuC;AAC3C;;AAEA;IACI,YAAY;IACZ,WAAW;IACX,QAAQ;IACR,gBAAgB;IAChB,sBAAsB;IACtB,6BAA6B;IAC7B,OAAO;IACP,iCAAiC;IACjC,sBAAsB;AAC1B;;AAEA;;IAEI,qBAAqB;IACrB,uBAAuB;AAC3B;;AAEA;;IAEI,mBAAmB;IACnB,uBAAuB;AAC3B;;AAEA;;IAEI,qBAAqB;IACrB,uBAAuB;AAC3B;;AAEA;;IAEI,qBAAqB;IACrB,uBAAuB;AAC3B","sourcesContent":["/* レンジスライダー共通 */\n\n.axpc_range {\n    position: relative;\n}\n\n.axpc_range_label {\n    pointer-events: none;\n    z-index: 9999;\n    position: absolute;\n    top: 0;\n    color: #fff;\n    font-size: 12px;\n    padding-left: 4px;\n    padding-top: 1px;\n    line-height: 14px;\n}\n\n.axpc_range_value {\n    pointer-events: none;\n    position: absolute;\n    z-index: 9999;\n    top: 0;\n    width: 100px;\n    color: #fff;\n    font-size: 16px;\n    font-family: \"Arial Black\", Arial, sans-serif;\n    padding-left: 4px;\n    padding-top: 15px;\n    line-height: 14px;\n}\n\n.axpc_range input[type=\"range\"] {\n    appearance: none;\n    position: relative;\n    overflow: hidden;\n    height: 32px;\n    width: 100px;\n    cursor: pointer;\n    border-radius: 8px;\n    border: 3px solid #444;\n}\n\n/* webkit */\n/* 背景 */\n.axpc_range input[type=\"range\"]::-webkit-slider-runnable-track {\n    background: linear-gradient(#000, #555);\n}\n\n.axpc_range input[type=\"range\"]::-webkit-slider-thumb {\n    appearance: none;\n    width: 32px;\n    height: 32px;\n    /* つまみ */\n    background: #999;\n    border: 4px solid #777;\n    border-radius: 8px;\n    /* バー */\n    box-shadow: -100vw 0 0 99vw #777;\n}\n\n/* moz */\n/* 背景 */\n.axpc_range input[type=\"range\"]::-moz-range-track {\n    height: 32px;\n    background: linear-gradient(#000, #555);\n}\n\n.axpc_range input[type=\"range\"]::-moz-range-thumb {\n    height: 32px;\n    width: 32px;\n    /* つまみ */\n    background: #999;\n    border: 4px solid #777;\n    border-radius: 8px !important;\n    /* バー */\n    box-shadow: -100vw 0 0 100vw #777;\n    box-sizing: border-box;\n}\n\n#axp_layer_form_alpha input,\n#axp_layer_form_alpha div {\n    /* レイヤー不透明度width再指定 */\n    width: 129px !important;\n}\n\n#axp_palette_form_column input,\n#axp_palette_form_column div {\n    /* パレット横幅width再指定 */\n    width: 110px !important;\n}\n\n.axpc_range_width228 input,\n.axpc_range_width228 div {\n    /* 設定パレット横幅width再指定 */\n    width: 228px !important;\n}\n\n#axp_tool_form_gridH *,\n#axp_tool_form_gridV * {\n    /* 設定パレット横幅width再指定 */\n    width: 118px !important;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/input_toggle.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/input_toggle.css ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* 有／無トグルスイッチ共通 */

.axpc_toggle_switch {
    position: relative;
    width: 55px;
    height: 32px;
    margin: 0px 0px;
    border-radius: 50px;
    overflow: hidden;
    cursor: pointer;
    background: #aaa5;
}

.axpc_toggle_switch input[type=checkbox] {
    display: none;
}

.axpc_toggle_switch::before {
    content: "";
    position: absolute;
    top: 0;
    left: -55px;
    width: 100%;
    height: 100%;
    display: block;
    -webkit-transition: 0.2s ease-out;
    transition: 0.2s ease-out;
    background: rgb(224, 156, 53);
}

.axpc_toggle_switch::after {
    content: "無";
    position: absolute;
    top: 2px;
    left: 2px;
    width: 28px;
    height: 28px;
    display: block;
    border-radius: 50px;
    background: #fff;
    box-shadow: 0 9px 28px -6px rgba(0, 0, 0, 0.3);
    -webkit-transition: 0.2s ease-out;
    transition: 0.2s ease-out;
    text-align: center;
    padding: 9px 0 0;
    line-height: 1;
    font-size: 12px;
    font-weight: bold;
    color: #333;
    letter-spacing: .5px;
    box-sizing: border-box;
}

.axpc_toggle_switch[data-checked="true"]::before {
    left: 0;
}

.axpc_toggle_switch[data-checked="true"]::after {
    content: "有";
    left: 24px;
    box-shadow: 0 9px 28px -6px rgba(0, 0, 0, 0.5);
    color: #333;
    padding: 9px 0 0 1px;
}`, "",{"version":3,"sources":["webpack://./src/css/input_toggle.css"],"names":[],"mappings":"AAAA,iBAAiB;;AAEjB;IACI,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,eAAe;IACf,mBAAmB;IACnB,gBAAgB;IAChB,eAAe;IACf,iBAAiB;AACrB;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,WAAW;IACX,kBAAkB;IAClB,MAAM;IACN,WAAW;IACX,WAAW;IACX,YAAY;IACZ,cAAc;IACd,iCAAiC;IACjC,yBAAyB;IACzB,6BAA6B;AACjC;;AAEA;IACI,YAAY;IACZ,kBAAkB;IAClB,QAAQ;IACR,SAAS;IACT,WAAW;IACX,YAAY;IACZ,cAAc;IACd,mBAAmB;IACnB,gBAAgB;IAChB,8CAA8C;IAC9C,iCAAiC;IACjC,yBAAyB;IACzB,kBAAkB;IAClB,gBAAgB;IAChB,cAAc;IACd,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,oBAAoB;IACpB,sBAAsB;AAC1B;;AAEA;IACI,OAAO;AACX;;AAEA;IACI,YAAY;IACZ,UAAU;IACV,8CAA8C;IAC9C,WAAW;IACX,oBAAoB;AACxB","sourcesContent":["/* 有／無トグルスイッチ共通 */\n\n.axpc_toggle_switch {\n    position: relative;\n    width: 55px;\n    height: 32px;\n    margin: 0px 0px;\n    border-radius: 50px;\n    overflow: hidden;\n    cursor: pointer;\n    background: #aaa5;\n}\n\n.axpc_toggle_switch input[type=checkbox] {\n    display: none;\n}\n\n.axpc_toggle_switch::before {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: -55px;\n    width: 100%;\n    height: 100%;\n    display: block;\n    -webkit-transition: 0.2s ease-out;\n    transition: 0.2s ease-out;\n    background: rgb(224, 156, 53);\n}\n\n.axpc_toggle_switch::after {\n    content: \"無\";\n    position: absolute;\n    top: 2px;\n    left: 2px;\n    width: 28px;\n    height: 28px;\n    display: block;\n    border-radius: 50px;\n    background: #fff;\n    box-shadow: 0 9px 28px -6px rgba(0, 0, 0, 0.3);\n    -webkit-transition: 0.2s ease-out;\n    transition: 0.2s ease-out;\n    text-align: center;\n    padding: 9px 0 0;\n    line-height: 1;\n    font-size: 12px;\n    font-weight: bold;\n    color: #333;\n    letter-spacing: .5px;\n    box-sizing: border-box;\n}\n\n.axpc_toggle_switch[data-checked=\"true\"]::before {\n    left: 0;\n}\n\n.axpc_toggle_switch[data-checked=\"true\"]::after {\n    content: \"有\";\n    left: 24px;\n    box-shadow: 0 9px 28px -6px rgba(0, 0, 0, 0.5);\n    color: #333;\n    padding: 9px 0 0 1px;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/post.css":
/*!****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/post.css ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* 投稿タブ */

/* 投稿タブ 外枠 */
#axp_post_div_content {
    height: 100%;
    padding: 10px;
    background: #eee;
    color: #333;
    overflow: auto;
    display: flex;
    flex-direction: column;
    gap: 15px 0;
    align-items: center;
}

.axpc_post_frame,
#axp_post_div_notice,
#axp_post_div_button {
    width: 100%;
    max-width: 1024px;
}

.axpc_post_frame {
    display: grid;
    grid-template-rows: repeat(4, max-content);
    grid-template-columns: 150px 2px 1fr;
    grid-template-areas:
        "post_canvas  post_line  ."
        "post_canvas  post_line  post_div_input"
        "post_canvas  post_line  post_status"
        "post_canvas  post_line  .";
    gap: 10px 10px;
    padding: 10px;
    border-radius: 20px;
    background-color: #dedede;
}

/* image canvas */
.axpc_post_canvas {
    grid-area: post_canvas;
}

.acpc_post_canvas p {
    text-align: center;
}

/* サムネイルタイトル表示 */
#axp_post_div_thumbnailTitle {
    margin: auto;
    color: #1e7dc0;
    font-weight: 600;
    width: 134px;
    font-size: 13px;
    line-height: 16px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    word-break: break-all;
}

#axp_post_radio_bgWhite,
#axp_post_radio_bgWhite~label,
#axp_post_radio_bgTransparent,
#axp_post_radio_bgTransparent~label {
    cursor: pointer;
}


/* 罫線 */
.axpc_post_line {
    grid-area: post_line;
    background-image: linear-gradient(0deg, transparent, #aaa, transparent);
}

/* ※クリックで拡大表示 */
.axpc_post_thumbnailClick {
    text-align: center;
}

/* post form */
#axp_post_div_input {
    grid-area: post_div_input;
}

.axpc_post_input {
    display: grid;
    align-items: center;
    grid-template-columns: max-content max-content 1fr;
    grid-template-areas:
        "name_property      name_required      ."
        "text_name          text_name          text_name"
        "title_property     title_required     ."
        "text_title         text_title         text_title"
        "message_property   message_required   ."
        "textarea_message   textarea_message   textarea_message"
        "watchList          watchList          watchList";
}

.axpc_post_name_property,
.axpc_post_title_property,
.axpc_post_message_property {
    line-height: normal;
    background: #ccc;
    padding: 2px 10px 5px;
    border: #ddd 2px solid;
    border-bottom: none;
    border-radius: 10px 10px 0 0;
    /* border分のネガティブマージン */
    margin-left: -2px;
}

.axpc_post_name_required,
.axpc_post_title_required,
.axpc_post_message_required {
    font-size: 0.7em;
    font-weight: bold;
    background-color: #ff4444;
    color: #eee;
    padding: 0.2em 3px;
    border-radius: 5px;
    width: fit-content;
}

#axp_post_text_name,
#axp_post_text_title,
#axp_post_textarea_message {
    margin-bottom: 10px;
    /* タブ部分へのネガティブマージン */
    margin-top: -3px;
}

#axp_post_text_name,
#axp_post_text_title {
    line-height: 1.5lh;
    padding: 0 4px;
}

#axp_post_textarea_message {
    field-sizing: content;
    min-height: 4.5lh;
    height: auto;
    resize: vertical;
    line-height: 1.3em;
    padding: 5px;
    font-size: 13px;
}

.axpc_post_name_property {
    grid-area: name_property;
}

.axpc_post_name_required {
    grid-area: name_required;
}

#axp_post_text_name {
    grid-area: text_name;
}

.axpc_post_title_property {
    grid-area: title_property;
}

.axpc_post_title_required {
    grid-area: title_required;
}

#axp_post_text_title {
    grid-area: text_title;
}

.axpc_post_message_property {
    grid-area: message_property;
}

.axpc_post_message_required {
    grid-area: message_required;
}

#axp_post_textarea_message {
    grid-area: textarea_message;
}

.axpc_post_watchList {
    grid-area: watchList;
}

/* status */
.axpc_post_status {
    grid-area: post_status;
    display: grid;
    grid-template-areas:
        "size_property    size_colon    size_value"
        "bg_property      bg_colon      bg_value"
        "based_property   based_colon   based_value";
    grid-template-columns: max-content max-content 1fr;
    align-items: center;
}

[class^="axpc_post_status_"][class\$="_property"] {
    text-align: right;
}

.axpc_post_status_size_property {
    grid-area: size_property;
}

.axpc_post_status_bg_property {
    grid-area: bg_property;
}

.axpc_post_status_based_property {
    grid-area: based_property;
}

.axpc_post_status_size_value {
    grid-area: size_value;
}

.axpc_post_status_based_value {
    grid-area: based_value;
}

[class^="axpc_post_status_"][class\$="_colon"] {
    width: 1.5em;
    text-align: center;
}

.axpc_post_status_size_colon {
    grid-area: size_colon;
}

.axpc_post_status_bg_colon {
    grid-area: bg_colon;
}

.axpc_post_status_based_colon {
    grid-area: based_colon;
}

/* notice */
#axp_post_div_notice {
    padding: 20px;
    border-radius: 20px;
    background-color: #dedede;
}

#axp_post_div_notice>u {
    font-size: 120%;
    font-weight: bold;
}


#axp_post_div_notice div {
    text-indent: 1em;
    margin: 5px auto;
}

/* 投稿ボタン外枠 */
#axp_post_div_button {
    border-radius: 20px;
    background-color: #dedede;
    padding: 20px;
}

/* エラー時のメッセージ領域 */
#axp_post_span_message {
    color: #d00;
    font-weight: 600;
}

/* 投稿ボタン */
#axp_post_button_upload {
    width: 260px;
    display: block;
    margin: auto;
    transition: 0.5s ease-in-out;
    display: flex;
    align-items: center;
    justify-content: center;
}

@keyframes spin {
    0% {
        transform: rotate(0deg);
    }

    100% {
        transform: rotate(360deg);
    }
}

/* 投稿中 */
#axp_post_button_upload_loading {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 0.25rem solid rgba(255, 255, 255, 0.2);
    border-top-color: rgb(255, 255, 255);
    animation: spin 1s infinite linear;
}

/* ポップアップ */
.axpc_post_overlay {
    position: fixed;
    background: #0008;
    visibility: hidden;
    opacity: 0;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    display: flex;
    justify-content: center;
    align-items: center;
}

.axpc_post_overlay,
.axpc_post_overlay * {
    cursor: zoom-out;
}

.axpc_post_thumbnail {
    cursor: zoom-in;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 120px;
    height: 120px;
    margin: auto;
    background-color: #fff;
}

.axpc_post_thumbnail>img {
    background-color: #fff;
}

#axp_post_checkbox_popup {
    display: none;
}

#axp_post_checkbox_popup:checked+.axpc_post_overlay {
    visibility: visible;
    opacity: 1;
    z-index: 10;
    background-color: #0008;
    width: 100%;
}

.axpc_post_overlayWindow {
    border-radius: 15px;
    min-width: fit-content;
    max-width: 100%;
    max-height: 100%;
    position: fixed;
    z-index: 11;
    margin: 0 auto;
    padding: 15px;
    background: #fff5;
    line-height: 0;
}

.axpc_post_overlayCloseButton {
    cursor: pointer;
    position: absolute;
    box-sizing: border-box;
    width: 40px;
    height: 40px;
    top: -35px;
    right: -35px;
    border: #666 solid 5px;
    border-radius: 50%;
    text-decoration: none;
    color: #000;
    background: #fff;
    padding: 0;
}

.axpc_post_overlayCloseButton::after,
.axpc_post_overlayCloseButton::before {
    background-color: #666;
    border-radius: 15% 15% 15% 15% / 50% 50% 50% 50%;
    content: "";
    display: block;
    height: 22%;
    left: 10%;
    position: absolute;
    top: 38%;
    width: 80%;
}

.axpc_post_overlayCloseButton::before {
    transform: rotate(135deg);
}

.axpc_post_overlayCloseButton::after {
    transform: rotate(45deg);
}

.axpc_post_overlayCanvas {
    max-width: calc(100vw - 120px);
    max-height: calc(95vh - 110px);
    object-fit: contain;
    width: 100%;
    height: 100%;
}

/* ブラウザの横幅が599px以下の場合 */
@media (max-width: 599px) {
    .axpc_post_frame {
        display: flex;
        flex-direction: column;
    }

    /* 罫線 */
    .axpc_post_line {
        height: 2px;
        margin: 20px 10px;
        background: linear-gradient(90deg, transparent, #aaa, transparent)
    }
}`, "",{"version":3,"sources":["webpack://./src/css/post.css"],"names":[],"mappings":"AAAA,SAAS;;AAET,YAAY;AACZ;IACI,YAAY;IACZ,aAAa;IACb,gBAAgB;IAChB,WAAW;IACX,cAAc;IACd,aAAa;IACb,sBAAsB;IACtB,WAAW;IACX,mBAAmB;AACvB;;AAEA;;;IAGI,WAAW;IACX,iBAAiB;AACrB;;AAEA;IACI,aAAa;IACb,0CAA0C;IAC1C,oCAAoC;IACpC;;;;mCAI+B;IAC/B,cAAc;IACd,aAAa;IACb,mBAAmB;IACnB,yBAAyB;AAC7B;;AAEA,iBAAiB;AACjB;IACI,sBAAsB;AAC1B;;AAEA;IACI,kBAAkB;AACtB;;AAEA,gBAAgB;AAChB;IACI,YAAY;IACZ,cAAc;IACd,gBAAgB;IAChB,YAAY;IACZ,eAAe;IACf,iBAAiB;IACjB,oBAAoB;IACpB,qBAAqB;IACrB,aAAa;IACb,4BAA4B;IAC5B,gBAAgB;IAChB,qBAAqB;AACzB;;AAEA;;;;IAII,eAAe;AACnB;;;AAGA,OAAO;AACP;IACI,oBAAoB;IACpB,uEAAuE;AAC3E;;AAEA,eAAe;AACf;IACI,kBAAkB;AACtB;;AAEA,cAAc;AACd;IACI,yBAAyB;AAC7B;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,kDAAkD;IAClD;;;;;;;yDAOqD;AACzD;;AAEA;;;IAGI,mBAAmB;IACnB,gBAAgB;IAChB,qBAAqB;IACrB,sBAAsB;IACtB,mBAAmB;IACnB,4BAA4B;IAC5B,sBAAsB;IACtB,iBAAiB;AACrB;;AAEA;;;IAGI,gBAAgB;IAChB,iBAAiB;IACjB,yBAAyB;IACzB,WAAW;IACX,kBAAkB;IAClB,kBAAkB;IAClB,kBAAkB;AACtB;;AAEA;;;IAGI,mBAAmB;IACnB,oBAAoB;IACpB,gBAAgB;AACpB;;AAEA;;IAEI,kBAAkB;IAClB,cAAc;AAClB;;AAEA;IACI,qBAAqB;IACrB,iBAAiB;IACjB,YAAY;IACZ,gBAAgB;IAChB,kBAAkB;IAClB,YAAY;IACZ,eAAe;AACnB;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,oBAAoB;AACxB;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,qBAAqB;AACzB;;AAEA;IACI,2BAA2B;AAC/B;;AAEA;IACI,2BAA2B;AAC/B;;AAEA;IACI,2BAA2B;AAC/B;;AAEA;IACI,oBAAoB;AACxB;;AAEA,WAAW;AACX;IACI,sBAAsB;IACtB,aAAa;IACb;;;oDAGgD;IAChD,kDAAkD;IAClD,mBAAmB;AACvB;;AAEA;IACI,iBAAiB;AACrB;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,qBAAqB;AACzB;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,YAAY;IACZ,kBAAkB;AACtB;;AAEA;IACI,qBAAqB;AACzB;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,sBAAsB;AAC1B;;AAEA,WAAW;AACX;IACI,aAAa;IACb,mBAAmB;IACnB,yBAAyB;AAC7B;;AAEA;IACI,eAAe;IACf,iBAAiB;AACrB;;;AAGA;IACI,gBAAgB;IAChB,gBAAgB;AACpB;;AAEA,YAAY;AACZ;IACI,mBAAmB;IACnB,yBAAyB;IACzB,aAAa;AACjB;;AAEA,iBAAiB;AACjB;IACI,WAAW;IACX,gBAAgB;AACpB;;AAEA,UAAU;AACV;IACI,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,4BAA4B;IAC5B,aAAa;IACb,mBAAmB;IACnB,uBAAuB;AAC3B;;AAEA;IACI;QACI,uBAAuB;IAC3B;;IAEA;QACI,yBAAyB;IAC7B;AACJ;;AAEA,QAAQ;AACR;IACI,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,8CAA8C;IAC9C,oCAAoC;IACpC,kCAAkC;AACtC;;AAEA,WAAW;AACX;IACI,eAAe;IACf,iBAAiB;IACjB,kBAAkB;IAClB,UAAU;IACV,MAAM;IACN,OAAO;IACP,SAAS;IACT,QAAQ;IACR,aAAa;IACb,uBAAuB;IACvB,mBAAmB;AACvB;;AAEA;;IAEI,gBAAgB;AACpB;;AAEA;IACI,eAAe;IACf,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,YAAY;IACZ,aAAa;IACb,YAAY;IACZ,sBAAsB;AAC1B;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,mBAAmB;IACnB,UAAU;IACV,WAAW;IACX,uBAAuB;IACvB,WAAW;AACf;;AAEA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,eAAe;IACf,gBAAgB;IAChB,eAAe;IACf,WAAW;IACX,cAAc;IACd,aAAa;IACb,iBAAiB;IACjB,cAAc;AAClB;;AAEA;IACI,eAAe;IACf,kBAAkB;IAClB,sBAAsB;IACtB,WAAW;IACX,YAAY;IACZ,UAAU;IACV,YAAY;IACZ,sBAAsB;IACtB,kBAAkB;IAClB,qBAAqB;IACrB,WAAW;IACX,gBAAgB;IAChB,UAAU;AACd;;AAEA;;IAEI,sBAAsB;IACtB,gDAAgD;IAChD,WAAW;IACX,cAAc;IACd,WAAW;IACX,SAAS;IACT,kBAAkB;IAClB,QAAQ;IACR,UAAU;AACd;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,8BAA8B;IAC9B,8BAA8B;IAC9B,mBAAmB;IACnB,WAAW;IACX,YAAY;AAChB;;AAEA,uBAAuB;AACvB;IACI;QACI,aAAa;QACb,sBAAsB;IAC1B;;IAEA,OAAO;IACP;QACI,WAAW;QACX,iBAAiB;QACjB;IACJ;AACJ","sourcesContent":["/* 投稿タブ */\n\n/* 投稿タブ 外枠 */\n#axp_post_div_content {\n    height: 100%;\n    padding: 10px;\n    background: #eee;\n    color: #333;\n    overflow: auto;\n    display: flex;\n    flex-direction: column;\n    gap: 15px 0;\n    align-items: center;\n}\n\n.axpc_post_frame,\n#axp_post_div_notice,\n#axp_post_div_button {\n    width: 100%;\n    max-width: 1024px;\n}\n\n.axpc_post_frame {\n    display: grid;\n    grid-template-rows: repeat(4, max-content);\n    grid-template-columns: 150px 2px 1fr;\n    grid-template-areas:\n        \"post_canvas  post_line  .\"\n        \"post_canvas  post_line  post_div_input\"\n        \"post_canvas  post_line  post_status\"\n        \"post_canvas  post_line  .\";\n    gap: 10px 10px;\n    padding: 10px;\n    border-radius: 20px;\n    background-color: #dedede;\n}\n\n/* image canvas */\n.axpc_post_canvas {\n    grid-area: post_canvas;\n}\n\n.acpc_post_canvas p {\n    text-align: center;\n}\n\n/* サムネイルタイトル表示 */\n#axp_post_div_thumbnailTitle {\n    margin: auto;\n    color: #1e7dc0;\n    font-weight: 600;\n    width: 134px;\n    font-size: 13px;\n    line-height: 16px;\n    display: -webkit-box;\n    -webkit-line-clamp: 2;\n    line-clamp: 2;\n    -webkit-box-orient: vertical;\n    overflow: hidden;\n    word-break: break-all;\n}\n\n#axp_post_radio_bgWhite,\n#axp_post_radio_bgWhite~label,\n#axp_post_radio_bgTransparent,\n#axp_post_radio_bgTransparent~label {\n    cursor: pointer;\n}\n\n\n/* 罫線 */\n.axpc_post_line {\n    grid-area: post_line;\n    background-image: linear-gradient(0deg, transparent, #aaa, transparent);\n}\n\n/* ※クリックで拡大表示 */\n.axpc_post_thumbnailClick {\n    text-align: center;\n}\n\n/* post form */\n#axp_post_div_input {\n    grid-area: post_div_input;\n}\n\n.axpc_post_input {\n    display: grid;\n    align-items: center;\n    grid-template-columns: max-content max-content 1fr;\n    grid-template-areas:\n        \"name_property      name_required      .\"\n        \"text_name          text_name          text_name\"\n        \"title_property     title_required     .\"\n        \"text_title         text_title         text_title\"\n        \"message_property   message_required   .\"\n        \"textarea_message   textarea_message   textarea_message\"\n        \"watchList          watchList          watchList\";\n}\n\n.axpc_post_name_property,\n.axpc_post_title_property,\n.axpc_post_message_property {\n    line-height: normal;\n    background: #ccc;\n    padding: 2px 10px 5px;\n    border: #ddd 2px solid;\n    border-bottom: none;\n    border-radius: 10px 10px 0 0;\n    /* border分のネガティブマージン */\n    margin-left: -2px;\n}\n\n.axpc_post_name_required,\n.axpc_post_title_required,\n.axpc_post_message_required {\n    font-size: 0.7em;\n    font-weight: bold;\n    background-color: #ff4444;\n    color: #eee;\n    padding: 0.2em 3px;\n    border-radius: 5px;\n    width: fit-content;\n}\n\n#axp_post_text_name,\n#axp_post_text_title,\n#axp_post_textarea_message {\n    margin-bottom: 10px;\n    /* タブ部分へのネガティブマージン */\n    margin-top: -3px;\n}\n\n#axp_post_text_name,\n#axp_post_text_title {\n    line-height: 1.5lh;\n    padding: 0 4px;\n}\n\n#axp_post_textarea_message {\n    field-sizing: content;\n    min-height: 4.5lh;\n    height: auto;\n    resize: vertical;\n    line-height: 1.3em;\n    padding: 5px;\n    font-size: 13px;\n}\n\n.axpc_post_name_property {\n    grid-area: name_property;\n}\n\n.axpc_post_name_required {\n    grid-area: name_required;\n}\n\n#axp_post_text_name {\n    grid-area: text_name;\n}\n\n.axpc_post_title_property {\n    grid-area: title_property;\n}\n\n.axpc_post_title_required {\n    grid-area: title_required;\n}\n\n#axp_post_text_title {\n    grid-area: text_title;\n}\n\n.axpc_post_message_property {\n    grid-area: message_property;\n}\n\n.axpc_post_message_required {\n    grid-area: message_required;\n}\n\n#axp_post_textarea_message {\n    grid-area: textarea_message;\n}\n\n.axpc_post_watchList {\n    grid-area: watchList;\n}\n\n/* status */\n.axpc_post_status {\n    grid-area: post_status;\n    display: grid;\n    grid-template-areas:\n        \"size_property    size_colon    size_value\"\n        \"bg_property      bg_colon      bg_value\"\n        \"based_property   based_colon   based_value\";\n    grid-template-columns: max-content max-content 1fr;\n    align-items: center;\n}\n\n[class^=\"axpc_post_status_\"][class$=\"_property\"] {\n    text-align: right;\n}\n\n.axpc_post_status_size_property {\n    grid-area: size_property;\n}\n\n.axpc_post_status_bg_property {\n    grid-area: bg_property;\n}\n\n.axpc_post_status_based_property {\n    grid-area: based_property;\n}\n\n.axpc_post_status_size_value {\n    grid-area: size_value;\n}\n\n.axpc_post_status_based_value {\n    grid-area: based_value;\n}\n\n[class^=\"axpc_post_status_\"][class$=\"_colon\"] {\n    width: 1.5em;\n    text-align: center;\n}\n\n.axpc_post_status_size_colon {\n    grid-area: size_colon;\n}\n\n.axpc_post_status_bg_colon {\n    grid-area: bg_colon;\n}\n\n.axpc_post_status_based_colon {\n    grid-area: based_colon;\n}\n\n/* notice */\n#axp_post_div_notice {\n    padding: 20px;\n    border-radius: 20px;\n    background-color: #dedede;\n}\n\n#axp_post_div_notice>u {\n    font-size: 120%;\n    font-weight: bold;\n}\n\n\n#axp_post_div_notice div {\n    text-indent: 1em;\n    margin: 5px auto;\n}\n\n/* 投稿ボタン外枠 */\n#axp_post_div_button {\n    border-radius: 20px;\n    background-color: #dedede;\n    padding: 20px;\n}\n\n/* エラー時のメッセージ領域 */\n#axp_post_span_message {\n    color: #d00;\n    font-weight: 600;\n}\n\n/* 投稿ボタン */\n#axp_post_button_upload {\n    width: 260px;\n    display: block;\n    margin: auto;\n    transition: 0.5s ease-in-out;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n@keyframes spin {\n    0% {\n        transform: rotate(0deg);\n    }\n\n    100% {\n        transform: rotate(360deg);\n    }\n}\n\n/* 投稿中 */\n#axp_post_button_upload_loading {\n    width: 24px;\n    height: 24px;\n    border-radius: 50%;\n    border: 0.25rem solid rgba(255, 255, 255, 0.2);\n    border-top-color: rgb(255, 255, 255);\n    animation: spin 1s infinite linear;\n}\n\n/* ポップアップ */\n.axpc_post_overlay {\n    position: fixed;\n    background: #0008;\n    visibility: hidden;\n    opacity: 0;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.axpc_post_overlay,\n.axpc_post_overlay * {\n    cursor: zoom-out;\n}\n\n.axpc_post_thumbnail {\n    cursor: zoom-in;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 120px;\n    height: 120px;\n    margin: auto;\n    background-color: #fff;\n}\n\n.axpc_post_thumbnail>img {\n    background-color: #fff;\n}\n\n#axp_post_checkbox_popup {\n    display: none;\n}\n\n#axp_post_checkbox_popup:checked+.axpc_post_overlay {\n    visibility: visible;\n    opacity: 1;\n    z-index: 10;\n    background-color: #0008;\n    width: 100%;\n}\n\n.axpc_post_overlayWindow {\n    border-radius: 15px;\n    min-width: fit-content;\n    max-width: 100%;\n    max-height: 100%;\n    position: fixed;\n    z-index: 11;\n    margin: 0 auto;\n    padding: 15px;\n    background: #fff5;\n    line-height: 0;\n}\n\n.axpc_post_overlayCloseButton {\n    cursor: pointer;\n    position: absolute;\n    box-sizing: border-box;\n    width: 40px;\n    height: 40px;\n    top: -35px;\n    right: -35px;\n    border: #666 solid 5px;\n    border-radius: 50%;\n    text-decoration: none;\n    color: #000;\n    background: #fff;\n    padding: 0;\n}\n\n.axpc_post_overlayCloseButton::after,\n.axpc_post_overlayCloseButton::before {\n    background-color: #666;\n    border-radius: 15% 15% 15% 15% / 50% 50% 50% 50%;\n    content: \"\";\n    display: block;\n    height: 22%;\n    left: 10%;\n    position: absolute;\n    top: 38%;\n    width: 80%;\n}\n\n.axpc_post_overlayCloseButton::before {\n    transform: rotate(135deg);\n}\n\n.axpc_post_overlayCloseButton::after {\n    transform: rotate(45deg);\n}\n\n.axpc_post_overlayCanvas {\n    max-width: calc(100vw - 120px);\n    max-height: calc(95vh - 110px);\n    object-fit: contain;\n    width: 100%;\n    height: 100%;\n}\n\n/* ブラウザの横幅が599px以下の場合 */\n@media (max-width: 599px) {\n    .axpc_post_frame {\n        display: flex;\n        flex-direction: column;\n    }\n\n    /* 罫線 */\n    .axpc_post_line {\n        height: 2px;\n        margin: 20px 10px;\n        background: linear-gradient(90deg, transparent, #aaa, transparent)\n    }\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/reinvented-color-wheel.css":
/*!**********************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/reinvented-color-wheel.css ***!
  \**********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* カラーピッカー reinvented-color-wheel (WTFPL license) (https://github.com/luncheon/reinvented-color-wheel) */

.reinvented-color-wheel,
.reinvented-color-wheel--hue-wheel,
.reinvented-color-wheel--hue-handle,
.reinvented-color-wheel--sv-space,
.reinvented-color-wheel--sv-handle {
  touch-action: manipulation;
  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.reinvented-color-wheel {
  position: relative;
  display: inline-block;
  line-height: 0;
  border-radius: 50%;
}

.reinvented-color-wheel--hue-wheel {
  border-radius: 50%;
}

.reinvented-color-wheel--sv-space {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  margin: auto;
}

.reinvented-color-wheel--hue-handle,
.reinvented-color-wheel--sv-handle {
  position: absolute;
  box-sizing: border-box;
  border-radius: 50%;
  border: 2px solid white;
  box-shadow: 0 0 0 1px black inset;
}

.reinvented-color-wheel--hue-handle {
  pointer-events: none;
}`, "",{"version":3,"sources":["webpack://./src/css/reinvented-color-wheel.css"],"names":[],"mappings":"AAAA,wGAAwG;;AAExG;;;;;EAKE,0BAA0B;EAC1B,kBAAkB;EAClB,2BAA2B;EAC3B,wCAAwC;EACxC,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;AACnB;;AAEA;EACE,kBAAkB;EAClB,qBAAqB;EACrB,cAAc;EACd,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;EAClB,OAAO;EACP,MAAM;EACN,QAAQ;EACR,SAAS;EACT,YAAY;AACd;;AAEA;;EAEE,kBAAkB;EAClB,sBAAsB;EACtB,kBAAkB;EAClB,uBAAuB;EACvB,iCAAiC;AACnC;;AAEA;EACE,oBAAoB;AACtB","sourcesContent":["/* カラーピッカー reinvented-color-wheel (WTFPL license) (https://github.com/luncheon/reinvented-color-wheel) */\n\n.reinvented-color-wheel,\n.reinvented-color-wheel--hue-wheel,\n.reinvented-color-wheel--hue-handle,\n.reinvented-color-wheel--sv-space,\n.reinvented-color-wheel--sv-handle {\n  touch-action: manipulation;\n  touch-action: none;\n  -webkit-touch-callout: none;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.reinvented-color-wheel {\n  position: relative;\n  display: inline-block;\n  line-height: 0;\n  border-radius: 50%;\n}\n\n.reinvented-color-wheel--hue-wheel {\n  border-radius: 50%;\n}\n\n.reinvented-color-wheel--sv-space {\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  margin: auto;\n}\n\n.reinvented-color-wheel--hue-handle,\n.reinvented-color-wheel--sv-handle {\n  position: absolute;\n  box-sizing: border-box;\n  border-radius: 50%;\n  border: 2px solid white;\n  box-shadow: 0 0 0 1px black inset;\n}\n\n.reinvented-color-wheel--hue-handle {\n  pointer-events: none;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/saveload.css":
/*!********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/saveload.css ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* セーブ／ロード／自動保存から復元のサブ画面 */

#axp_saveload {
    position: absolute;
    z-index: 5000;
    left: 0;
    top: 0;
    height: 100%;
    width: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.5);
}

#axp_saveload>div {
    background-color: #eee;
    color: #000;
    border-color: #337;
    border-width: 4px;
    border-style: double;
    margin: 8px;
    padding: 8px;
    border-radius: 5px;
}

/* セーブスロットのHTMLを挿入するポイント */
#axp_saveload_div_insertHTML {
    background-color: #aaa;
    border: solid 0px;
    display: flex;
    justify-content: normal;
    flex-wrap: wrap;
    padding: 8px;
    cursor: pointer;
}

/* 閉じるボタン */
#axp_saveload_button_close {
    margin-top: 8px;
    font-weight: bolder;
    font-size: 15px;
    width: 100%;
}

.axpc_saveload_saveSlot,
.axpc_saveload_loadSlot {
    background-color: #ddd;
    width: 135px;
    min-height: 180px;
    border: solid 2px #000;
    border-radius: 10px;
    text-align: center;
    padding-top: 4px;
    font-size: 12px;
    font-weight: bold;
    line-height: 15px;
}

.axpc_saveload_saveSlot:hover {
    background-color: #faa;
}

.axpc_saveload_loadSlot:hover {
    background-color: #ffa;
}

.axpc_saveload_thumbnall {
    width: 124px;
    height: 124px;
    margin: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    border: #aaa solid 1px;
}

.axpc_saveload_refId {
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    line-clamp: 2;
    -webkit-box-orient: vertical;
    word-break: break-all;
    color: #00f;
    /* ブラウザがサポートしていない場合のフェールセーフ */
    max-height: 30px;
}`, "",{"version":3,"sources":["webpack://./src/css/saveload.css"],"names":[],"mappings":"AAAA,0BAA0B;;AAE1B;IACI,kBAAkB;IAClB,aAAa;IACb,OAAO;IACP,MAAM;IACN,YAAY;IACZ,WAAW;IACX,cAAc;IACd,oCAAoC;AACxC;;AAEA;IACI,sBAAsB;IACtB,WAAW;IACX,kBAAkB;IAClB,iBAAiB;IACjB,oBAAoB;IACpB,WAAW;IACX,YAAY;IACZ,kBAAkB;AACtB;;AAEA,0BAA0B;AAC1B;IACI,sBAAsB;IACtB,iBAAiB;IACjB,aAAa;IACb,uBAAuB;IACvB,eAAe;IACf,YAAY;IACZ,eAAe;AACnB;;AAEA,WAAW;AACX;IACI,eAAe;IACf,mBAAmB;IACnB,eAAe;IACf,WAAW;AACf;;AAEA;;IAEI,sBAAsB;IACtB,YAAY;IACZ,iBAAiB;IACjB,sBAAsB;IACtB,mBAAmB;IACnB,kBAAkB;IAClB,gBAAgB;IAChB,eAAe;IACf,iBAAiB;IACjB,iBAAiB;AACrB;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,YAAY;IACZ,aAAa;IACb,YAAY;IACZ,aAAa;IACb,mBAAmB;IACnB,uBAAuB;IACvB,sBAAsB;AAC1B;;AAEA;IACI,gBAAgB;IAChB,oBAAoB;IACpB,qBAAqB;IACrB,aAAa;IACb,4BAA4B;IAC5B,qBAAqB;IACrB,WAAW;IACX,6BAA6B;IAC7B,gBAAgB;AACpB","sourcesContent":["/* セーブ／ロード／自動保存から復元のサブ画面 */\n\n#axp_saveload {\n    position: absolute;\n    z-index: 5000;\n    left: 0;\n    top: 0;\n    height: 100%;\n    width: 100%;\n    overflow: auto;\n    background-color: rgba(0, 0, 0, 0.5);\n}\n\n#axp_saveload>div {\n    background-color: #eee;\n    color: #000;\n    border-color: #337;\n    border-width: 4px;\n    border-style: double;\n    margin: 8px;\n    padding: 8px;\n    border-radius: 5px;\n}\n\n/* セーブスロットのHTMLを挿入するポイント */\n#axp_saveload_div_insertHTML {\n    background-color: #aaa;\n    border: solid 0px;\n    display: flex;\n    justify-content: normal;\n    flex-wrap: wrap;\n    padding: 8px;\n    cursor: pointer;\n}\n\n/* 閉じるボタン */\n#axp_saveload_button_close {\n    margin-top: 8px;\n    font-weight: bolder;\n    font-size: 15px;\n    width: 100%;\n}\n\n.axpc_saveload_saveSlot,\n.axpc_saveload_loadSlot {\n    background-color: #ddd;\n    width: 135px;\n    min-height: 180px;\n    border: solid 2px #000;\n    border-radius: 10px;\n    text-align: center;\n    padding-top: 4px;\n    font-size: 12px;\n    font-weight: bold;\n    line-height: 15px;\n}\n\n.axpc_saveload_saveSlot:hover {\n    background-color: #faa;\n}\n\n.axpc_saveload_loadSlot:hover {\n    background-color: #ffa;\n}\n\n.axpc_saveload_thumbnall {\n    width: 124px;\n    height: 124px;\n    margin: auto;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border: #aaa solid 1px;\n}\n\n.axpc_saveload_refId {\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-line-clamp: 2;\n    line-clamp: 2;\n    -webkit-box-orient: vertical;\n    word-break: break-all;\n    color: #00f;\n    /* ブラウザがサポートしていない場合のフェールセーフ */\n    max-height: 30px;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/window.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/window.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* ツールウィンドウ共通 */

.axpc_window {
    width: 180px;
    height: auto;
    position: absolute;
    z-index: 1000;
    color: #fff;
    background-color: rgb(0, 0, 0, 0.3);
    box-shadow: 4px 4px 8px #000a;
    padding: 2px;
    border-radius: 8px;
    /*
    overflow: hidden;
    */
    /* すりガラス効果 */
    -webkit-backdrop-filter: blur(3px);
    backdrop-filter: blur(3px);
    line-height: 14px;
}

/* パレット編集時のアテンション */
.axpc_window_attention {
    background-color: rgb(255, 255, 0, 0.3);
}

/* ヘッダー部 */
.axpc_window_header {
    margin-top: -24px;
    justify-content: right;
    font-size: 15px;
    /* #axp_mainのfont-size指定(必要なし) */
    display: grid;
    grid-template-columns: minmax(18px, 30px) minmax(0px, 1fr) 24px;
    /* minmax(18px, 30px)→img、minmax(0px, 1fr)→文字、24px→▲ */
    margin: -2px -2px 0;
    /* ドラッグ範囲のクラスaxpc_windowとのズレを相殺させる */
    padding: 0;
    height: 30px;
}

/* ツール名 文字 */
.axpc_window_header>div:first-of-type {
    font-size: 13px;
    height: 30px;
    line-height: 30px;
    overflow: hidden;
    /* grid位置指定 アイコンがない場合は1/1/2/3; */
    grid-area: 1/2/2/3;
}

/* アイコン表示 span */
.axpc_window_header>span {
    display: inline-flex;
    align-items: center;
    /* imgを中央に */
    justify-content: center;
    /* grid位置指定 */
    grid-area: 1/1/2/2;
}

/* ドラッグ可能領域 */
.axpc_window_header_dragZone {
    cursor: move;
    height: 30px;
    grid-area: 1/1/2/3;
    /* grid位置指定 */
    margin-left: -2px;
    /* safari */
    isolation: isolate;
}

/* 閉じるボタン */
.axpc_window_header_minimizeButton {
    background-color: #0000;
    border: 0;
    cursor: pointer;
    grid-area: 1/3/2/4;
    position: relative;
    border-top-right-radius: 8px;
}

.axpc_window_header_minimizeButton:hover {
    background-color: #f009;
}

.axpc_window_header_minimizeButton::before,
.axpc_window_header_minimizeButton::after {
    background-color: #ddd;
    border-radius: 15% 15% 15% 15% / 50% 50% 50% 50%;
    content: "";
    display: block;
    height: 15%;
    left: 10%;
    position: absolute;
    top: 42%;
    width: 80%;
}

.axpc_window_header_minimizeButton::before {
    transform: rotate(135deg);
}

.axpc_window_header_minimizeButton::after {
    transform: rotate(45deg);
}

/* 内容部 */
.axpc_window_content {
    background-color: rgba(0, 0, 0, 0.5);
    padding: 5px;
    border-radius: 8px;
}

/* ウィンドウ開閉制御用class */
.axpc_window_minimize,
.axpc_window_hidden {
    display: none;
}`, "",{"version":3,"sources":["webpack://./src/css/window.css"],"names":[],"mappings":"AAAA,eAAe;;AAEf;IACI,YAAY;IACZ,YAAY;IACZ,kBAAkB;IAClB,aAAa;IACb,WAAW;IACX,mCAAmC;IACnC,6BAA6B;IAC7B,YAAY;IACZ,kBAAkB;IAClB;;KAEC;IACD,YAAY;IACZ,kCAAkC;IAClC,0BAA0B;IAC1B,iBAAiB;AACrB;;AAEA,mBAAmB;AACnB;IACI,uCAAuC;AAC3C;;AAEA,UAAU;AACV;IACI,iBAAiB;IACjB,sBAAsB;IACtB,eAAe;IACf,gCAAgC;IAChC,aAAa;IACb,+DAA+D;IAC/D,sDAAsD;IACtD,mBAAmB;IACnB,oCAAoC;IACpC,UAAU;IACV,YAAY;AAChB;;AAEA,YAAY;AACZ;IACI,eAAe;IACf,YAAY;IACZ,iBAAiB;IACjB,gBAAgB;IAChB,gCAAgC;IAChC,kBAAkB;AACtB;;AAEA,gBAAgB;AAChB;IACI,oBAAoB;IACpB,mBAAmB;IACnB,YAAY;IACZ,uBAAuB;IACvB,aAAa;IACb,kBAAkB;AACtB;;AAEA,aAAa;AACb;IACI,YAAY;IACZ,YAAY;IACZ,kBAAkB;IAClB,aAAa;IACb,iBAAiB;IACjB,WAAW;IACX,kBAAkB;AACtB;;AAEA,WAAW;AACX;IACI,uBAAuB;IACvB,SAAS;IACT,eAAe;IACf,kBAAkB;IAClB,kBAAkB;IAClB,4BAA4B;AAChC;;AAEA;IACI,uBAAuB;AAC3B;;AAEA;;IAEI,sBAAsB;IACtB,gDAAgD;IAChD,WAAW;IACX,cAAc;IACd,WAAW;IACX,SAAS;IACT,kBAAkB;IAClB,QAAQ;IACR,UAAU;AACd;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,wBAAwB;AAC5B;;AAEA,QAAQ;AACR;IACI,oCAAoC;IACpC,YAAY;IACZ,kBAAkB;AACtB;;AAEA,oBAAoB;AACpB;;IAEI,aAAa;AACjB","sourcesContent":["/* ツールウィンドウ共通 */\n\n.axpc_window {\n    width: 180px;\n    height: auto;\n    position: absolute;\n    z-index: 1000;\n    color: #fff;\n    background-color: rgb(0, 0, 0, 0.3);\n    box-shadow: 4px 4px 8px #000a;\n    padding: 2px;\n    border-radius: 8px;\n    /*\n    overflow: hidden;\n    */\n    /* すりガラス効果 */\n    -webkit-backdrop-filter: blur(3px);\n    backdrop-filter: blur(3px);\n    line-height: 14px;\n}\n\n/* パレット編集時のアテンション */\n.axpc_window_attention {\n    background-color: rgb(255, 255, 0, 0.3);\n}\n\n/* ヘッダー部 */\n.axpc_window_header {\n    margin-top: -24px;\n    justify-content: right;\n    font-size: 15px;\n    /* #axp_mainのfont-size指定(必要なし) */\n    display: grid;\n    grid-template-columns: minmax(18px, 30px) minmax(0px, 1fr) 24px;\n    /* minmax(18px, 30px)→img、minmax(0px, 1fr)→文字、24px→▲ */\n    margin: -2px -2px 0;\n    /* ドラッグ範囲のクラスaxpc_windowとのズレを相殺させる */\n    padding: 0;\n    height: 30px;\n}\n\n/* ツール名 文字 */\n.axpc_window_header>div:first-of-type {\n    font-size: 13px;\n    height: 30px;\n    line-height: 30px;\n    overflow: hidden;\n    /* grid位置指定 アイコンがない場合は1/1/2/3; */\n    grid-area: 1/2/2/3;\n}\n\n/* アイコン表示 span */\n.axpc_window_header>span {\n    display: inline-flex;\n    align-items: center;\n    /* imgを中央に */\n    justify-content: center;\n    /* grid位置指定 */\n    grid-area: 1/1/2/2;\n}\n\n/* ドラッグ可能領域 */\n.axpc_window_header_dragZone {\n    cursor: move;\n    height: 30px;\n    grid-area: 1/1/2/3;\n    /* grid位置指定 */\n    margin-left: -2px;\n    /* safari */\n    isolation: isolate;\n}\n\n/* 閉じるボタン */\n.axpc_window_header_minimizeButton {\n    background-color: #0000;\n    border: 0;\n    cursor: pointer;\n    grid-area: 1/3/2/4;\n    position: relative;\n    border-top-right-radius: 8px;\n}\n\n.axpc_window_header_minimizeButton:hover {\n    background-color: #f009;\n}\n\n.axpc_window_header_minimizeButton::before,\n.axpc_window_header_minimizeButton::after {\n    background-color: #ddd;\n    border-radius: 15% 15% 15% 15% / 50% 50% 50% 50%;\n    content: \"\";\n    display: block;\n    height: 15%;\n    left: 10%;\n    position: absolute;\n    top: 42%;\n    width: 80%;\n}\n\n.axpc_window_header_minimizeButton::before {\n    transform: rotate(135deg);\n}\n\n.axpc_window_header_minimizeButton::after {\n    transform: rotate(45deg);\n}\n\n/* 内容部 */\n.axpc_window_content {\n    background-color: rgba(0, 0, 0, 0.5);\n    padding: 5px;\n    border-radius: 8px;\n}\n\n/* ウィンドウ開閉制御用class */\n.axpc_window_minimize,\n.axpc_window_hidden {\n    display: none;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/window_custom.css":
/*!*************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/window_custom.css ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* カスタムボタン */

#axp_custom {
    width: 60px;
}

/* カスタムボタン共通 */
.axpc_custom_button {
    cursor: pointer;
    width: 48px;
    height: 48px;
    margin-bottom: 4px;
    border: 2px solid #000;
    border-radius: 5px;
    background: #555;
    color: #eee;
    font-family: "Arial Black", Arial, sans-serif;
    font-size: 20px;
    text-align: center;
}

.axpc_custom_button:hover {
    border: 2px solid #bbb;
}

.axpc_custom_button:active {
    background: linear-gradient(#222, #444);
    border: 2px solid #333;
}`, "",{"version":3,"sources":["webpack://./src/css/window_custom.css"],"names":[],"mappings":"AAAA,YAAY;;AAEZ;IACI,WAAW;AACf;;AAEA,cAAc;AACd;IACI,eAAe;IACf,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,sBAAsB;IACtB,kBAAkB;IAClB,gBAAgB;IAChB,WAAW;IACX,6CAA6C;IAC7C,eAAe;IACf,kBAAkB;AACtB;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,uCAAuC;IACvC,sBAAsB;AAC1B","sourcesContent":["/* カスタムボタン */\n\n#axp_custom {\n    width: 60px;\n}\n\n/* カスタムボタン共通 */\n.axpc_custom_button {\n    cursor: pointer;\n    width: 48px;\n    height: 48px;\n    margin-bottom: 4px;\n    border: 2px solid #000;\n    border-radius: 5px;\n    background: #555;\n    color: #eee;\n    font-family: \"Arial Black\", Arial, sans-serif;\n    font-size: 20px;\n    text-align: center;\n}\n\n.axpc_custom_button:hover {\n    border: 2px solid #bbb;\n}\n\n.axpc_custom_button:active {\n    background: linear-gradient(#222, #444);\n    border: 2px solid #333;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/window_launcher.css":
/*!***************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/window_launcher.css ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#axp_launcher {
    width: auto;
}

/* ランチャーボタン外枠 */
#axp_launcher_div_buttons {
    display: flex;
}

/* 個別ボタン外枠 */
#axp_launcher_div_personalButtonsEntry {
    display: flex;
}

/* ランチャーボタン */
.axpc_launcher_personalButton,
.axpc_launcher_allButton {
    position: relative;
    cursor: pointer;
    border: 2px solid #000;
    border-radius: 5px;
    width: 40px;
    height: 40px;
    margin: 0 2px;
    background-color: #ddd;
    border: 2px solid #aaa;
    padding: 0;
}

/* ランチャーボタンのアイコン部 */
.axpc_launcher_personalButton>div,
.axpc_launcher_allButton>div {
    pointer-events: none;
    width: 28px;
    height: 28px;
    margin: auto auto;
    opacity: 1;
}

/* 個別ボタンが最小化状態 */
.axpc_launcher_personalButton.axpc_launcher_minimize {
    background-color: #888;
}

.axpc_launcher_personalButton.axpc_launcher_minimize>div {
    opacity: 0.3;
}

/* ボタンにホバーしたとき */
.axpc_launcher_personalButton:hover,
.axpc_launcher_allButton:hover {
    border: 2px solid #eee;
    background-color: #bbb;
}

/* ボタンを押したとき */
.axpc_launcher_personalButton:active,
.axpc_launcher_allButton:active {
    border: 2px solid #555;
    background-color: #555;
}

/* ボタンサイズ */
.axpc_launcher_sizeSmall {
    width: 32px;
    height: 32px;
}

.axpc_launcher_sizeBig {
    width: 48px;
    height: 48px;
}

#axp_launcher_separator {
    width: 2px;
    height: auto;
    background-color: #888;
    margin: 0 2px;
}`, "",{"version":3,"sources":["webpack://./src/css/window_launcher.css"],"names":[],"mappings":"AAAA;IACI,WAAW;AACf;;AAEA,eAAe;AACf;IACI,aAAa;AACjB;;AAEA,YAAY;AACZ;IACI,aAAa;AACjB;;AAEA,aAAa;AACb;;IAEI,kBAAkB;IAClB,eAAe;IACf,sBAAsB;IACtB,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,aAAa;IACb,sBAAsB;IACtB,sBAAsB;IACtB,UAAU;AACd;;AAEA,mBAAmB;AACnB;;IAEI,oBAAoB;IACpB,WAAW;IACX,YAAY;IACZ,iBAAiB;IACjB,UAAU;AACd;;AAEA,gBAAgB;AAChB;IACI,sBAAsB;AAC1B;;AAEA;IACI,YAAY;AAChB;;AAEA,gBAAgB;AAChB;;IAEI,sBAAsB;IACtB,sBAAsB;AAC1B;;AAEA,cAAc;AACd;;IAEI,sBAAsB;IACtB,sBAAsB;AAC1B;;AAEA,WAAW;AACX;IACI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,UAAU;IACV,YAAY;IACZ,sBAAsB;IACtB,aAAa;AACjB","sourcesContent":["#axp_launcher {\n    width: auto;\n}\n\n/* ランチャーボタン外枠 */\n#axp_launcher_div_buttons {\n    display: flex;\n}\n\n/* 個別ボタン外枠 */\n#axp_launcher_div_personalButtonsEntry {\n    display: flex;\n}\n\n/* ランチャーボタン */\n.axpc_launcher_personalButton,\n.axpc_launcher_allButton {\n    position: relative;\n    cursor: pointer;\n    border: 2px solid #000;\n    border-radius: 5px;\n    width: 40px;\n    height: 40px;\n    margin: 0 2px;\n    background-color: #ddd;\n    border: 2px solid #aaa;\n    padding: 0;\n}\n\n/* ランチャーボタンのアイコン部 */\n.axpc_launcher_personalButton>div,\n.axpc_launcher_allButton>div {\n    pointer-events: none;\n    width: 28px;\n    height: 28px;\n    margin: auto auto;\n    opacity: 1;\n}\n\n/* 個別ボタンが最小化状態 */\n.axpc_launcher_personalButton.axpc_launcher_minimize {\n    background-color: #888;\n}\n\n.axpc_launcher_personalButton.axpc_launcher_minimize>div {\n    opacity: 0.3;\n}\n\n/* ボタンにホバーしたとき */\n.axpc_launcher_personalButton:hover,\n.axpc_launcher_allButton:hover {\n    border: 2px solid #eee;\n    background-color: #bbb;\n}\n\n/* ボタンを押したとき */\n.axpc_launcher_personalButton:active,\n.axpc_launcher_allButton:active {\n    border: 2px solid #555;\n    background-color: #555;\n}\n\n/* ボタンサイズ */\n.axpc_launcher_sizeSmall {\n    width: 32px;\n    height: 32px;\n}\n\n.axpc_launcher_sizeBig {\n    width: 48px;\n    height: 48px;\n}\n\n#axp_launcher_separator {\n    width: 2px;\n    height: auto;\n    background-color: #888;\n    margin: 0 2px;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/window_layer.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/window_layer.css ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/clip.png */ "./resource/clip.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/clip_invalid.png */ "./resource/clip_invalid.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/flip_h.png */ "./resource/flip_h.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/flip_v.png */ "./resource/flip_v.png"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* レイヤー */

#axp_layer_div_button1 {
    display: flex;
}

#axp_layer_div_button2 {
    display: grid;
    grid-template-columns: 50px repeat(3, 32px);
    gap: 0 calc(20px / 3);
    margin-bottom: 8px;
}

#axp_layer_button_create {
    width: 50px;
    height: 32px;
}

#axp_layer_button_copy,
#axp_layer_button_delete,
#axp_layer_button_clear,
#axp_layer_button_integrate {
    width: 32px;
    height: 32px;
}

#axp_layer_button_clear {
    margin-left: 5px;
}

/* セレクトボックス */
#axp_layer_select_blendMode {
    width: 100%;
    height: 30px;
    border-radius: 8px;
    margin-top: 4px;
    margin-bottom: 4px;
}

/* レイヤーボックス */
#axp_layer_ul_layerBox {
    list-style: none;
    margin: 0;
    padding: 0;
    /* レイヤー数に応じて可変*/
    height: 100%;
    background: rgba(0, 0, 0, 0);
    border-radius: 0 0 5px 5px;
    position: relative;
}

#axp_layer_ul_layerBox li {
    -webkit-user-select: none;
    user-select: none;
    background: rgba(0, 0, 0, 0);
    border: 1px solid #000f;
    border-radius: 5px;
}

/* レイヤードラッグ制御 */
#axp_layer_ul_layerBox li.axpc_onGRAB {
    position: absolute;
    z-index: 1;
}

/* ドラッグ中カーソル変化 */
#axp_layer_ul_layerBox li.axpc_onGRAB * {
    cursor: grabbing;
}

#axp_layer_ul_layerBox li:not(:last-child) {
    margin-bottom: 0px;
}

/* レイヤーにポインタをあわせたとき */
#axp_layer_ul_layerBox li:hover {
    background: rgba(255, 255, 255, 0.1);
}

/* レイヤーが選択状態のとき */
#axp_layer_ul_layerBox li[data-selected="true"] {
    background: rgba(235, 154, 50);
}

/* レイヤーセル全体 */
.axpc_layer_div_cell {
    display: flex;
    /* 垂直方向：中央揃え */
    align-items: center;
    /* 水平方向：左揃え */
    justify-content: flex-start;
    height: 42px;
}

/* レイヤーセルの左側要素 */
.axpc_layer_div_cellLeftSide {
    display: flex;
}

/* 表示切り替えの目のボタン */
.axpc_layer_div_cellButtonEyeIcon {
    cursor: pointer;
    width: 21px;
    height: 42px;
    border-radius: 4px 0 0 4px;
}

.axpc_layer_div_cellButtonEye {
    border-radius: 4px 0 0 4px;
}

/* ロックと透明部分保護チェックボックスを格納する要素 */
.axpc_layer_div_cellButtonContainer {
    display: flex;
    flex-direction: column;
}

/* ロックと透明部分保護チェックボックス */
.axpc_layer_div_cellButton {
    cursor: pointer;
    width: 21px;
    height: 21px;
    border: 2px solid #333;
    border-radius: 2px;
}

/* サムネイル */
.axpc_layer_canvas_cellThumbnail {
    border: solid 1px #000;
    background: #777;
}

/* クリッピングマーク */
.axpc_layer_div_cellCliping {
    width: 0px;
    height: 100%;
}

.axpc_layer_div_cellCliping[data-mode="source-atop"] {
    width: 8px;
    height: 100%;
    background: #000;
    isolation: isolate;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
    background-position: bottom;
    background-repeat: no-repeat;
}

.axpc_layer_div_cellCliping[data-mode="invalid"] {
    width: 8px;
    height: 100%;
    background: #000;
    isolation: isolate;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});
    background-position: bottom;
    background-repeat: no-repeat;
}

/* レイヤーセルの右側要素 */
.axpc_layer_div_cellRightSide {
    display: flex;
    align-items: flex-start;
    flex-direction: column;
    justify-content: center;
    width: 82px;
    height: 100%;
    position: relative;
}

/* クリッピングマーク表示時の幅調整 */
.axpc_layer_div_cellRightSide[data-mode="source-atop"] {
    width: 74px;
}

/* カラータグ */
.axpc_layer_div_cellColorTag {
    width: 8px;
    height: 100%;
    border-radius: 0 4px 4px 0;
}

/* 状態テキスト */
.axpc_layer_span_cellStatus {
    font-size: 11px;
    color: #ddd;
}

/* レイヤー名テキスト */
.axpc_layer_span_cellName {
    -webkit-user-select: none;
    user-select: none;
    word-break: break-all;
    overflow-wrap: anywhere;
}

/* レイヤードラッグが有効な領域 */
.axpc_layer_CANDRAG {
    cursor: grab;
}

/* レイヤー名変更 */
#axp_renamelayer_div_textarea {
    margin-bottom: 8px;
    background: #555;
    border-radius: 5px;
    padding: 4px;
}

/* レイヤー名変更テキストボックス */
#axp_renamelayer_text_newLayerName {
    width: 100%;
    height: 32px;
    font-size: 16px;
    padding: 4px;
    margin-top: 4px;
    margin-bottom: 4px;
    border-radius: 4px;
}

/* レイヤー名変更決定ボタン */
#axp_renamelayer_button_confirm {
    width: 100%;
}

#axp_renamelayer_button_confirm[data-enabled="false"] {
    background: #aaa;
}

#axp_renamelayer_button_confirm:hover[data-enabled="false"] {
    border-top: 2px solid #777;
    border-left: 2px solid #777;
    border-right: 2px solid #333;
    border-bottom: 2px solid #333;
}

/* レイヤー単体反転 */
#axp_renamelayer_button_flipH {
    width: 32px;
    height: 32px;
    background: #555 center no-repeat url(${___CSS_LOADER_URL_REPLACEMENT_2___});
}

#axp_renamelayer_button_flipV {
    width: 32px;
    height: 32px;
    background: #555 center no-repeat url(${___CSS_LOADER_URL_REPLACEMENT_3___});
}

/* カラータグ用外枠 */
#axp_renamelayer_div_colorTagContainer {
    background: #333;
    display: flex;
    justify-content: space-between;
    margin-bottom: 4px;
}

/* 色リセット */
#axp_renamelayer_button_colorReset {
    width: 50%;
    height: 28px;
}

/* カラータグ用内枠 */
#axp_renamelayer_div_colorTag {
    display: flex;
    flex-wrap: wrap;
}



/* カラータグ */
.axpc_renamelayer_button_colorTag {
    cursor: pointer;
    border-radius: 5px;
    border-top: 2px solid #777;
    border-left: 2px solid #777;
    border-right: 2px solid #333;
    border-bottom: 2px solid #333;
    font-size: 13px;
    line-height: 14px;
    color: #eee;
    text-align: left;
    padding-left: 4px;
    width: 50%;
    height: 32px;

}

.axpc_renamelayer_button_colorTag:hover {
    border: 2px solid #bbb;
}

.axpc_renamelayer_button_colorTag:active {
    border: 2px solid #333;
}

/* 閉じるボタン×アイコン */
.axpc_button_closeContainer {
    display: flex;
    justify-content: space-between;
    position: relative;
}

.axpc_button_close {
    box-sizing: border-box;
    position: relative;
    width: 30px;
    height: 30px;
}

/* before,after共通 */
.axpc_button_close::before,
.axpc_button_close::after {
    content: "";
    display: block;
    width: 100%;
    height: 25%;
    position: absolute;
    background-color: white;
    left: 1%;
    top: 36%;
    border-radius: 15% 15% 15% 15% / 50% 50% 50% 50%;
}

.axpc_button_close::before {
    transform: rotate(135deg);
}

.axpc_button_close::after {
    transform: rotate(45deg);
}`, "",{"version":3,"sources":["webpack://./src/css/window_layer.css"],"names":[],"mappings":"AAAA,SAAS;;AAET;IACI,aAAa;AACjB;;AAEA;IACI,aAAa;IACb,2CAA2C;IAC3C,qBAAqB;IACrB,kBAAkB;AACtB;;AAEA;IACI,WAAW;IACX,YAAY;AAChB;;AAEA;;;;IAII,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,gBAAgB;AACpB;;AAEA,aAAa;AACb;IACI,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,eAAe;IACf,kBAAkB;AACtB;;AAEA,aAAa;AACb;IACI,gBAAgB;IAChB,SAAS;IACT,UAAU;IACV,eAAe;IACf,YAAY;IACZ,4BAA4B;IAC5B,0BAA0B;IAC1B,kBAAkB;AACtB;;AAEA;IACI,yBAAyB;IACzB,iBAAiB;IACjB,4BAA4B;IAC5B,uBAAuB;IACvB,kBAAkB;AACtB;;AAEA,eAAe;AACf;IACI,kBAAkB;IAClB,UAAU;AACd;;AAEA,gBAAgB;AAChB;IACI,gBAAgB;AACpB;;AAEA;IACI,kBAAkB;AACtB;;AAEA,qBAAqB;AACrB;IACI,oCAAoC;AACxC;;AAEA,iBAAiB;AACjB;IACI,8BAA8B;AAClC;;AAEA,aAAa;AACb;IACI,aAAa;IACb,cAAc;IACd,mBAAmB;IACnB,aAAa;IACb,2BAA2B;IAC3B,YAAY;AAChB;;AAEA,gBAAgB;AAChB;IACI,aAAa;AACjB;;AAEA,iBAAiB;AACjB;IACI,eAAe;IACf,WAAW;IACX,YAAY;IACZ,0BAA0B;AAC9B;;AAEA;IACI,0BAA0B;AAC9B;;AAEA,8BAA8B;AAC9B;IACI,aAAa;IACb,sBAAsB;AAC1B;;AAEA,uBAAuB;AACvB;IACI,eAAe;IACf,WAAW;IACX,YAAY;IACZ,sBAAsB;IACtB,kBAAkB;AACtB;;AAEA,UAAU;AACV;IACI,sBAAsB;IACtB,gBAAgB;AACpB;;AAEA,cAAc;AACd;IACI,UAAU;IACV,YAAY;AAChB;;AAEA;IACI,UAAU;IACV,YAAY;IACZ,gBAAgB;IAChB,kBAAkB;IAClB,yDAAgD;IAChD,2BAA2B;IAC3B,4BAA4B;AAChC;;AAEA;IACI,UAAU;IACV,YAAY;IACZ,gBAAgB;IAChB,kBAAkB;IAClB,yDAAwD;IACxD,2BAA2B;IAC3B,4BAA4B;AAChC;;AAEA,gBAAgB;AAChB;IACI,aAAa;IACb,uBAAuB;IACvB,sBAAsB;IACtB,uBAAuB;IACvB,WAAW;IACX,YAAY;IACZ,kBAAkB;AACtB;;AAEA,qBAAqB;AACrB;IACI,WAAW;AACf;;AAEA,UAAU;AACV;IACI,UAAU;IACV,YAAY;IACZ,0BAA0B;AAC9B;;AAEA,WAAW;AACX;IACI,eAAe;IACf,WAAW;AACf;;AAEA,cAAc;AACd;IACI,yBAAyB;IACzB,iBAAiB;IACjB,qBAAqB;IACrB,uBAAuB;AAC3B;;AAEA,mBAAmB;AACnB;IACI,YAAY;AAChB;;AAEA,YAAY;AACZ;IACI,kBAAkB;IAClB,gBAAgB;IAChB,kBAAkB;IAClB,YAAY;AAChB;;AAEA,oBAAoB;AACpB;IACI,WAAW;IACX,YAAY;IACZ,eAAe;IACf,YAAY;IACZ,eAAe;IACf,kBAAkB;IAClB,kBAAkB;AACtB;;AAEA,iBAAiB;AACjB;IACI,WAAW;AACf;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,0BAA0B;IAC1B,2BAA2B;IAC3B,4BAA4B;IAC5B,6BAA6B;AACjC;;AAEA,aAAa;AACb;IACI,WAAW;IACX,YAAY;IACZ,yEAAkE;AACtE;;AAEA;IACI,WAAW;IACX,YAAY;IACZ,yEAAkE;AACtE;;AAEA,aAAa;AACb;IACI,gBAAgB;IAChB,aAAa;IACb,8BAA8B;IAC9B,kBAAkB;AACtB;;AAEA,UAAU;AACV;IACI,UAAU;IACV,YAAY;AAChB;;AAEA,aAAa;AACb;IACI,aAAa;IACb,eAAe;AACnB;;;;AAIA,UAAU;AACV;IACI,eAAe;IACf,kBAAkB;IAClB,0BAA0B;IAC1B,2BAA2B;IAC3B,4BAA4B;IAC5B,6BAA6B;IAC7B,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,gBAAgB;IAChB,iBAAiB;IACjB,UAAU;IACV,YAAY;;AAEhB;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,sBAAsB;AAC1B;;AAEA,gBAAgB;AAChB;IACI,aAAa;IACb,8BAA8B;IAC9B,kBAAkB;AACtB;;AAEA;IACI,sBAAsB;IACtB,kBAAkB;IAClB,WAAW;IACX,YAAY;AAChB;;AAEA,mBAAmB;AACnB;;IAEI,WAAW;IACX,cAAc;IACd,WAAW;IACX,WAAW;IACX,kBAAkB;IAClB,uBAAuB;IACvB,QAAQ;IACR,QAAQ;IACR,gDAAgD;AACpD;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,wBAAwB;AAC5B","sourcesContent":["/* レイヤー */\n\n#axp_layer_div_button1 {\n    display: flex;\n}\n\n#axp_layer_div_button2 {\n    display: grid;\n    grid-template-columns: 50px repeat(3, 32px);\n    gap: 0 calc(20px / 3);\n    margin-bottom: 8px;\n}\n\n#axp_layer_button_create {\n    width: 50px;\n    height: 32px;\n}\n\n#axp_layer_button_copy,\n#axp_layer_button_delete,\n#axp_layer_button_clear,\n#axp_layer_button_integrate {\n    width: 32px;\n    height: 32px;\n}\n\n#axp_layer_button_clear {\n    margin-left: 5px;\n}\n\n/* セレクトボックス */\n#axp_layer_select_blendMode {\n    width: 100%;\n    height: 30px;\n    border-radius: 8px;\n    margin-top: 4px;\n    margin-bottom: 4px;\n}\n\n/* レイヤーボックス */\n#axp_layer_ul_layerBox {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    /* レイヤー数に応じて可変*/\n    height: 100%;\n    background: rgba(0, 0, 0, 0);\n    border-radius: 0 0 5px 5px;\n    position: relative;\n}\n\n#axp_layer_ul_layerBox li {\n    -webkit-user-select: none;\n    user-select: none;\n    background: rgba(0, 0, 0, 0);\n    border: 1px solid #000f;\n    border-radius: 5px;\n}\n\n/* レイヤードラッグ制御 */\n#axp_layer_ul_layerBox li.axpc_onGRAB {\n    position: absolute;\n    z-index: 1;\n}\n\n/* ドラッグ中カーソル変化 */\n#axp_layer_ul_layerBox li.axpc_onGRAB * {\n    cursor: grabbing;\n}\n\n#axp_layer_ul_layerBox li:not(:last-child) {\n    margin-bottom: 0px;\n}\n\n/* レイヤーにポインタをあわせたとき */\n#axp_layer_ul_layerBox li:hover {\n    background: rgba(255, 255, 255, 0.1);\n}\n\n/* レイヤーが選択状態のとき */\n#axp_layer_ul_layerBox li[data-selected=\"true\"] {\n    background: rgba(235, 154, 50);\n}\n\n/* レイヤーセル全体 */\n.axpc_layer_div_cell {\n    display: flex;\n    /* 垂直方向：中央揃え */\n    align-items: center;\n    /* 水平方向：左揃え */\n    justify-content: flex-start;\n    height: 42px;\n}\n\n/* レイヤーセルの左側要素 */\n.axpc_layer_div_cellLeftSide {\n    display: flex;\n}\n\n/* 表示切り替えの目のボタン */\n.axpc_layer_div_cellButtonEyeIcon {\n    cursor: pointer;\n    width: 21px;\n    height: 42px;\n    border-radius: 4px 0 0 4px;\n}\n\n.axpc_layer_div_cellButtonEye {\n    border-radius: 4px 0 0 4px;\n}\n\n/* ロックと透明部分保護チェックボックスを格納する要素 */\n.axpc_layer_div_cellButtonContainer {\n    display: flex;\n    flex-direction: column;\n}\n\n/* ロックと透明部分保護チェックボックス */\n.axpc_layer_div_cellButton {\n    cursor: pointer;\n    width: 21px;\n    height: 21px;\n    border: 2px solid #333;\n    border-radius: 2px;\n}\n\n/* サムネイル */\n.axpc_layer_canvas_cellThumbnail {\n    border: solid 1px #000;\n    background: #777;\n}\n\n/* クリッピングマーク */\n.axpc_layer_div_cellCliping {\n    width: 0px;\n    height: 100%;\n}\n\n.axpc_layer_div_cellCliping[data-mode=\"source-atop\"] {\n    width: 8px;\n    height: 100%;\n    background: #000;\n    isolation: isolate;\n    background-image: url('../../resource/clip.png');\n    background-position: bottom;\n    background-repeat: no-repeat;\n}\n\n.axpc_layer_div_cellCliping[data-mode=\"invalid\"] {\n    width: 8px;\n    height: 100%;\n    background: #000;\n    isolation: isolate;\n    background-image: url('../../resource/clip_invalid.png');\n    background-position: bottom;\n    background-repeat: no-repeat;\n}\n\n/* レイヤーセルの右側要素 */\n.axpc_layer_div_cellRightSide {\n    display: flex;\n    align-items: flex-start;\n    flex-direction: column;\n    justify-content: center;\n    width: 82px;\n    height: 100%;\n    position: relative;\n}\n\n/* クリッピングマーク表示時の幅調整 */\n.axpc_layer_div_cellRightSide[data-mode=\"source-atop\"] {\n    width: 74px;\n}\n\n/* カラータグ */\n.axpc_layer_div_cellColorTag {\n    width: 8px;\n    height: 100%;\n    border-radius: 0 4px 4px 0;\n}\n\n/* 状態テキスト */\n.axpc_layer_span_cellStatus {\n    font-size: 11px;\n    color: #ddd;\n}\n\n/* レイヤー名テキスト */\n.axpc_layer_span_cellName {\n    -webkit-user-select: none;\n    user-select: none;\n    word-break: break-all;\n    overflow-wrap: anywhere;\n}\n\n/* レイヤードラッグが有効な領域 */\n.axpc_layer_CANDRAG {\n    cursor: grab;\n}\n\n/* レイヤー名変更 */\n#axp_renamelayer_div_textarea {\n    margin-bottom: 8px;\n    background: #555;\n    border-radius: 5px;\n    padding: 4px;\n}\n\n/* レイヤー名変更テキストボックス */\n#axp_renamelayer_text_newLayerName {\n    width: 100%;\n    height: 32px;\n    font-size: 16px;\n    padding: 4px;\n    margin-top: 4px;\n    margin-bottom: 4px;\n    border-radius: 4px;\n}\n\n/* レイヤー名変更決定ボタン */\n#axp_renamelayer_button_confirm {\n    width: 100%;\n}\n\n#axp_renamelayer_button_confirm[data-enabled=\"false\"] {\n    background: #aaa;\n}\n\n#axp_renamelayer_button_confirm:hover[data-enabled=\"false\"] {\n    border-top: 2px solid #777;\n    border-left: 2px solid #777;\n    border-right: 2px solid #333;\n    border-bottom: 2px solid #333;\n}\n\n/* レイヤー単体反転 */\n#axp_renamelayer_button_flipH {\n    width: 32px;\n    height: 32px;\n    background: #555 center no-repeat url('../../resource/flip_h.png');\n}\n\n#axp_renamelayer_button_flipV {\n    width: 32px;\n    height: 32px;\n    background: #555 center no-repeat url('../../resource/flip_v.png');\n}\n\n/* カラータグ用外枠 */\n#axp_renamelayer_div_colorTagContainer {\n    background: #333;\n    display: flex;\n    justify-content: space-between;\n    margin-bottom: 4px;\n}\n\n/* 色リセット */\n#axp_renamelayer_button_colorReset {\n    width: 50%;\n    height: 28px;\n}\n\n/* カラータグ用内枠 */\n#axp_renamelayer_div_colorTag {\n    display: flex;\n    flex-wrap: wrap;\n}\n\n\n\n/* カラータグ */\n.axpc_renamelayer_button_colorTag {\n    cursor: pointer;\n    border-radius: 5px;\n    border-top: 2px solid #777;\n    border-left: 2px solid #777;\n    border-right: 2px solid #333;\n    border-bottom: 2px solid #333;\n    font-size: 13px;\n    line-height: 14px;\n    color: #eee;\n    text-align: left;\n    padding-left: 4px;\n    width: 50%;\n    height: 32px;\n\n}\n\n.axpc_renamelayer_button_colorTag:hover {\n    border: 2px solid #bbb;\n}\n\n.axpc_renamelayer_button_colorTag:active {\n    border: 2px solid #333;\n}\n\n/* 閉じるボタン×アイコン */\n.axpc_button_closeContainer {\n    display: flex;\n    justify-content: space-between;\n    position: relative;\n}\n\n.axpc_button_close {\n    box-sizing: border-box;\n    position: relative;\n    width: 30px;\n    height: 30px;\n}\n\n/* before,after共通 */\n.axpc_button_close::before,\n.axpc_button_close::after {\n    content: \"\";\n    display: block;\n    width: 100%;\n    height: 25%;\n    position: absolute;\n    background-color: white;\n    left: 1%;\n    top: 36%;\n    border-radius: 15% 15% 15% 15% / 50% 50% 50% 50%;\n}\n\n.axpc_button_close::before {\n    transform: rotate(135deg);\n}\n\n.axpc_button_close::after {\n    transform: rotate(45deg);\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/window_makecolor.css":
/*!****************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/window_makecolor.css ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/swap.png */ "./resource/swap.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/window_palette.png */ "./resource/window_palette.png"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* 色作成 */

/* メインカラー等領域全体 */
#axp_makecolor_div_drawColor {
    display: grid;
    align-items: start;
    /* template-columns メ1 メ2 右下カーブ1 カーブ2 色入替2 サブ サ透間隔 右枠右端 パレ間隔 パレ登録 */
    grid-template-columns: 62px 3px 5px 5px 20px 34px 3px 4px 5px 25px;
    grid-template-rows: 26px 5px 5px 29px;
}

/* L字背景枠1 */
#axp_makecolor_div_drawColor>div:first-child {
    grid-area: 2/3/4/5;
    height: 100%;
    background: radial-gradient(circle at 100% 100%, #0000 10.3px, rgb(255 255 255 / 30%) 10.3px);
}

/* L字背景枠2 */
#axp_makecolor_div_drawColor>div:nth-child(2) {
    grid-area: 1/1/5/3;
    width: 65px;
    height: 65px;
    background: rgb(255 255 255 / 30%);
    border-radius: 10px 0 10px 10px;
}

/* L字背景枠3 */
#axp_makecolor_div_drawColor>div:nth-child(3) {
    grid-area: 1/3/2/9;
    height: 100%;
    background: rgb(255 255 255 / 30%);
    border-radius: 0 10px 10px 0;
}

/* メインカラー */
#axp_makecolor_div_mainColor {
    grid-area: 1/1/5/3;
    isolation: isolate;
    width: 55px;
    height: 55px;
    margin: 5px;
    position: relative;
    --axp-mixedcolor: #000;
}

/* 混色パレット非選択時 */
#axp_makecolor_div_mainColor::before {
    content: "";
    width: 0;
    height: 0;
    position: absolute;
    background-color: transparent;
}


/* 混色パレット選択時 */
#axp_makecolor_div_mainColor[data-mixed="true"]::before {
    content: "";
    width: 51px;
    height: 51px;
    position: absolute;
    border-radius: 3px;
    -webkit-clip-path: polygon(100% 0, 0 0, 0 100%);
    clip-path: polygon(100% 0, 0 0, 0 100%);
    /* 色指定 */
    background-color: var(--axp-mixedcolor);
}

/* 混色パレット選択時三角形 */
#axp_makecolor_div_mainColor[data-mixed="true"]::after {
    content: "";
    position: absolute;
    border: 5px solid transparent;
    border-top: 6px solid #eee;
    border-bottom: 0;
    height: 0;
    left: 21px;
    top: -9px;
    width: 0;
}

/* サブカラー */
#axp_makecolor_div_subColor {
    grid-area: 3/6/5/7;
    isolation: isolate;
}

/* 透明色 */
#axp_makecolor_div_transparent {
    grid-area: 3/8/5/11;
    margin: 1px;
    isolation: isolate;
    background-size: 14px 14px;
}

/* コード入力 */
#axp_makecolor_text_colorCode {
    grid-area: 1/2/2/9;
    margin: 4px 0 0 0;
    width: 70px;
}

/* メインカラーとサブカラーを入れ替えボタン */
#axp_makecolor_button_swapColor {
    grid-area: 3/4/5/6;
    isolation: isolate;
    height: 100%;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
    background-position: 0% 50%;
    background-size: 85%;
    background-repeat: no-repeat;
    cursor: pointer;
}

/* パレット登録ボタン */
#axp_makecolor_button_addColor {
    grid-area: 1/10/2/11;
    isolation: isolate;
    height: 100%;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});
    background-position: 0% 50%;
    background-size: 85%;
    background-repeat: no-repeat;
    cursor: pointer;
}

/* RGBスライダー */
#axp_makecolor_div_RGBSlider>div {
    /*赤、緑、青　間　上下マージン*/
    margin-bottom: 2px;
}

#axp_makecolor_div_RGBSlider>div>* {
    /*赤、緑、青　縦配置*/
    vertical-align: middle;
}

#axp_makecolor_div_RGBSlider input[type="range"] {
    /*赤、緑、青　スライダー左右マージン*/
    margin-left: 5px;
    margin-right: 5px;
}

/* RGB数値入力 */
#axp_makecolor_number_red,
#axp_makecolor_number_green,
#axp_makecolor_number_blue {
    width: 40px;
    border: 0;
}

/* 混色パレット枠 */
#axp_makecolor_div_mixedPalette>div {
    display: flex;
    flex-wrap: wrap;
    align-content: flex-start;
    background-color: #333;
    margin-left: 2px;
    margin-bottom: 4px;
    gap: 1px;
    justify-content: center;
}

/* 混色パレット */
.axpc_makecolor_mixedColorRect {
    height: 20px;
    width: 30px;
    margin: 1px;
    border-radius: 3px;
    cursor: pointer;
}

/* メインカラー／透過色プレビュー選択時 */
/* 混色パレット選択時 */
#axp_makecolor_div_mainColor[data-selected="true"],
#axp_makecolor_div_subColor[data-selected="true"],
#axp_makecolor_div_transparent[data-selected="true"],
.axpc_makecolor_mixedColorRect[data-selected="true"] {
    border-width: 5px;
    border-style: double;
    border-color: #f00;
}`, "",{"version":3,"sources":["webpack://./src/css/window_makecolor.css"],"names":[],"mappings":"AAAA,QAAQ;;AAER,gBAAgB;AAChB;IACI,aAAa;IACb,kBAAkB;IAClB,mEAAmE;IACnE,kEAAkE;IAClE,qCAAqC;AACzC;;AAEA,WAAW;AACX;IACI,kBAAkB;IAClB,YAAY;IACZ,6FAA6F;AACjG;;AAEA,WAAW;AACX;IACI,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,kCAAkC;IAClC,+BAA+B;AACnC;;AAEA,WAAW;AACX;IACI,kBAAkB;IAClB,YAAY;IACZ,kCAAkC;IAClC,4BAA4B;AAChC;;AAEA,WAAW;AACX;IACI,kBAAkB;IAClB,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,WAAW;IACX,kBAAkB;IAClB,sBAAsB;AAC1B;;AAEA,eAAe;AACf;IACI,WAAW;IACX,QAAQ;IACR,SAAS;IACT,kBAAkB;IAClB,6BAA6B;AACjC;;;AAGA,cAAc;AACd;IACI,WAAW;IACX,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,kBAAkB;IAClB,+CAA+C;IAC/C,uCAAuC;IACvC,QAAQ;IACR,uCAAuC;AAC3C;;AAEA,iBAAiB;AACjB;IACI,WAAW;IACX,kBAAkB;IAClB,6BAA6B;IAC7B,0BAA0B;IAC1B,gBAAgB;IAChB,SAAS;IACT,UAAU;IACV,SAAS;IACT,QAAQ;AACZ;;AAEA,UAAU;AACV;IACI,kBAAkB;IAClB,kBAAkB;AACtB;;AAEA,QAAQ;AACR;IACI,mBAAmB;IACnB,WAAW;IACX,kBAAkB;IAClB,0BAA0B;AAC9B;;AAEA,UAAU;AACV;IACI,kBAAkB;IAClB,iBAAiB;IACjB,WAAW;AACf;;AAEA,yBAAyB;AACzB;IACI,kBAAkB;IAClB,kBAAkB;IAClB,YAAY;IACZ,yDAAgD;IAChD,2BAA2B;IAC3B,oBAAoB;IACpB,4BAA4B;IAC5B,eAAe;AACnB;;AAEA,cAAc;AACd;IACI,oBAAoB;IACpB,kBAAkB;IAClB,YAAY;IACZ,yDAA0D;IAC1D,2BAA2B;IAC3B,oBAAoB;IACpB,4BAA4B;IAC5B,eAAe;AACnB;;AAEA,aAAa;AACb;IACI,iBAAiB;IACjB,kBAAkB;AACtB;;AAEA;IACI,YAAY;IACZ,sBAAsB;AAC1B;;AAEA;IACI,oBAAoB;IACpB,gBAAgB;IAChB,iBAAiB;AACrB;;AAEA,YAAY;AACZ;;;IAGI,WAAW;IACX,SAAS;AACb;;AAEA,YAAY;AACZ;IACI,aAAa;IACb,eAAe;IACf,yBAAyB;IACzB,sBAAsB;IACtB,gBAAgB;IAChB,kBAAkB;IAClB,QAAQ;IACR,uBAAuB;AAC3B;;AAEA,WAAW;AACX;IACI,YAAY;IACZ,WAAW;IACX,WAAW;IACX,kBAAkB;IAClB,eAAe;AACnB;;AAEA,uBAAuB;AACvB,cAAc;AACd;;;;IAII,iBAAiB;IACjB,oBAAoB;IACpB,kBAAkB;AACtB","sourcesContent":["/* 色作成 */\n\n/* メインカラー等領域全体 */\n#axp_makecolor_div_drawColor {\n    display: grid;\n    align-items: start;\n    /* template-columns メ1 メ2 右下カーブ1 カーブ2 色入替2 サブ サ透間隔 右枠右端 パレ間隔 パレ登録 */\n    grid-template-columns: 62px 3px 5px 5px 20px 34px 3px 4px 5px 25px;\n    grid-template-rows: 26px 5px 5px 29px;\n}\n\n/* L字背景枠1 */\n#axp_makecolor_div_drawColor>div:first-child {\n    grid-area: 2/3/4/5;\n    height: 100%;\n    background: radial-gradient(circle at 100% 100%, #0000 10.3px, rgb(255 255 255 / 30%) 10.3px);\n}\n\n/* L字背景枠2 */\n#axp_makecolor_div_drawColor>div:nth-child(2) {\n    grid-area: 1/1/5/3;\n    width: 65px;\n    height: 65px;\n    background: rgb(255 255 255 / 30%);\n    border-radius: 10px 0 10px 10px;\n}\n\n/* L字背景枠3 */\n#axp_makecolor_div_drawColor>div:nth-child(3) {\n    grid-area: 1/3/2/9;\n    height: 100%;\n    background: rgb(255 255 255 / 30%);\n    border-radius: 0 10px 10px 0;\n}\n\n/* メインカラー */\n#axp_makecolor_div_mainColor {\n    grid-area: 1/1/5/3;\n    isolation: isolate;\n    width: 55px;\n    height: 55px;\n    margin: 5px;\n    position: relative;\n    --axp-mixedcolor: #000;\n}\n\n/* 混色パレット非選択時 */\n#axp_makecolor_div_mainColor::before {\n    content: \"\";\n    width: 0;\n    height: 0;\n    position: absolute;\n    background-color: transparent;\n}\n\n\n/* 混色パレット選択時 */\n#axp_makecolor_div_mainColor[data-mixed=\"true\"]::before {\n    content: \"\";\n    width: 51px;\n    height: 51px;\n    position: absolute;\n    border-radius: 3px;\n    -webkit-clip-path: polygon(100% 0, 0 0, 0 100%);\n    clip-path: polygon(100% 0, 0 0, 0 100%);\n    /* 色指定 */\n    background-color: var(--axp-mixedcolor);\n}\n\n/* 混色パレット選択時三角形 */\n#axp_makecolor_div_mainColor[data-mixed=\"true\"]::after {\n    content: \"\";\n    position: absolute;\n    border: 5px solid transparent;\n    border-top: 6px solid #eee;\n    border-bottom: 0;\n    height: 0;\n    left: 21px;\n    top: -9px;\n    width: 0;\n}\n\n/* サブカラー */\n#axp_makecolor_div_subColor {\n    grid-area: 3/6/5/7;\n    isolation: isolate;\n}\n\n/* 透明色 */\n#axp_makecolor_div_transparent {\n    grid-area: 3/8/5/11;\n    margin: 1px;\n    isolation: isolate;\n    background-size: 14px 14px;\n}\n\n/* コード入力 */\n#axp_makecolor_text_colorCode {\n    grid-area: 1/2/2/9;\n    margin: 4px 0 0 0;\n    width: 70px;\n}\n\n/* メインカラーとサブカラーを入れ替えボタン */\n#axp_makecolor_button_swapColor {\n    grid-area: 3/4/5/6;\n    isolation: isolate;\n    height: 100%;\n    background-image: url('../../resource/swap.png');\n    background-position: 0% 50%;\n    background-size: 85%;\n    background-repeat: no-repeat;\n    cursor: pointer;\n}\n\n/* パレット登録ボタン */\n#axp_makecolor_button_addColor {\n    grid-area: 1/10/2/11;\n    isolation: isolate;\n    height: 100%;\n    background-image: url('../../resource/window_palette.png');\n    background-position: 0% 50%;\n    background-size: 85%;\n    background-repeat: no-repeat;\n    cursor: pointer;\n}\n\n/* RGBスライダー */\n#axp_makecolor_div_RGBSlider>div {\n    /*赤、緑、青　間　上下マージン*/\n    margin-bottom: 2px;\n}\n\n#axp_makecolor_div_RGBSlider>div>* {\n    /*赤、緑、青　縦配置*/\n    vertical-align: middle;\n}\n\n#axp_makecolor_div_RGBSlider input[type=\"range\"] {\n    /*赤、緑、青　スライダー左右マージン*/\n    margin-left: 5px;\n    margin-right: 5px;\n}\n\n/* RGB数値入力 */\n#axp_makecolor_number_red,\n#axp_makecolor_number_green,\n#axp_makecolor_number_blue {\n    width: 40px;\n    border: 0;\n}\n\n/* 混色パレット枠 */\n#axp_makecolor_div_mixedPalette>div {\n    display: flex;\n    flex-wrap: wrap;\n    align-content: flex-start;\n    background-color: #333;\n    margin-left: 2px;\n    margin-bottom: 4px;\n    gap: 1px;\n    justify-content: center;\n}\n\n/* 混色パレット */\n.axpc_makecolor_mixedColorRect {\n    height: 20px;\n    width: 30px;\n    margin: 1px;\n    border-radius: 3px;\n    cursor: pointer;\n}\n\n/* メインカラー／透過色プレビュー選択時 */\n/* 混色パレット選択時 */\n#axp_makecolor_div_mainColor[data-selected=\"true\"],\n#axp_makecolor_div_subColor[data-selected=\"true\"],\n#axp_makecolor_div_transparent[data-selected=\"true\"],\n.axpc_makecolor_mixedColorRect[data-selected=\"true\"] {\n    border-width: 5px;\n    border-style: double;\n    border-color: #f00;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/window_palette.css":
/*!**************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/window_palette.css ***!
  \**************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* パレット */

#axp_palette_div_container {
    display: flex;
    flex-direction: column;
}

#axp_palette_div_buttons {
    display: flex;
    flex-wrap: wrap;
    align-content: flex-start;
    background-color: rgba(0, 0, 0, 0);
}

#axp_palette_div_paletteBox {
    display: flex;
    flex-wrap: wrap;
    align-content: flex-start;
    background-color: #333;
}

#axp_palette_button_edit,
#axp_palette_button_addColor,
#axp_palette_button_delete {
    height: 32px;
    width: 32px;
}

/* パレット専用の単体色枠 */
.axpc_palette_colorRect {
    height: 30px;
    width: 30px;
    background-color: rgba(0, 0, 0, 0);
    cursor: pointer;
    border-radius: 5px;
    margin: 1px;
    border-width: 6px;
    border-style: double;
    border-color: rgba(0, 0, 0, 0);
    /* BUGFIX:html5版のcss指定打ち消し用に必須 */
    padding: 0 0;
}

.axpc_palette_colorRect[data-selected="true"] {
    border-color: rgb(206, 206, 206);
}

.axpc_palette_colorRect.axpc_onGRAB {
    cursor: grabbing;
    position: absolute;
    z-index: 1;
}

/* 列数変更スライダー用枠 */
#axp_palette_div_column {
    position: absolute;
    z-index: 2000;
    margin-top: -70px;
    margin-left: -6px;
}`, "",{"version":3,"sources":["webpack://./src/css/window_palette.css"],"names":[],"mappings":"AAAA,SAAS;;AAET;IACI,aAAa;IACb,sBAAsB;AAC1B;;AAEA;IACI,aAAa;IACb,eAAe;IACf,yBAAyB;IACzB,kCAAkC;AACtC;;AAEA;IACI,aAAa;IACb,eAAe;IACf,yBAAyB;IACzB,sBAAsB;AAC1B;;AAEA;;;IAGI,YAAY;IACZ,WAAW;AACf;;AAEA,gBAAgB;AAChB;IACI,YAAY;IACZ,WAAW;IACX,kCAAkC;IAClC,eAAe;IACf,kBAAkB;IAClB,WAAW;IACX,iBAAiB;IACjB,oBAAoB;IACpB,8BAA8B;IAC9B,gCAAgC;IAChC,YAAY;AAChB;;AAEA;IACI,gCAAgC;AACpC;;AAEA;IACI,gBAAgB;IAChB,kBAAkB;IAClB,UAAU;AACd;;AAEA,gBAAgB;AAChB;IACI,kBAAkB;IAClB,aAAa;IACb,iBAAiB;IACjB,iBAAiB;AACrB","sourcesContent":["/* パレット */\n\n#axp_palette_div_container {\n    display: flex;\n    flex-direction: column;\n}\n\n#axp_palette_div_buttons {\n    display: flex;\n    flex-wrap: wrap;\n    align-content: flex-start;\n    background-color: rgba(0, 0, 0, 0);\n}\n\n#axp_palette_div_paletteBox {\n    display: flex;\n    flex-wrap: wrap;\n    align-content: flex-start;\n    background-color: #333;\n}\n\n#axp_palette_button_edit,\n#axp_palette_button_addColor,\n#axp_palette_button_delete {\n    height: 32px;\n    width: 32px;\n}\n\n/* パレット専用の単体色枠 */\n.axpc_palette_colorRect {\n    height: 30px;\n    width: 30px;\n    background-color: rgba(0, 0, 0, 0);\n    cursor: pointer;\n    border-radius: 5px;\n    margin: 1px;\n    border-width: 6px;\n    border-style: double;\n    border-color: rgba(0, 0, 0, 0);\n    /* BUGFIX:html5版のcss指定打ち消し用に必須 */\n    padding: 0 0;\n}\n\n.axpc_palette_colorRect[data-selected=\"true\"] {\n    border-color: rgb(206, 206, 206);\n}\n\n.axpc_palette_colorRect.axpc_onGRAB {\n    cursor: grabbing;\n    position: absolute;\n    z-index: 1;\n}\n\n/* 列数変更スライダー用枠 */\n#axp_palette_div_column {\n    position: absolute;\n    z-index: 2000;\n    margin-top: -70px;\n    margin-left: -6px;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/window_pen.css":
/*!**********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/window_pen.css ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/pen1.png */ "./resource/pen1.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/pen2.png */ "./resource/pen2.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/dot.png */ "./resource/dot.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/fude.png */ "./resource/fude.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_4___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/crayon.png */ "./resource/crayon.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_5___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/brush.png */ "./resource/brush.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_6___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/eraser.png */ "./resource/eraser.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_7___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/eraser_dot.png */ "./resource/eraser_dot.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_8___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/fill.png */ "./resource/fill.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_9___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/fillgradation.png */ "./resource/fillgradation.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_10___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/hand.png */ "./resource/hand.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_11___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/move.png */ "./resource/move.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_12___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/spuit.png */ "./resource/spuit.png"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_4___);
var ___CSS_LOADER_URL_REPLACEMENT_5___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_5___);
var ___CSS_LOADER_URL_REPLACEMENT_6___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_6___);
var ___CSS_LOADER_URL_REPLACEMENT_7___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_7___);
var ___CSS_LOADER_URL_REPLACEMENT_8___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_8___);
var ___CSS_LOADER_URL_REPLACEMENT_9___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_9___);
var ___CSS_LOADER_URL_REPLACEMENT_10___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_10___);
var ___CSS_LOADER_URL_REPLACEMENT_11___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_11___);
var ___CSS_LOADER_URL_REPLACEMENT_12___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_12___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* ペンツール */

/* ペンツール外枠 */
#axp_pen_div_content {
    display: flex;
}

/* ペンツール左側（プレビュー、スライダー）外枠 */
#axp_pen_div_leftSide {
    width: 104px;
    overflow: hidden;
}

/* ペンの名前 */
#axp_pen_span_penName {
    line-height: 1.0;
}

/* プレビュー領域 */
#axp_pen_div_preview {
    position: relative;
    width: 104px;
    height: 104px;
    background: rgba(255, 255, 255, 0.4);
    border: 2px #aaa solid;
    cursor: pointer;
    margin-top: 4px;
}

/* ペンの太さプレビュー用キャンバス */
#axp_pen_canvas_previewPenSize {
    position: absolute;
    z-index: 2;
    width: 100px;
    height: 100px;
}

/* スポイト用キャンバス */
#axp_pen_canvas_previewSpuit {
    position: absolute;
    z-index: 1;
    width: 100px;
    height: 100px;
    image-rendering: pixelated;
}

/* スポイトのRGBA表示用 */
#axp_pen_div_spuitColorRGBA {
    line-height: 1.3em;
}

/* スライダー領域 */
#axp_pen_div_slider {
    margin-top: 8px;
    display: flex;
    flex-flow: column;
}

/* セレクトボックス */
#axp_pen_div_selectbox {
    margin-top: 8px;
}

#axp_pen_select_drawMode,
#axp_pen_select_fillMode {
    width: 100px;
    height: 24px;
    border-radius: 5px;
}

/* ペンツール右側（機能ボタン）外枠 */
#axp_pen_div_rightSide {
    margin-left: 12px;
}

/* 各ボタンの枠 */
#axp_pen_div_rightSide>div {
    position: relative;
}

/* ペンツール内のアイコン（メイン＆サブ） */
#axp_pen_div_rightSide>div>button,
#axp_penmode button {
    width: 44px;
    height: 44px;
    border-radius: 5px;
    border: 3px solid #000;
    box-shadow: 0px 0px 10px #000;
    cursor: pointer;
    background-repeat: no-repeat;
    background-position: 2px 2px;
    background-color: #aaa;
}

/* ホバーしたアイコンに枠をつける */
#axp_pen_div_rightSide>div>button:hover,
#axp_penmode button:hover {
    background-color: #aaa;
    border: 3px solid #fff;
}

/* 選択しているアイコンに色をつける */
#axp_pen_div_rightSide>div>button[data-selected="true"] {
    background-color: rgb(238, 172, 96);
}

/* サブメニューがあることを示す表示効果 */
#axp_pen_div_rightSide>div:not(:last-child)>button[data-selected=true]::before {
    content: "";
    position: absolute;
    top: 6px;
    left: -9px;
    height: 16px;
    border-width: 8px 7px 8px 0;
    border-color: transparent #eeac60;
    border-style: solid;
    /*
    transition: all .5s ease-out;
    */
}

#axp_pen_div_rightSide>div:not(:last-child)>button[data-selected=true]::after {
    content: "";
    position: absolute;
    top: 18px;
    left: -8px;
    height: 0px;
    border-width: 4px 4px 4px 0;
    border-color: transparent #000;
    border-style: solid;
    /*
    transition: all .5s ease-out;
    */
}

#axp_penmode:not(.axpc_NONE)~#axp_main #axp_pen_div_rightSide>div:not(:last-child)>button[data-selected=true]::before {
    border-color: transparent #533C21;
    /*
    transition: all .5s ease-out;
    */
}

/* サブメニュー用外枠 */
#axp_penmode {
    touch-action: none;
    position: absolute;
    z-index: 2000;
    left: 0;
    top: 0;
    height: 100%;
    width: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0);
}

/* サブメニュー用内枠 */
#axp_penmode>div {
    -webkit-user-select: none;
    user-select: none;
    font-size: 15px;
    border-radius: 8px;
    color: #fff;
    background: rgba(0, 0, 0, .8);
    padding-left: 8px;
}

.axpc_penmode_round {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
}

.axpc_penmode_square {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});
}

.axpc_penmode_dot {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_2___});
}

.axpc_penmode_fude {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_3___});
}

.axpc_penmode_crayon {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_4___});
}

.axpc_penmode_brush {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_5___});
}

.axpc_penmode_eraser_round {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_6___});
}

.axpc_penmode_eraser_dot {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_7___});
}

.axpc_penmode_fill {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_8___});
}

.axpc_penmode_fillgradation {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_9___});
}

.axpc_penmode_hand {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_10___});
}

.axpc_penmode_move {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_11___});
}

.axpc_penmode_spuit {
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_12___});
}`, "",{"version":3,"sources":["webpack://./src/css/window_pen.css"],"names":[],"mappings":"AAAA,UAAU;;AAEV,YAAY;AACZ;IACI,aAAa;AACjB;;AAEA,2BAA2B;AAC3B;IACI,YAAY;IACZ,gBAAgB;AACpB;;AAEA,UAAU;AACV;IACI,gBAAgB;AACpB;;AAEA,YAAY;AACZ;IACI,kBAAkB;IAClB,YAAY;IACZ,aAAa;IACb,oCAAoC;IACpC,sBAAsB;IACtB,eAAe;IACf,eAAe;AACnB;;AAEA,qBAAqB;AACrB;IACI,kBAAkB;IAClB,UAAU;IACV,YAAY;IACZ,aAAa;AACjB;;AAEA,eAAe;AACf;IACI,kBAAkB;IAClB,UAAU;IACV,YAAY;IACZ,aAAa;IACb,0BAA0B;AAC9B;;AAEA,iBAAiB;AACjB;IACI,kBAAkB;AACtB;;AAEA,YAAY;AACZ;IACI,eAAe;IACf,aAAa;IACb,iBAAiB;AACrB;;AAEA,aAAa;AACb;IACI,eAAe;AACnB;;AAEA;;IAEI,YAAY;IACZ,YAAY;IACZ,kBAAkB;AACtB;;AAEA,qBAAqB;AACrB;IACI,iBAAiB;AACrB;;AAEA,WAAW;AACX;IACI,kBAAkB;AACtB;;AAEA,wBAAwB;AACxB;;IAEI,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,sBAAsB;IACtB,6BAA6B;IAC7B,eAAe;IACf,4BAA4B;IAC5B,4BAA4B;IAC5B,sBAAsB;AAC1B;;AAEA,oBAAoB;AACpB;;IAEI,sBAAsB;IACtB,sBAAsB;AAC1B;;AAEA,qBAAqB;AACrB;IACI,mCAAmC;AACvC;;AAEA,uBAAuB;AACvB;IACI,WAAW;IACX,kBAAkB;IAClB,QAAQ;IACR,UAAU;IACV,YAAY;IACZ,2BAA2B;IAC3B,iCAAiC;IACjC,mBAAmB;IACnB;;KAEC;AACL;;AAEA;IACI,WAAW;IACX,kBAAkB;IAClB,SAAS;IACT,UAAU;IACV,WAAW;IACX,2BAA2B;IAC3B,8BAA8B;IAC9B,mBAAmB;IACnB;;KAEC;AACL;;AAEA;IACI,iCAAiC;IACjC;;KAEC;AACL;;AAEA,cAAc;AACd;IACI,kBAAkB;IAClB,kBAAkB;IAClB,aAAa;IACb,OAAO;IACP,MAAM;IACN,YAAY;IACZ,WAAW;IACX,cAAc;IACd,kCAAkC;AACtC;;AAEA,cAAc;AACd;IACI,yBAAyB;IACzB,iBAAiB;IACjB,eAAe;IACf,kBAAkB;IAClB,WAAW;IACX,6BAA6B;IAC7B,iBAAiB;AACrB;;AAEA;IACI,yDAAgD;AACpD;;AAEA;IACI,yDAAgD;AACpD;;AAEA;IACI,yDAA+C;AACnD;;AAEA;IACI,yDAAgD;AACpD;;AAEA;IACI,yDAAkD;AACtD;;AAEA;IACI,yDAAiD;AACrD;;AAEA;IACI,yDAAkD;AACtD;;AAEA;IACI,yDAAsD;AAC1D;;AAEA;IACI,yDAAgD;AACpD;;AAEA;IACI,yDAAyD;AAC7D;;AAEA;IACI,0DAAgD;AACpD;;AAEA;IACI,0DAAgD;AACpD;;AAEA;IACI,0DAAiD;AACrD","sourcesContent":["/* ペンツール */\n\n/* ペンツール外枠 */\n#axp_pen_div_content {\n    display: flex;\n}\n\n/* ペンツール左側（プレビュー、スライダー）外枠 */\n#axp_pen_div_leftSide {\n    width: 104px;\n    overflow: hidden;\n}\n\n/* ペンの名前 */\n#axp_pen_span_penName {\n    line-height: 1.0;\n}\n\n/* プレビュー領域 */\n#axp_pen_div_preview {\n    position: relative;\n    width: 104px;\n    height: 104px;\n    background: rgba(255, 255, 255, 0.4);\n    border: 2px #aaa solid;\n    cursor: pointer;\n    margin-top: 4px;\n}\n\n/* ペンの太さプレビュー用キャンバス */\n#axp_pen_canvas_previewPenSize {\n    position: absolute;\n    z-index: 2;\n    width: 100px;\n    height: 100px;\n}\n\n/* スポイト用キャンバス */\n#axp_pen_canvas_previewSpuit {\n    position: absolute;\n    z-index: 1;\n    width: 100px;\n    height: 100px;\n    image-rendering: pixelated;\n}\n\n/* スポイトのRGBA表示用 */\n#axp_pen_div_spuitColorRGBA {\n    line-height: 1.3em;\n}\n\n/* スライダー領域 */\n#axp_pen_div_slider {\n    margin-top: 8px;\n    display: flex;\n    flex-flow: column;\n}\n\n/* セレクトボックス */\n#axp_pen_div_selectbox {\n    margin-top: 8px;\n}\n\n#axp_pen_select_drawMode,\n#axp_pen_select_fillMode {\n    width: 100px;\n    height: 24px;\n    border-radius: 5px;\n}\n\n/* ペンツール右側（機能ボタン）外枠 */\n#axp_pen_div_rightSide {\n    margin-left: 12px;\n}\n\n/* 各ボタンの枠 */\n#axp_pen_div_rightSide>div {\n    position: relative;\n}\n\n/* ペンツール内のアイコン（メイン＆サブ） */\n#axp_pen_div_rightSide>div>button,\n#axp_penmode button {\n    width: 44px;\n    height: 44px;\n    border-radius: 5px;\n    border: 3px solid #000;\n    box-shadow: 0px 0px 10px #000;\n    cursor: pointer;\n    background-repeat: no-repeat;\n    background-position: 2px 2px;\n    background-color: #aaa;\n}\n\n/* ホバーしたアイコンに枠をつける */\n#axp_pen_div_rightSide>div>button:hover,\n#axp_penmode button:hover {\n    background-color: #aaa;\n    border: 3px solid #fff;\n}\n\n/* 選択しているアイコンに色をつける */\n#axp_pen_div_rightSide>div>button[data-selected=\"true\"] {\n    background-color: rgb(238, 172, 96);\n}\n\n/* サブメニューがあることを示す表示効果 */\n#axp_pen_div_rightSide>div:not(:last-child)>button[data-selected=true]::before {\n    content: \"\";\n    position: absolute;\n    top: 6px;\n    left: -9px;\n    height: 16px;\n    border-width: 8px 7px 8px 0;\n    border-color: transparent #eeac60;\n    border-style: solid;\n    /*\n    transition: all .5s ease-out;\n    */\n}\n\n#axp_pen_div_rightSide>div:not(:last-child)>button[data-selected=true]::after {\n    content: \"\";\n    position: absolute;\n    top: 18px;\n    left: -8px;\n    height: 0px;\n    border-width: 4px 4px 4px 0;\n    border-color: transparent #000;\n    border-style: solid;\n    /*\n    transition: all .5s ease-out;\n    */\n}\n\n#axp_penmode:not(.axpc_NONE)~#axp_main #axp_pen_div_rightSide>div:not(:last-child)>button[data-selected=true]::before {\n    border-color: transparent #533C21;\n    /*\n    transition: all .5s ease-out;\n    */\n}\n\n/* サブメニュー用外枠 */\n#axp_penmode {\n    touch-action: none;\n    position: absolute;\n    z-index: 2000;\n    left: 0;\n    top: 0;\n    height: 100%;\n    width: 100%;\n    overflow: auto;\n    background-color: rgba(0, 0, 0, 0);\n}\n\n/* サブメニュー用内枠 */\n#axp_penmode>div {\n    -webkit-user-select: none;\n    user-select: none;\n    font-size: 15px;\n    border-radius: 8px;\n    color: #fff;\n    background: rgba(0, 0, 0, .8);\n    padding-left: 8px;\n}\n\n.axpc_penmode_round {\n    background-image: url('../../resource/pen1.png');\n}\n\n.axpc_penmode_square {\n    background-image: url('../../resource/pen2.png');\n}\n\n.axpc_penmode_dot {\n    background-image: url('../../resource/dot.png');\n}\n\n.axpc_penmode_fude {\n    background-image: url('../../resource/fude.png');\n}\n\n.axpc_penmode_crayon {\n    background-image: url('../../resource/crayon.png');\n}\n\n.axpc_penmode_brush {\n    background-image: url('../../resource/brush.png');\n}\n\n.axpc_penmode_eraser_round {\n    background-image: url('../../resource/eraser.png');\n}\n\n.axpc_penmode_eraser_dot {\n    background-image: url('../../resource/eraser_dot.png');\n}\n\n.axpc_penmode_fill {\n    background-image: url('../../resource/fill.png');\n}\n\n.axpc_penmode_fillgradation {\n    background-image: url('../../resource/fillgradation.png');\n}\n\n.axpc_penmode_hand {\n    background-image: url('../../resource/hand.png');\n}\n\n.axpc_penmode_move {\n    background-image: url('../../resource/move.png');\n}\n\n.axpc_penmode_spuit {\n    background-image: url('../../resource/spuit.png');\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/window_tool.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/window_tool.css ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../../resource/config.png */ "./resource/config.png"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* 補助ツール */

#axp_tool {
    width: 300px;
}

#axp_tool_div_content {
    display: flex;
}

/* 補助ツール左側 */
#axp_tool_div_leftSide {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-start;
    align-content: flex-start;
}

/* キャンバスサイズ表示ラベル */
#axp_tool_div_canvasSize {
    text-align: center;
}

/* キャンバスサイズ文字 */
#axp_tool_span_canvasSize {
    font-size: 13px;
}

/* サムネイル表示の外枠 */
#axp_tool_div_minimap_outer {
    cursor: grab;
    position: relative;
    width: 132px;
    height: 132px;
    margin-right: 4px;
    margin-top: 2px;
    margin-bottom: 4px;
    border: 6px solid #888;
}

/* サムネイル表示の内枠 */
#axp_tool_div_minimap_inner {
    width: 120px;
    height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #777;
}

/* キャンバスが画面をはみ出た時に、サムネイルに表示する赤線 */
#axp_tool_div_minimap_line {
    position: absolute;
    border: 2px #f00 solid;
}

/* 補助ツール右側 */
#axp_tool_div_rightSide {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    flex-direction: row;
    gap: 0px 6px;
    margin-top: 2px;
    margin-left: 4px;
}

/* 100% */
#axp_tool_button_loupeReset {
    width: 62px;
    margin: 0 5px 0 1px;
}

/* 拡大縮小（＋－） */
#axp_tool_button_loupeUp,
#axp_tool_button_loupeDown {
    width: 30px;
    margin-right: 4px;
}

/* アンドウ リドゥ 復元 */
#axp_tool_button_undo,
#axp_tool_button_redo,
#axp_tool_button_restore {
    width: 100%
}

/* セーブ ロード 左右反転 上下反転 背景透過 補助線の枠 */
#axp_tool_button_save,
#axp_tool_button_load,
#axp_tool_button_flipH,
#axp_tool_button_flipV,
#axp_tool_button_transparent,
#axp_tool_div_gridbutton {
    width: 70px;
}

/* 補助線ボタン枠 */
#axp_tool_div_gridbutton {
    display: flex;
}

/* 補助線 */
#axp_tool_button_grid {
    width: 50px;
}

/* 補助線設定（歯車アイコン） */
#axp_tool_button_gridConfig {
    isolation: isolate;
    height: 100%;
    width: 20px;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
    background-position: 0% 50%;
    background-repeat: no-repeat;
}

/* 補助線設定UI */
#axp_tool_div_gridConfig {
    padding: 4px 0;
}

#axp_tool_div_gridConfig>div {
    display: flex;
    column-gap: 8px;
}

/* 右側のスライダーコンテナ */
#axp_tool_div_gridConfig>div>div:nth-of-type(2) {
    display: flex;
    padding-top: 4px;
}

/* 補助線：表示ボタンなど用コンテナ */
.axpc_tool_div_gridConfigButton {
    display: flex;
    border: 2px solid #555;
    border-radius: 8px;
    column-gap: 8px;
    margin-bottom: 2px;
}

/* 主線などのラベル */
.axpc_tool_div_gridConfigButton>div:nth-of-type(1) {
    display: flex;
    align-items: center;
    justify-content: center;
    background: #666;
    width: 50px;
}

/* px指定テキストボックス */
#axp_tool_number_gridPixel1,
#axp_tool_number_gridPixel2 {
    border-radius: 5px;
    width: 60px;
    height: 32px;
    font-family: "Arial Black", Arial, sans-serif;
    padding-left: 2px;
}

/* 補助線の色変更サブメニュー */
/* 不透明度 */
#axp_gridconfig_range_gridColor {
    width: 100% !important;
}`, "",{"version":3,"sources":["webpack://./src/css/window_tool.css"],"names":[],"mappings":"AAAA,UAAU;;AAEV;IACI,YAAY;AAChB;;AAEA;IACI,aAAa;AACjB;;AAEA,YAAY;AACZ;IACI,aAAa;IACb,eAAe;IACf,uBAAuB;IACvB,uBAAuB;IACvB,yBAAyB;AAC7B;;AAEA,kBAAkB;AAClB;IACI,kBAAkB;AACtB;;AAEA,eAAe;AACf;IACI,eAAe;AACnB;;AAEA,eAAe;AACf;IACI,YAAY;IACZ,kBAAkB;IAClB,YAAY;IACZ,aAAa;IACb,iBAAiB;IACjB,eAAe;IACf,kBAAkB;IAClB,sBAAsB;AAC1B;;AAEA,eAAe;AACf;IACI,YAAY;IACZ,aAAa;IACb,aAAa;IACb,mBAAmB;IACnB,uBAAuB;IACvB,gBAAgB;AACpB;;AAEA,iCAAiC;AACjC;IACI,kBAAkB;IAClB,sBAAsB;AAC1B;;AAEA,YAAY;AACZ;IACI,aAAa;IACb,eAAe;IACf,2BAA2B;IAC3B,mBAAmB;IACnB,YAAY;IACZ,eAAe;IACf,gBAAgB;AACpB;;AAEA,SAAS;AACT;IACI,WAAW;IACX,mBAAmB;AACvB;;AAEA,aAAa;AACb;;IAEI,WAAW;IACX,iBAAiB;AACrB;;AAEA,gBAAgB;AAChB;;;IAGI;AACJ;;AAEA,iCAAiC;AACjC;;;;;;IAMI,WAAW;AACf;;AAEA,YAAY;AACZ;IACI,aAAa;AACjB;;AAEA,QAAQ;AACR;IACI,WAAW;AACf;;AAEA,kBAAkB;AAClB;IACI,kBAAkB;IAClB,YAAY;IACZ,WAAW;IACX,yDAAkD;IAClD,2BAA2B;IAC3B,4BAA4B;AAChC;;AAEA,YAAY;AACZ;IACI,cAAc;AAClB;;AAEA;IACI,aAAa;IACb,eAAe;AACnB;;AAEA,iBAAiB;AACjB;IACI,aAAa;IACb,gBAAgB;AACpB;;AAEA,qBAAqB;AACrB;IACI,aAAa;IACb,sBAAsB;IACtB,kBAAkB;IAClB,eAAe;IACf,kBAAkB;AACtB;;AAEA,aAAa;AACb;IACI,aAAa;IACb,mBAAmB;IACnB,uBAAuB;IACvB,gBAAgB;IAChB,WAAW;AACf;;AAEA,iBAAiB;AACjB;;IAEI,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,6CAA6C;IAC7C,iBAAiB;AACrB;;AAEA,kBAAkB;AAClB,SAAS;AACT;IACI,sBAAsB;AAC1B","sourcesContent":["/* 補助ツール */\n\n#axp_tool {\n    width: 300px;\n}\n\n#axp_tool_div_content {\n    display: flex;\n}\n\n/* 補助ツール左側 */\n#axp_tool_div_leftSide {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n    align-items: flex-start;\n    align-content: flex-start;\n}\n\n/* キャンバスサイズ表示ラベル */\n#axp_tool_div_canvasSize {\n    text-align: center;\n}\n\n/* キャンバスサイズ文字 */\n#axp_tool_span_canvasSize {\n    font-size: 13px;\n}\n\n/* サムネイル表示の外枠 */\n#axp_tool_div_minimap_outer {\n    cursor: grab;\n    position: relative;\n    width: 132px;\n    height: 132px;\n    margin-right: 4px;\n    margin-top: 2px;\n    margin-bottom: 4px;\n    border: 6px solid #888;\n}\n\n/* サムネイル表示の内枠 */\n#axp_tool_div_minimap_inner {\n    width: 120px;\n    height: 120px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: #777;\n}\n\n/* キャンバスが画面をはみ出た時に、サムネイルに表示する赤線 */\n#axp_tool_div_minimap_line {\n    position: absolute;\n    border: 2px #f00 solid;\n}\n\n/* 補助ツール右側 */\n#axp_tool_div_rightSide {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: flex-start;\n    flex-direction: row;\n    gap: 0px 6px;\n    margin-top: 2px;\n    margin-left: 4px;\n}\n\n/* 100% */\n#axp_tool_button_loupeReset {\n    width: 62px;\n    margin: 0 5px 0 1px;\n}\n\n/* 拡大縮小（＋－） */\n#axp_tool_button_loupeUp,\n#axp_tool_button_loupeDown {\n    width: 30px;\n    margin-right: 4px;\n}\n\n/* アンドウ リドゥ 復元 */\n#axp_tool_button_undo,\n#axp_tool_button_redo,\n#axp_tool_button_restore {\n    width: 100%\n}\n\n/* セーブ ロード 左右反転 上下反転 背景透過 補助線の枠 */\n#axp_tool_button_save,\n#axp_tool_button_load,\n#axp_tool_button_flipH,\n#axp_tool_button_flipV,\n#axp_tool_button_transparent,\n#axp_tool_div_gridbutton {\n    width: 70px;\n}\n\n/* 補助線ボタン枠 */\n#axp_tool_div_gridbutton {\n    display: flex;\n}\n\n/* 補助線 */\n#axp_tool_button_grid {\n    width: 50px;\n}\n\n/* 補助線設定（歯車アイコン） */\n#axp_tool_button_gridConfig {\n    isolation: isolate;\n    height: 100%;\n    width: 20px;\n    background-image: url('../../resource/config.png');\n    background-position: 0% 50%;\n    background-repeat: no-repeat;\n}\n\n/* 補助線設定UI */\n#axp_tool_div_gridConfig {\n    padding: 4px 0;\n}\n\n#axp_tool_div_gridConfig>div {\n    display: flex;\n    column-gap: 8px;\n}\n\n/* 右側のスライダーコンテナ */\n#axp_tool_div_gridConfig>div>div:nth-of-type(2) {\n    display: flex;\n    padding-top: 4px;\n}\n\n/* 補助線：表示ボタンなど用コンテナ */\n.axpc_tool_div_gridConfigButton {\n    display: flex;\n    border: 2px solid #555;\n    border-radius: 8px;\n    column-gap: 8px;\n    margin-bottom: 2px;\n}\n\n/* 主線などのラベル */\n.axpc_tool_div_gridConfigButton>div:nth-of-type(1) {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: #666;\n    width: 50px;\n}\n\n/* px指定テキストボックス */\n#axp_tool_number_gridPixel1,\n#axp_tool_number_gridPixel2 {\n    border-radius: 5px;\n    width: 60px;\n    height: 32px;\n    font-family: \"Arial Black\", Arial, sans-serif;\n    padding-left: 2px;\n}\n\n/* 補助線の色変更サブメニュー */\n/* 不透明度 */\n#axp_gridconfig_range_gridColor {\n    width: 100% !important;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./src/text/ja.json":
/*!**************************!*\
  !*** ./src/text/ja.json ***!
  \**************************/
/***/ ((module) => {

module.exports = {"@VERSION":"2.4.0","@LANGUAGE":"ja","@COMMON.OPACITY":"不透明度","@COMMON.RED":"赤","@COMMON.GREEN":"緑","@COMMON.BLUE":"青","@COMMON.ALPHA":"透","@COMMON.BUTTON_CLOSE":"閉じる","@COMMON.WIDTH":"横","@COMMON.HEIGHT":"縦","@COMMON.BG_WHITE":"白地","@COMMON.BG_TRANSPARENT":"透過","@COMMON.DRAW_NEW":"いちから描いた","@COMMON.DRAW_BASED":"もとの絵あるよ","@COMMON.REQUIRED":"必須","@TAB.CANVAS":"キャンバス","@TAB.SETTINGS":"設定","@TAB.POST":"投稿","@WINDOW.LAUNCHER":"表示","@WINDOW.PEN_TOOL":"ペンツール","@WINDOW.COLOR":"色作成","@WINDOW.SWATCHES":"パレット","@WINDOW.LAYER":"レイヤー","@WINDOW.MISC":"補助ツール","@WINDOW.CUSTOM_BUTTONS":"ｶｽﾀﾑ","@PEN.SIZE":"太さ","@PEN.GROW_FILL_AREA":"塗り残し補正","@PEN.ANGLE":"角度","@PEN.ROUNDNESS":"丸み","@PEN.BLUR":"ぼかし度","@PEN.TONE_DENSITY":"トーン濃度","@PEN.STABILIZER":"手ぶれ補正","@PEN.OPTION_FREE_HAND":"手描き","@PEN.OPTION_STRAIGHT":"直線","@PEN.OPTION_RECT":"長方形","@PEN.OPTION_CIRCLE":"円","@PEN.OPTION_FILL_SAMPLE_ALL":"全ﾚｲﾔｰ判定","@PEN.OPTION_FILL_SAMPLE_CURRENT":"現ﾚｲﾔｰ判定","@PEN.TYPE":"種別","@PENGROUP.PEN":"ペン","@PENGROUP.TOOL":"ツール","@PENGROUP.ERASER":"消しゴム","@PENGROUP.FILL":"バケツ","@PENGROUP.EYEDROPPER":"スポイト","@PENNAME.ROUND":"丸ペン","@PENNAME.SQUARE":"角ペン","@PENNAME.DOT":"ドットペン","@PENNAME.CALLIGRAPHY":"筆ペン","@PENNAME.CRAYON":"クレヨン","@PENNAME.AIRBRUSH":"エアブラシ","@PENNAME.ERASER":"消しゴム","@PENNAME.SQUARE_ERASER":"角消しゴム","@PENNAME.FILL":"バケツ","@PENNAME.GRADATION_FILL":"階調バケツ","@PENNAME.EYEDROPPER":"スポイト","@PENNAME.HAND":"ハンド","@PENNAME.MOVE_TOOL":"移動ツール","@SWATCHES.COLUMNS":"横幅","@SWATCHES.EDIT":"編集","@SWATCHES.SET":"登録","@SWATCHES.DEL":"削除","@LAYER.NEWLAYER_TEMPLATE":"レイヤー","@LAYER.OPTION_NORMAL":"通常","@LAYER.OPTION_CLIPING":"クリッピング","@LAYER.OPTION_MULTIPLY":"乗算","@LAYER.OPTION_SCREEN":"スクリーン","@LAYER.OPTION_OVERLAY":"オーバーレイ","@LAYER.OPTION_DARKEN":"比較（暗）","@LAYER.OPTION_LIGHTEN":"比較（明）","@LAYER.OPTION_DODGE":"覆い焼き","@LAYER.OPTION_BURN":"焼き込み","@LAYER.OPTION_HARD_LIGHT":"ハードライト","@LAYER.OPTION_SOFT_LIGHT":"ソフトライト","@LAYER.OPTION_DIFFERENCE":"差の絶対値","@LAYER.OPTION_EXCLUSION":"除外","@LAYER.BUTTON_CLEAR":"ｸﾘｱ","@LAYER.BUTTON_NEW":"新規","@LAYER.BUTTON_MERGE":"統","@LAYER.BUTTON_COPY":"複","@LAYER.BUTTON_DEL":"削","@LAYER.BUTTON_RENAME_OK":"決定","@LAYER.BUTTON_CLEAR_COLOR":"色解除","@LAYER.LAYERS_INFO":"レイヤー情報","@LAYER.PRESET_NAME":"登録名","@MISC.BUTTON_UNDO":"アンドゥ","@MISC.BUTTON_REDO":"リドゥ","@MISC.BUTTON_RESTORE_AUTOSAVE":"自動保存から復元","@MISC.BUTTON_SAVE":"セーブ","@MISC.BUTTON_LOAD":"ロード","@MISC.BUTTON_FLIP_H":"左右反転","@MISC.BUTTON_FLIP_V":"上下反転","@MISC.BUTTON_BG_ALPHA":"背景透過","@MISC.BUTTON_GRID":"補助線","@GRID.MAIN":"主線","@GRID.SUB":"副線","@GRID.DIAG":"斜め","@GRID.DIVISIONS_H":"分割数：横","@GRID.DIVISIONS_V":"分割数：縦","@GRID.CONSTRAIN":"縦横を連動","@GRID.LINE_COLOR":"補助線の色","@SETTINGS.MENU_CANVAS":"キャンバス","@SETTINGS.MENU_TOOL_WINDOWS":"ツールウィンドウ","@SETTINGS.MENU_PEN_TOOL":"ペンツール","@SETTINGS.MENU_COLOR":"色作成","@SETTINGS.MENU_SWATCHES":"パレット","@SETTINGS.MENU_LAYER":"レイヤー","@SETTINGS.MENU_MISC":"補助ツール","@SETTINGS.MENU_CUSTOM_BUTTONS":"カスタムボタン","@SETTINGS.MENU_MOUSE":"マウス","@SETTINGS.MENU_TOUCH_PANEL":"タッチパネル","@SETTINGS.MENU_KEYBOARD":"キーボード","@SETTINGS.MENU_STARTUP":"起動時","@SETTINGS.MENU_VER_INFO":"バージョン情報","@POST.POSTPICTURE":"投稿するお絵カキコ","@POST.THUMBNAIL":"サムネイル","@POST.THUMBNAIL_CLICK":"※クリックで拡大表示","@POST.INPUT":"投稿情報の入力","@POST.NAME":"投稿者名","@POST.TITLE":"タイトル","@POST.MESSAGE":"本文","@POST.WATCHLIST":"ウォッチリストに登録","@POST.STATUS.SIZE":"画像サイズ","@POST.STATUS.BG_TRANSPARENT":"背景の透過","@POST.STATUS.BASED":"もとの絵","@POST.BUTTON_SUBMIT":"お絵カキコする！","@POST.INFO_REQUIRED":"※必須項目が入力されていません。","@POST.NOTICE":"投稿前の注意事項","@POST.NOTICE1":"投稿時にすべてのレイヤーが統合されます。","@POST.NOTICE2":"","@POST.NOTICE3":"","@POST.NOTICE4":""}

/***/ }),

/***/ "./src/css/alert.css":
/*!***************************!*\
  !*** ./src/css/alert.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_alert_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./alert.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/alert.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_alert_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_alert_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_alert_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_alert_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/axnospaint.css":
/*!********************************!*\
  !*** ./src/css/axnospaint.css ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_axnospaint_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./axnospaint.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/axnospaint.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_axnospaint_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_axnospaint_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_axnospaint_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_axnospaint_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/common.css":
/*!****************************!*\
  !*** ./src/css/common.css ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_common_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./common.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/common.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_common_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_common_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_common_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_common_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/config.css":
/*!****************************!*\
  !*** ./src/css/config.css ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_config_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./config.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/config.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_config_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_config_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_config_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_config_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/icon.css":
/*!**************************!*\
  !*** ./src/css/icon.css ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_icon_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./icon.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/icon.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_icon_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_icon_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_icon_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_icon_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/input_button.css":
/*!**********************************!*\
  !*** ./src/css/input_button.css ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_input_button_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./input_button.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/input_button.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_input_button_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_input_button_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_input_button_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_input_button_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/input_checkbox.css":
/*!************************************!*\
  !*** ./src/css/input_checkbox.css ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_input_checkbox_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./input_checkbox.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/input_checkbox.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_input_checkbox_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_input_checkbox_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_input_checkbox_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_input_checkbox_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/input_number.css":
/*!**********************************!*\
  !*** ./src/css/input_number.css ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_input_number_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./input_number.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/input_number.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_input_number_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_input_number_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_input_number_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_input_number_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/input_radio.css":
/*!*********************************!*\
  !*** ./src/css/input_radio.css ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_input_radio_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./input_radio.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/input_radio.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_input_radio_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_input_radio_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_input_radio_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_input_radio_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/input_range.css":
/*!*********************************!*\
  !*** ./src/css/input_range.css ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_input_range_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./input_range.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/input_range.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_input_range_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_input_range_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_input_range_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_input_range_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/input_toggle.css":
/*!**********************************!*\
  !*** ./src/css/input_toggle.css ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_input_toggle_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./input_toggle.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/input_toggle.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_input_toggle_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_input_toggle_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_input_toggle_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_input_toggle_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/post.css":
/*!**************************!*\
  !*** ./src/css/post.css ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_post_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./post.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/post.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_post_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_post_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_post_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_post_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/reinvented-color-wheel.css":
/*!********************************************!*\
  !*** ./src/css/reinvented-color-wheel.css ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_reinvented_color_wheel_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./reinvented-color-wheel.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/reinvented-color-wheel.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_reinvented_color_wheel_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_reinvented_color_wheel_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_reinvented_color_wheel_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_reinvented_color_wheel_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/saveload.css":
/*!******************************!*\
  !*** ./src/css/saveload.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_saveload_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./saveload.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/saveload.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_saveload_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_saveload_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_saveload_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_saveload_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/window.css":
/*!****************************!*\
  !*** ./src/css/window.css ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_window_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./window.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/window.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_window_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_window_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_window_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_window_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/window_custom.css":
/*!***********************************!*\
  !*** ./src/css/window_custom.css ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_window_custom_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./window_custom.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/window_custom.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_window_custom_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_window_custom_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_window_custom_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_window_custom_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/window_launcher.css":
/*!*************************************!*\
  !*** ./src/css/window_launcher.css ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_window_launcher_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./window_launcher.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/window_launcher.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_window_launcher_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_window_launcher_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_window_launcher_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_window_launcher_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/window_layer.css":
/*!**********************************!*\
  !*** ./src/css/window_layer.css ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_window_layer_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./window_layer.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/window_layer.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_window_layer_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_window_layer_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_window_layer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_window_layer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/window_makecolor.css":
/*!**************************************!*\
  !*** ./src/css/window_makecolor.css ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_window_makecolor_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./window_makecolor.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/window_makecolor.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_window_makecolor_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_window_makecolor_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_window_makecolor_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_window_makecolor_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/window_palette.css":
/*!************************************!*\
  !*** ./src/css/window_palette.css ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_window_palette_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./window_palette.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/window_palette.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_window_palette_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_window_palette_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_window_palette_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_window_palette_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/window_pen.css":
/*!********************************!*\
  !*** ./src/css/window_pen.css ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_window_pen_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./window_pen.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/window_pen.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_window_pen_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_window_pen_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_window_pen_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_window_pen_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/window_tool.css":
/*!*********************************!*\
  !*** ./src/css/window_tool.css ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_window_tool_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./window_tool.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/window_tool.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_window_tool_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_window_tool_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_window_tool_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_window_tool_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./src/js/alert.js":
/*!*************************!*\
  !*** ./src/js/alert.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alertExPromise: () => (/* binding */ alertExPromise),
/* harmony export */   confirmExPromise: () => (/* binding */ confirmExPromise),
/* harmony export */   createCustomAlert: () => (/* binding */ createCustomAlert)
/* harmony export */ });
// @description 拡張アラート

// 拡張アラート-------------------------------------------------------------------------------------
const ALERT_TITLE = "メッセージ";
const ALERT_BUTTON_OK = "Ok";
const ALERT_BUTTON_CANCEL = "キャンセル";

// アラート用HTML生成
const createAlertHTML = (message, useCancel = false) => {
    let mObj = document.getElementsByTagName("body")[0].appendChild(document.createElement("div"));
    mObj.id = "axp_alert_div_modalContainer";

    let alertObj = mObj.appendChild(document.createElement("div"));
    alertObj.id = "axp_alert_div_alertBox";
    //※恐らくIEのための個別処理
    //if (document.all && !window.opera) alertObj.style.top = document.documentElement.scrollTop + "px";
    alertObj.style.visiblity = "visible";

    let h1 = alertObj.appendChild(document.createElement("h1"));
    h1.appendChild(document.createTextNode(ALERT_TITLE));

    let messagetext = alertObj.appendChild(document.createElement("p"));
    messagetext.innerText = message;

    let div1 = alertObj.appendChild(document.createElement("div"));
    div1.style.display = 'flex';

    // OKボタン
    let btn_ok = div1.appendChild(document.createElement("button"));
    btn_ok.id = "axp_alert_button_closeBtn";
    btn_ok.appendChild(document.createTextNode(ALERT_BUTTON_OK));
    btn_ok.focus();

    let btn_cancel;
    if (useCancel) {
        // キャンセルボタン
        btn_cancel = div1.appendChild(document.createElement("button"));
        btn_cancel.id = "axp_alert_button_cancelBtn";
        btn_cancel.appendChild(document.createTextNode(ALERT_BUTTON_CANCEL));
    } else {
        btn_cancel = null;
    }

    // 生成したHTML要素への参照を返却
    return {
        alertObj: alertObj,
        btn_ok: btn_ok,
        btn_cancel: btn_cancel
    };
};

// アラート用HTML削除
function removeCustomAlert() {
    document.getElementsByTagName("body")[0].removeChild(document.getElementById("axp_alert_div_modalContainer"));
}

// 標準アラートのオーバーライド用（通常のalert()が他の処理を阻害しない独自仕様になる）
function createCustomAlert(message) {
    if (document.getElementById("axp_alert_div_modalContainer")) return;
    const obj = createAlertHTML(message);
    obj.btn_ok.onclick = function () { removeCustomAlert(); return true; }
    obj.alertObj.style.display = "block";
}

// 確認ダイアログ（OK／キャンセル）
function confirmExPromise(message) {
    var _showConfirmDialog = function (message, okFunction, cancelFunction) {
        if (document.getElementById("axp_alert_div_modalContainer")) return;
        const obj = createAlertHTML(message, true);
        obj.btn_ok.onclick = function () { removeCustomAlert(); okFunction(); }
        obj.btn_cancel.onclick = function () { removeCustomAlert(); cancelFunction(); }
        obj.alertObj.style.display = "block";
    }
    return new Promise(function (resolve, reject) {
        _showConfirmDialog(message, resolve, reject);
    });
}

// 確認ダイアログ（OK）（Promiseで処理を待機してくれる版）
function alertExPromise(message) {
    var _showConfirmDialog = function (message, okFunction) {
        if (document.getElementById("axp_alert_div_modalContainer")) return;
        const obj = createAlertHTML(message);
        obj.btn_ok.onclick = function () { removeCustomAlert(); okFunction(); }
        obj.alertObj.style.display = "block";
    }
    return new Promise(function (resolve) {
        _showConfirmDialog(message, resolve);
    });
}

/***/ }),

/***/ "./src/js/axpobj.js":
/*!**************************!*\
  !*** ./src/js/axpobj.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AXPObj: () => (/* binding */ AXPObj)
/* harmony export */ });
/* harmony import */ var _dragwindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dragwindow.js */ "./src/js/dragwindow.js");
/* harmony import */ var _window_pen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./window_pen.js */ "./src/js/window_pen.js");
/* harmony import */ var _window_layer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./window_layer.js */ "./src/js/window_layer.js");
/* harmony import */ var _window_palette_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./window_palette.js */ "./src/js/window_palette.js");
/* harmony import */ var _window_makecolor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./window_makecolor.js */ "./src/js/window_makecolor.js");
/* harmony import */ var _window_tool_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./window_tool.js */ "./src/js/window_tool.js");
/* harmony import */ var _window_custom_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./window_custom.js */ "./src/js/window_custom.js");
/* harmony import */ var _window_launcher_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./window_launcher.js */ "./src/js/window_launcher.js");
/* harmony import */ var _undo_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./undo.js */ "./src/js/undo.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./config.js */ "./src/js/config.js");
/* harmony import */ var _post_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./post.js */ "./src/js/post.js");
/* harmony import */ var _saveload_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./saveload.js */ "./src/js/saveload.js");
/* harmony import */ var _keyboard_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./keyboard.js */ "./src/js/keyboard.js");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./etc.js */ "./src/js/etc.js");
/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./message.js */ "./src/js/message.js");
/* harmony import */ var _debuglog_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./debuglog.js */ "./src/js/debuglog.js");
/* harmony import */ var _text_ja_json__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../text/ja.json */ "./src/text/ja.json");
/* harmony import */ var _text_ja_json__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_text_ja_json__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _extensions__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @extensions */ "./extensions/prod.js");
// @description AXNOS Paint基幹

// AXPObjは、ペイントツールの機能やデータを一元管理する親オブジェクト
// ユーザーからの入力をイベントとして受け取り、対応する子システムの処理を呼び出す


















// 辞書データ（日本語のみデフォルトでバンドルする）


// 拡張機能インポート


class AXPObj {
    // AXNOS Paint全体で使用する定数。（システム単位で完全に独立している定数は、システム毎に定義する）
    CONST = {
        APP_TITLE: 'AXNOS Paint',
        MIN_SYSTEM_WIDTH: 8,
        MIN_SYSTEM_HEIGHT: 8,
        MAX_SYSTEM_WIDTH: 1000,
        MAX_SYSTEM_HEIGHT: 1000,
        CANVAS_X_MAX: 600,
        CANVAS_Y_MAX: 600,
        CANVAS_X_MIN: 8,
        CANVAS_Y_MIN: 8,
        CANVAS_X_DEFAULT: 317,
        CANVAS_Y_DEFAULT: 317,
        // 描画時のステータス
        DRAW_FREEHAND: Symbol(),
        DRAW_LINE: Symbol(),
        DRAW_RECT: Symbol(),
        DRAW_CIRCLE: Symbol(),
        // 拡大率
        SCALE_MAX: 1600,
        SCALE_MIN: 25,
        SCALE_VALUE: [25, 33, 50, 66, 100, 150, 200, 250, 300, 400, 600, 800, 1200, 1600],
        SCALE_TABLE_MAX: 50,
        MESSAGE_KEEP_TIME: 2000,
        DRAW_MULTI: 1,
    }
    // 画面表示用キャンバス（※メモリ上のみで使用するcanvasは使用する各クラスで定義）
    CANVAS = {
        // 表示用キャンバス
        main: null,
        main_ctx: null,
    };
    // DOM要素
    ELEMENT = {
        view: null,
        cursor: null,
        info: null,
        base: null,
        grid: null,
        grid_dot: null,
    };
    // 関数定義
    FUNCTION = {
        // 投稿用プログラム（ユーザー定義）
        post: null,
    };
    // タスク呼び出し（ボタンやショートカットで起動できる処理のまとまり）
    TASK = [];
    // ツールウィンドウ
    dragWindow;
    toolWindow = [];
    layerSystem;
    colorPaletteSystem;
    colorMakerSystem;
    penSystem;
    assistToolSystem;
    customButtonSystem;

    // ステータス -----------------------------------------
    isModalOpen; // モーダルウィンドウが開かれている
    isCanvasOpen; // キャンバスのタブが開かれている
    isClose;//ユーザーにより非表示状態
    isBackgroundimage; // 背景タイルプレビューが有効である
    isSPACE = false; // スペースが押されている
    isCTRL = false; // CTRLが押されている
    isSHIFT = false; // シフトキーが押されている
    isDrawing = false; // 描画中である
    isDrawn = false; // 描画処理が行われた
    isDrawCancel = false; // 描画処理がキャンセルされた
    isLine;
    isRect;
    // ----------------------------------------------------
    codeCHANGE_SIZE_KEY = null; // ショートカット「ペンの太さ調整」で押されたキー

    // 実行環境系
    ENV = {
        // ブラウザがsafari系か
        multiCanvas: false,
        // 画面幅が狭いデバイスか
        isMobileWidth: false,
        // 初回起動か
        isFirstLaunch: false,
    }

    // AXNOS Paint親要素ID
    paintBodyElement;
    // 使用ブラウザ
    browser;

    // 起動オプションで指定される変数
    checkSameBBS;
    restrictDraftCanvasResizing;
    restrictPost;
    expansionTab;
    option_height;
    option_width;

    // GETパラメーター記憶用
    oekaki_id = null; // 基にするお絵カキコの画像id
    oekaki_width;       // （起動時に指定された）キャンバスの幅
    oekaki_height;      // （起動時に指定された）キャンバスの高さ

    // お絵カキコのpng画像が存在するurl
    oekakiURL;
    oekakiTimeout;
    // 下書き機能画像ファイル名
    draftImageFile;
    // 基にしてお絵カキコ用Image
    oekaki_base;

    post_bbs_pageno;    // 投稿する掲示板のurl.pathname
    post_bbs_title;     // 投稿する掲示板のページタイトル
    // セーブデータの刻印となる情報
    oekaki_bbs_pageno = null; // 基にするお絵カキコの掲示板のページ番号（ロード制限の判定に使用）
    oekaki_bbs_title = null; // 基にするお絵カキコの掲示板のページタイトル（ロード制限時のエラーメッセージ用）

    // 許容するキャンバスサイズ
    minWidth;
    minHeight;
    maxWidth;
    maxHeight;

    // 現在のキャンバスサイズ
    x_size;
    y_size;

    // 画像の縦横サイズが異なる時のサムネイルのセンタリング用
    ctx_map_shift_x;
    ctx_map_shift_y;
    scale = 100;

    // カメラ座標（ハンドツールでキャンバスを移動させた差分）
    cameraX = 0;
    cameraY = 0;

    // 背景タイルプレビュー表示用
    url_backgroundimage;

    // キャンバス座標
    base_x;
    base_y;

    // 入力座標
    baseClientX;
    baseClientY;

    // イベント状態キャッシュ
    evCache = [];

    baseTouchX = -1;
    baseTouchY = -1;
    baseDiff = -1;
    baseScale = -1;
    baseCameraX = -1;
    baseCameraY = -1;

    longPressTimerID = null;
    touchTimerID = null;
    fingerCount = 0;

    // ホイールタイマー
    wheelTimeStamp = Date.now();

    // アンドゥ使用可能最大数
    undo_max;

    // 拡張機能
    exTool = null;

    // 拡大率テーブル
    currentScaleTable = this.CONST.SCALE_VALUE;

    // デバッグモード（デバッグ用）
    debugLog = null;

    // 使用する追加辞書
    additionalDictionaryJSON;

    // 投稿フォームカスタマイズ（デフォルト値）
    postForm = {
        // 投稿フォーム
        input: {
            isDisplay: true,
            // 投稿者名
            strName: {
                isDisplay: true,
                isInputRequired: false,
                maxLength: 32,
                placeholder: '',
            },
            // タイトル
            strTitle: {
                isDisplay: true,
                isInputRequired: false,
                maxLength: 32,
                placeholder: '',
            },
            // 本文
            strMessage: {
                isDisplay: true,
                isInputRequired: false,
                maxLength: 1024,
                placeholder: '',
            },
            // ウォッチリスト登録
            strWatchList: {
                isDisplay: true,
            },
        },
        // 注意事項
        notice: {
            isDisplay: true,
            // 文章はユーザー辞書を使用して書き換えが可能 
        },
    }

    constructor(additionalDictionaryJSON) {
        this.additionalDictionaryJSON = additionalDictionaryJSON;

        // ツールウィンドウシステム
        // 重要：ランチャーを最初に作成する必要あり
        this.toolWindow.push(this.launcher = new _window_launcher_js__WEBPACK_IMPORTED_MODULE_7__.Launcher(this));

        // 重要：生成順がランチャーのボタンの順番になる
        this.toolWindow.push(this.penSystem = new _window_pen_js__WEBPACK_IMPORTED_MODULE_1__.PenSystem(this));
        this.toolWindow.push(this.colorMakerSystem = new _window_makecolor_js__WEBPACK_IMPORTED_MODULE_4__.ColorMakerSystem(this));
        this.toolWindow.push(this.colorPaletteSystem = new _window_palette_js__WEBPACK_IMPORTED_MODULE_3__.ColorPaletteSystem(this));
        this.toolWindow.push(this.layerSystem = new _window_layer_js__WEBPACK_IMPORTED_MODULE_2__.LayerSystem(this));
        this.toolWindow.push(this.assistToolSystem = new _window_tool_js__WEBPACK_IMPORTED_MODULE_5__.AssistToolSystem(this));

        // カスタムボタンは別枠
        this.toolWindow.push(this.customButtonSystem = new _window_custom_js__WEBPACK_IMPORTED_MODULE_6__.CustomButtonSystem(this));

        // サブシステム
        this.keyboardSystem = new _keyboard_js__WEBPACK_IMPORTED_MODULE_12__.KeyboardSystem(this);
        this.undoSystem = new _undo_js__WEBPACK_IMPORTED_MODULE_8__.UndoSystem(this);
        this.configSystem = new _config_js__WEBPACK_IMPORTED_MODULE_9__.ConfigSystem(this);
        this.saveSystem = new _saveload_js__WEBPACK_IMPORTED_MODULE_11__.SaveSystem(this);
        this.postSystem = new _post_js__WEBPACK_IMPORTED_MODULE_10__.PostSystem(this);

        // デフォルト値設定
        this.minWidth = this.CONST.CANVAS_X_MIN;
        this.minHeight = this.CONST.CANVAS_Y_MIN;
        this.maxWidth = this.CONST.CANVAS_X_MAX;
        this.maxHeight = this.CONST.CANVAS_Y_MAX;

    }
    // 単語の辞書変換
    _(preTranslationText) {
        // 追加辞書が使える場合は優先して使う
        if (this.additionalDictionaryJSON) {
            if (preTranslationText in this.additionalDictionaryJSON) {
                return this.additionalDictionaryJSON[preTranslationText];
            }
        }
        // 日本語辞書
        if (preTranslationText in (_text_ja_json__WEBPACK_IMPORTED_MODULE_16___default())) {
            return (_text_ja_json__WEBPACK_IMPORTED_MODULE_16___default())[preTranslationText];
        }
        // 見つからなければ原文を返却
        return preTranslationText;
    }
    // htmlの辞書変換
    translateHTML(preTranslationHTML) {
        // ${で始まり、}で終わる文字列を検索して、置換する
        const resultHTML = preTranslationHTML.replace(/\$\{.*?\}/g, match => {
            // トークン部分だけを抜き出す
            // （例） ${_("@CANVAS")} => @CANVAS
            const token = match.slice(5, -3);
            // トークンを辞書変換
            const transWords = this._(token);
            // 変換チェック用
            // console.log(token, '=>', transWords);
            return transWords;
        });
        return resultHTML;
    }
    // 起動時に１回だけ必要な処理
    init() {
        //実際に表示されるキャンバス（ルーペによる拡大縮小が適用される）
        this.CANVAS.main = document.getElementById('axp_canvas_canvas_main');
        this.CANVAS.main_ctx = this.CANVAS.main.getContext('2d', { willReadFrequently: true });
        //this.CANVAS.main_ctx = this.CANVAS.main.getContext('2d');

        this.ELEMENT.base = document.getElementById('axp_canvas');
        this.ELEMENT.view = document.getElementById('axp_canvas_div_grayBackground');
        this.ELEMENT.cursor = document.getElementById('axp_canvas_div_penCursor');
        this.ELEMENT.info = document.getElementById('axp_footer_div_message');

        // 注意：
        // 初期化が完了していないシステムを呼び出してエラーになるのを避けるため、
        // 各init内で他システムの要素を参照する処理を行わないこと
        // ツールウィンドウシステム
        for (const item of this.toolWindow) {
            item.init();
        }

        // ツールウィンドウのドラッグ制御
        this.dragWindow = new _dragwindow_js__WEBPACK_IMPORTED_MODULE_0__.DragWindow(this);
        for (const item of this.toolWindow) {
            this.dragWindow.add(item);
        }
        // サブシステム
        this.keyboardSystem.init();
        this.undoSystem.init();
        this.configSystem.init();
        this.saveSystem.init();
        this.postSystem.init();

        this.initTask();

        // イベントリスナ設定（機能ボタン）
        const function_buttons = document.querySelectorAll('.axpc_FUNC');
        for (const item of function_buttons) {
            item.addEventListener('click', () => {
                this.TASK[item.dataset.function]();
            });
        }
    }
    // キャンバスの初期化（新規キャンバス、ロード、自動保存から復元時などに行う処理）
    resetCanvas() {
        this.CANVAS.main.style.width = this.x_size + 'px';
        this.CANVAS.main.style.height = this.y_size + 'px';
        this.CANVAS.main.width = this.x_size;
        this.CANVAS.main.height = this.y_size;

        this.updateGrid();

        // キャンバス表示位置の初期化
        this.zoomReset();
        this.refreshCanvas();

        this.layerSystem.resetCanvas();
        this.penSystem.resetCanvas();
        this.assistToolSystem.resetCanvas();
        this.undoSystem.resetCanvas();
        this.postSystem.resetCanvas();
    }
    // イベント受付開始
    startEvent() {
        // デバッグ情報
        this.debugLog = new _debuglog_js__WEBPACK_IMPORTED_MODULE_15__.DebugLog('axp_canvas_div_debugInfo', document.getElementById('axp_config_checkbox_useDebugMode').checked);

        // ツールウィンドウシステム
        for (const item of this.toolWindow) {
            item.startEvent();
        }
        // サブシステム
        this.keyboardSystem.startEvent();
        this.configSystem.startEvent();
        this.saveSystem.startEvent();
        this.postSystem.startEvent();

        // iPad safari
        // ダブルタップを抑止
        document.addEventListener('dblclick', function (e) { e.preventDefault(); }, { passive: false });
        // 長押し時のルーペ表示を抑止
        this.ELEMENT.view.addEventListener('touchstart', (e) => { e.preventDefault(); }, { passive: false });
        // ピンチインによるページ拡大抑止
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });

        // 描画領域を離れた時、ペンの太さガイドを非表示
        this.ELEMENT.base.addEventListener('pointerleave', () => { this.ELEMENT.cursor.style.visibility = 'hidden'; });

        /**
         * ポインタが押された時の処理
         */
        this.ELEMENT.base.addEventListener('pointerdown', (e) => {
            // 描画処理に受け渡すオプション情報
            const option = {};

            // モーダルウィンドウ表示中は無効
            if (this.isModalOpen) { return; }

            // キャンバス座標計算
            let pos = this.calcScaleCoordinates(e);

            // 新たなポインタダウンイベントが発生した時点で、それまでのタイマーはリセット
            if (this.longPressTimerID) {
                // タッチタイマー終了
                this.debugLog.log(`[TIMER] longPressTimerID:${this.longPressTimerID} -> CANCEL(DOWN)`);
                // 長押しキャンセル
                clearTimeout(this.longPressTimerID);
                this.longPressTimerID = null;
            }

            // タッチ処理
            if (e.pointerType === 'touch') {

                // ０→１に変化したとき、タッチタイマースタート
                if (this.evCache.length === 0) {
                    const time = Number(document.getElementById('axp_config_form_touchDurationValue').volume.value);
                    // タイマーセット
                    this.touchTimerID = setTimeout(() => {
                        this.debugLog.log(
                            `[TIMER] touchTimerID:${this.touchTimerID} -> TIMEOUT(${time}ミリ秒経過)`);
                        this.touchTimerID = null;
                    }, time)

                    this.debugLog.log(`[TIMER] touchTimerID:${this.touchTimerID} -> SET`);

                    // 初期カメラ位置記憶
                    this.baseCameraX = this.cameraX;
                    this.baseCameraY = this.cameraY;
                    // 初期入力座標
                    this.baseTouchX = e.clientX;
                    this.baseTouchY = e.clientY;
                    // 初期拡大率
                    this.baseScale = this.scale;
                }
                // タッチ情報記憶
                this.evCache.push(e);
                // 最大タッチ数更新
                if (this.fingerCount < this.evCache.length) {
                    this.fingerCount = this.evCache.length;
                };

                // ２点がタッチされている場合、ピンチジェスチャー処理
                if (this.evCache.length === 2) {
                    // 描画確定済みでなければ描画終了
                    if (!this.isDrawn) {
                        this.isDrawCancel = true;
                    }
                    // 初期距離差分
                    this.baseDiff = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.calcDistance)(this.evCache[0].clientX, this.evCache[0].clientY, this.evCache[1].clientX, this.evCache[1].clientY);
                };
            }

            let mode = this.penSystem.getPenMode();
            // プライマリーポインタ
            if (e.isPrimary) {
                // メッセージリセット
                //this.msg('');
                //右ボタンまたはホイールボタンに割り当てられた機能を実行
                if (e.buttons === 2 || e.buttons === 4) {
                    // OS本来の操作を抑止
                    e.preventDefault();
                    const task = e.buttons === 2 ? this.config('axp_config_form_mouseRightButton') : this.config('axp_config_form_mouseWheelButton');
                    switch (task) {
                        case 'undo':
                            this.TASK['func_undo']();
                            break;
                        case 'spuit':
                            this.penSystem.spuit(e);
                            this.penSystem.autoChangePen();
                            break;
                        case 'hand':
                            mode = 'axp_penmode_hand';
                            break;
                        case 'loupe':
                            this.TASK['func_loupe_reset']();
                            break;
                        case 'swapcolor':
                            this.TASK['func_swap_maincolor']();
                            break;
                        case 'swaptrans':
                            this.TASK['func_swap_transparent']();
                            break;
                        case 'transdraw':
                            option.task = 'transdraw';
                            break;
                    }
                    // ハンド以外の場合、ここで処理終了
                    if (task !== 'hand' && task !== 'transdraw') return;
                }

                // 入力座標記録
                this.baseClientX = e.clientX;
                this.baseClientY = e.clientY;

                if (this.config('axp_config_form_touchDrawType') === 'none' && e.pointerType === 'touch') {
                    // タッチ無効時は描画しない
                } else {
                    if (this.config('axp_config_form_touchDrawType') === 'hand' && e.pointerType === 'touch') {
                        mode = 'axp_penmode_hand';
                    }
                    this.base_x = pos.x;
                    this.base_y = pos.y;
                    // 機能呼び出し
                    this.penSystem.start(pos.x, pos.y, e, mode, option);
                    //console.log('描画準備:', mode);
                }

                // 長押しスポイトが有効の時、タイマーセット
                if (this.config('axp_config_form_useLongtap') === 'on') {
                    const time = Number(document.getElementById('axp_config_form_longtapDurationValue').volume.value);
                    this.longPressTimerID = setTimeout(() => {
                        // 描画中強制終了
                        this.isDrawCancel = true;
                        // [DEBUG]
                        this.debugStatus();
                        this.debugLog.log(`[TIMER] longPressTimerID:${this.longPressTimerID} -> TIMEOUT(${time}ミリ秒長押し)`);
                        this.debugLog.log(`[EXEC_] スポイト実行`);
                        this.longPressTimerID = null;
                        this.penSystem.spuit(e);
                        this.penSystem.autoChangePen();
                    }, time)
                    this.debugLog.log(`[TIMER] longPressTimerID:${this.longPressTimerID} -> SET`);
                }
            }
            // [DEBUG]
            this.debugStatus();
            const text =
                `[DOWN_] ID:${e.pointerId}(${e.pointerType}) P:${e.isPrimary ? 'O' : '-'} (${Math.trunc(e.clientX)},${Math.trunc(e.clientY)})`;
            this.debugLog.log(text);
        });

        /**
         * ポインタが移動した時の処理
         */
        this.ELEMENT.base.addEventListener('pointermove', (e) => {
            // モーダルウィンドウ表示中は無効
            if (this.isModalOpen) return;

            // プライマリーポインタ
            if (e.isPrimary) {
                // 長押し中判定
                if (this.longPressTimerID) {
                    let distance = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.calcDistance)(
                        this.baseClientX,
                        this.baseClientY,
                        e.clientX,
                        e.clientY
                    );
                    // 手ぶれの許容範囲内の場合は入力を無視する
                    if (distance < Number(document.getElementById('axp_config_form_longtapStabilizerValue').volume.value)) return;
                    this.debugLog.log(`[TIMER] longPressTimerID:${this.longPressTimerID} -> CANCEL(MOVE)`);
                    // 長押しキャンセル
                    clearTimeout(this.longPressTimerID);
                    this.longPressTimerID = null;
                }

                // キャンバス座標計算
                let pos = this.calcScaleCoordinates(e);
                const target = e.target;
                if (target === this.CANVAS.main || target === this.ELEMENT.view) {
                    // キャンバス内部

                    const name = this.layerSystem.getName();

                    // レイヤーが書き込み禁止の状態のとき、注意メッセージを表示する
                    const reasonText = this.layerSystem.getReasonTextForWriteProtection();
                    if (reasonText !== null) {
                        // 優先順位：１
                        // %1が%2のため、描画を禁止しています。
                        this.msg('@CAU0001', name, reasonText);
                    } else {
                        let isInvalid = false;
                        let isCliping = false;
                        // レイヤーの合成モードがクリッピング かつ 適切な親が存在しないとき、注意メッセージを表示する
                        if (this.layerSystem.getMode() === 'source-atop') {
                            if (this.layerSystem.getClupMode() === 'invalid') {
                                // 優先順位：２
                                // %1の下層に親レイヤーが存在しないため、クリッピングが無効になっています。
                                this.msg('@CAU0006', name);
                                isInvalid = true;
                            } else {
                                isCliping = true;
                            }
                        }
                        // 透明部分のロックのとき、情報メッセージを表示する
                        if (!isInvalid && this.layerSystem.getMasked()) {
                            // 優先順位：３
                            // %1は透明部分をロックしています。既に描画されている部分のみ上書き描画できます。
                            this.msg('@INF0001', name);
                        } else {
                            if (isCliping) {
                                // 優先順位：４
                                // %1はクリッピングです。描画内容は%2の形に切り抜かれます。
                                this.msg('@INF0008', name, this.layerSystem.getClupParentName());
                            }
                        }
                    }
                }
                // 座標表示
                // 座標の絶対値が1000以上の場合、表示形式を変える
                let textDisplayPositon;
                // 座標数値を文字列に書式変換
                const formatPositon = (num) => {
                    // -1000~1000にする
                    let num0 = Math.max(Math.min(num, 1000), -1000);
                    // 絶対値が1000ならNaN
                    let str0 = (Math.abs(num0) < 1000) ? num0.toString() : 'NaN';
                    // 桁揃え
                    let str1 = ('    ' + str0).slice(-4);
                    return str1;
                };
                // 直線または長方形描画中
                if (this.isLine || this.isRect) {
                    textDisplayPositon = `(${formatPositon(this.base_x)},${formatPositon(this.base_y)})→(${formatPositon(pos.x)},${formatPositon(pos.y)})`;
                } else {
                    textDisplayPositon = `(${formatPositon(pos.x)},${formatPositon(pos.y)})`;
                }

                // 座標表示
                document.getElementById('axp_canvas_div_pointerPosition').textContent = textDisplayPositon;
                // 機能呼び出し
                this.penSystem.move(pos.x, pos.y, e);
            }

            // タッチ処理
            if (e.pointerType === 'touch') {
                // キャッシュ内でこのイベントを見つけ、このイベントの記録を更新
                const index = this.evCache.findIndex(
                    (item) => item.pointerId === e.pointerId
                );
                if (index !== -1) {
                    this.evCache[index] = e;
                }
                // 描画が行われていた時
                if (this.touchTimerID && this.isDrawn) {
                    // タッチタイマー終了
                    this.debugLog.log(`[TIMER] touchTimerID:${this.touchTimerID} -> CANCEL(描画済み)`);
                    clearTimeout(this.touchTimerID);
                    this.touchTimerID = null;
                }

                // ２点がタッチされている場合、ピンチジェスチャー処理
                if (this.evCache.length === 2) {
                    if (this.isDrawCancel) {
                        // ２点間の距離を求める
                        const curDiff = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.calcDistance)(this.evCache[0].clientX, this.evCache[0].clientY, this.evCache[1].clientX, this.evCache[1].clientY);
                        // ２点間の距離（初期値）からの差分を求める
                        const diffDistance = Math.round(curDiff - this.baseDiff);
                        // 初期座標からの差分
                        const diffX = this.baseTouchX - this.evCache[0].clientX;
                        const diffY = this.baseTouchY - this.evCache[0].clientY;
                        // 座標の変化がある入力があったか？
                        const isMoveing = (Math.abs(diffDistance) + Math.abs(diffX) + Math.abs(diffY) >
                            Number(document.getElementById('axp_config_form_touchThresholdValue').volume.value));

                        // タイマー起動中（まだタップとスワイプが確定していない状態）
                        if (this.touchTimerID) {
                            // 座標の変化があれば、タイマーキャンセル（スワイプが確定）
                            if (isMoveing) {
                                this.debugLog.log(`[TIMER] touchTimerID:${this.touchTimerID} -> CANCEL(スワイプ開始)`);
                                clearTimeout(this.touchTimerID);
                                this.touchTimerID = null;
                            }
                        }
                        // スワイプが確定していれば、スワイプ処理を行う
                        if (this.touchTimerID === null) {
                            // ピンチによる拡大／縮小
                            if (this.config('axp_config_form_touchZoom') === 'on') {
                                // 拡大率（初期値）に差分を加算する（指定可能範囲を超える場合は補正する）
                                this.scale = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.adjustInRange)(this.baseScale + diffDistance, this.CONST.SCALE_MIN, this.CONST.SCALE_MAX);
                            };
                            // カメラ位置移動
                            if (this.config('axp_config_form_touchHand') === 'on') {

                                this.cameraX = Math.round(this.baseCameraX + (diffX * 100 / this.scale));
                                this.cameraY = Math.round(this.baseCameraY + (diffY * 100 / this.scale));
                            };
                            // キャンバス表示更新
                            this.refreshCanvas();
                        }
                    }
                }
            }
            // [DEBUG]
            this.debugStatus();
            let action = '';
            if (this.isDrawing && !this.isDrawCancel) {
                action = '[DRAW_]';
            } else {
                action = '[MOVE_]';
            }
            const text = action +
                ` ID:${e.pointerId}(${e.pointerType}) P:${e.isPrimary ? 'O' : '-'} (${Math.trunc(e.clientX)},${Math.trunc(e.clientY)})`;
            this.debugLog.log(text);
        });

        const removeEvent = (e) => {
            // 長押しキャンセル
            if (this.longPressTimerID) {
                this.debugLog.log(`[TIMER] longPressTimerID:${this.longPressTimerID} -> CANCEL(UP)`);
                clearTimeout(this.longPressTimerID);
                this.longPressTimerID = null;
            }
            // タッチ処理
            if (e.pointerType === 'touch') {
                // このイベントをターゲットのキャッシュから削除する
                const index = this.evCache.findIndex(
                    (item) => item.pointerId === e.pointerId
                );
                if (index !== -1) {
                    this.evCache.splice(index, 1);
                } else {
                    //console.log('認識されていないポインタIDを検出');
                    //this.evCache.splice(0);
                }
            }
            if (e.isPrimary) {
                // キャンバス座標計算
                let pos = this.calcScaleCoordinates(e);
                // 機能呼び出し
                this.penSystem.end(pos.x, pos.y, e);
            }
        };
        /**
        * ポインタが離された時の処理
        */
        this.ELEMENT.base.addEventListener('pointerup', (e) => {
            // タッチ処理
            if (e.pointerType === 'touch') {
                // このイベントをターゲットのキャッシュから削除する
                const index = this.evCache.findIndex(
                    (item) => item.pointerId === e.pointerId
                );
                if (index !== -1) {
                    this.evCache.splice(index, 1);
                }
                // 描画が行われていた時
                if (this.touchTimerID && this.isDrawn) {
                    // タッチタイマー終了
                    this.debugLog.log(`[TIMER] touchTimerID:${this.touchTimerID} -> CANCEL(描画済み)`);
                    clearTimeout(this.touchTimerID);
                    this.touchTimerID = null;
                }
                // すべてのタッチが離された時
                if (this.evCache.length === 0) {
                    if (this.touchTimerID) {
                        this.debugLog.log(`[TIMER] touchTimerID:${this.touchTimerID} -> CANCEL(タッチ数=0)`);
                        // タッチタイマー終了
                        clearTimeout(this.touchTimerID);
                        this.touchTimerID = null;
                        switch (this.fingerCount) {
                            case 2:
                                if (this.config('axp_config_form_touchUndo') === 'on') {
                                    this.debugLog.log(`[EXEC_] アンドゥ実行(最大タッチ数=${this.fingerCount})`);
                                    this.isDrawCancel = true;
                                    this.TASK['func_undo']();
                                }
                                break;
                            case 3:
                                if (this.config('axp_config_form_touchRedo') === 'on') {
                                    this.debugLog.log(`[EXEC_] リドゥ実行(最大タッチ数=${this.fingerCount})`);
                                    this.isDrawCancel = true;
                                    this.TASK['func_redo']();
                                }
                                break;
                        }
                    }
                    this.fingerCount = 0;
                }
            }
            removeEvent(e);
            // [DEBUG]
            this.debugStatus();
            const text =
                `[UP___] ID:${e.pointerId}(${e.pointerType}) P:${e.isPrimary ? 'O' : '-'} (${Math.trunc(e.clientX)},${Math.trunc(e.clientY)})`;
            this.debugLog.log(text);
        });
        // ポインタが無効になった時の処理
        this.ELEMENT.base.addEventListener('pointercancel', (e) => {
            //console.log('pointercancel');
            removeEvent(e);
        });
        this.ELEMENT.base.addEventListener('pointerleave', (e) => {
            //console.log('pointerleave');
            removeEvent(e);
        });

        // マウスホイール
        document.addEventListener('wheel', (e) => { this.mouseWheel(e) }, { passive: false });
        //非推奨
        //document.addEventListener('mousewheel', (e) => { this.mouseWheel(e) }, { passive: false });
        //非推奨
        //document.addEventListener('DOMMouseScroll', (e) => { this.mouseWheel(e) }, { passive: false });

        // コンテキストメニュー抑止
        document.oncontextmenu = () => {
            // キー入力可能な要素にフォーカス中の場合は有効
            if (document.activeElement.type === 'number' || document.activeElement.type === 'text' || document.activeElement.type === 'textarea') {
                return true;
            }
            // 右クリックに機能が割り当てられているなら無効
            if (this.config('axp_config_form_mouseRightButton') !== 'none') {
                return false;
            }
        };

        // ボタンにカーソルをあてたときにメッセージを表示
        const messages = document.querySelectorAll('.axpc_MSG');
        for (const item of messages) {
            // 要素に入ったとき
            item.addEventListener('pointerenter', (e) => {
                let text = e.currentTarget.dataset.msg;
                this.msg(text);
            });
        }
        // ボタンにカーソルをあてたときにメッセージを表示（ショートカット機能専用）
        const messagesFunction = document.querySelectorAll('.axpc_FUNC');
        for (const item of messagesFunction) {
            // 要素に入ったとき
            item.addEventListener('pointerenter', (e) => {
                let text = e.currentTarget.dataset.msg;
                let shortcut = '';
                if (e.currentTarget.dataset.key) {
                    // ショートカットキーが定義されている場合、表示テキストに付与する
                    shortcut = `${e.currentTarget.dataset.key}:`;
                }
                let additionalInfo = '';
                let key;
                switch (e.currentTarget.dataset.function) {
                    // ペンツールのボタン専用処理
                    case 'func_switch_pen':
                    case 'func_switch_eraser':
                    case 'func_switch_fill':
                    case 'func_switch_hand':
                        // メッセージIDの文章を取得し、先頭の%1を除外する
                        additionalInfo = _message_js__WEBPACK_IMPORTED_MODULE_14__.Message.getMessage(e.currentTarget.dataset.addmsg).slice(2);
                        this.msg(text, shortcut, additionalInfo);
                        break;
                    // 色作成のサブカラー専用処理
                    case 'func_switch_subcolor':
                        key = this.configSystem.getShortcutFunction('func_swap_maincolor');
                        if (key) {
                            additionalInfo = `${key}:メイン／サブカラー切替`;
                        }
                        this.msg(text, shortcut, additionalInfo);
                        break;
                    // 色作成の透明色専用処理
                    case 'func_switch_transparent':
                        key = this.configSystem.getShortcutFunction('func_swap_transparent');
                        if (key) {
                            additionalInfo = `${key}:メイン／透明色切替`;
                        }
                        this.msg(text, shortcut, additionalInfo);
                        break;
                    // 通常の機能ボタン
                    default:
                        this.msg(text, shortcut);
                }
            });
        }

        // メインのタブ制御
        this.selectTab('0');
        const elementsTab = document.querySelectorAll('#axp_main_div_tab_menu > div');
        elementsTab.forEach((element) => {
            element.addEventListener('click', (e) => {
                //console.log(e.currentTarget.dataset.idx);
                this.selectTab(e.currentTarget.dataset.idx);
            });
        });

        // Chromeの「メモリセーバー」によるcanvas消去の対応
        document.addEventListener('visibilitychange', () => {
            //console.log('document.visibilityState:', document.visibilityState);
            if (document.visibilityState === 'visible') {
                // タブが表示されたとき
                this.layerSystem.updateCanvas();
                this.colorMakerSystem.colorWheel.redraw();
                this.penSystem.previewPenSize();
                this.drawPostCanvas();
            }
        });
    }
    /**
     * キャンバス表示更新
     */
    refreshCanvas() {
        // 表示エリアの中央座標
        const rectView = this.ELEMENT.view.getBoundingClientRect();
        const centerX = rectView.width / 2;
        const centerY = rectView.height / 2;
        const width = Math.round(this.x_size * (this.scale / 100));
        const height = Math.round(this.y_size * (this.scale / 100));
        // キャンバスの表示座標更新
        this.CANVAS.main.style.left = Math.round(centerX - (this.x_size / 2 + this.cameraX) * this.scale / 100) + "px";
        this.CANVAS.main.style.top = Math.round(centerY - (this.y_size / 2 + this.cameraY) * this.scale / 100) + "px";
        // 拡大率に応じたキャンバズサイズ更新
        this.CANVAS.main.style.width = width + "px";
        this.CANVAS.main.style.height = height + "px";

        // 補助線表示座標更新
        const grid = document.getElementById('axp_canvas_div_grid');
        grid.style.left = this.CANVAS.main.style.left;
        grid.style.top = this.CANVAS.main.style.top;
        grid.style.width = this.CANVAS.main.style.width;
        grid.style.height = this.CANVAS.main.style.height;
        const svg = document.getElementById('axp_canvas_svg_grid');
        svg.setAttribute("viewBox", `-0.5, -0.5, ${width}, ${height}`);

        this.updateGrid();

        // 拡大率数値表示
        document.getElementById('axp_tool_button_loupeReset').textContent = `${Math.round(this.scale)}%`;

        // ペンの太さプレビュー更新
        this.penSystem.previewPenSize();
        // サムネイルのガイド線更新
        this.assistToolSystem.mapguide();
    }
    // 補助線更新
    updateGrid() {
        const gridRect = document.getElementById('axp_canvas_div_grid').getBoundingClientRect();
        const svg = document.getElementById('axp_canvas_svg_grid');

        // 作成済み補助線の消去
        const elementsRect = svg.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'rect');
        while (elementsRect.length) {
            elementsRect[0].remove();
        }

        const createRect = (id) => {
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', '100%');
            rect.setAttribute('height', '100%');
            rect.setAttribute('fill', `url(#${id})`);
            return rect;
        }

        // pattern作成（格子）
        const updatePatternVH = (element, h, v, color) => {
            const div_width = gridRect.width / h;
            const div_height = gridRect.height / v;
            element.setAttribute('viewBox', `0 0 ${div_width} ${div_height}`);
            element.setAttribute('width', `${div_width}`);
            element.setAttribute('height', `${div_height}`);
            const path = element.querySelector('path');
            path.setAttribute('d', `M ${div_width} 0 L ${div_width} ${div_height} L 0 ${div_height}`);
            path.setAttribute('stroke', color);
        }
        // 主線
        if (document.getElementById('axp_tool_checkbox_gridVH').dataset.checked === 'true') {
            updatePatternVH(
                document.getElementById('axp_canvas_pattern_gridVH'),
                parseInt(document.getElementById('axp_tool_range_gridH').value),
                parseInt(document.getElementById('axp_tool_range_gridV').value),
                document.getElementById('axp_tool_color_gridVH').dataset.colorcode
            );
            svg.appendChild(
                createRect('axp_canvas_pattern_gridVH')
            );
        }
        // 副線
        if (document.getElementById('axp_tool_checkbox_gridSubDivision').dataset.checked === 'true') {
            updatePatternVH(
                document.getElementById('axp_canvas_pattern_gridSubDivision'),
                parseInt(document.getElementById('axp_tool_range_gridH').value) * 2,
                parseInt(document.getElementById('axp_tool_range_gridV').value) * 2,
                document.getElementById('axp_tool_color_gridSubDivision').dataset.colorcode
            );
            svg.appendChild(
                createRect('axp_canvas_pattern_gridSubDivision')
            );
        }

        // pattern作成（斜め）
        const updatePatternDiagonal = (element, h, v, color) => {
            const div_width = gridRect.width / h;
            const div_height = gridRect.height / v;
            element.setAttribute('viewBox', `0 0 ${div_width} ${div_height}`);
            element.setAttribute('width', `${div_width}`);
            element.setAttribute('height', `${div_height}`);
            const path = element.querySelector('path');
            path.setAttribute('d', `M 0 0 L ${div_width} ${div_height} M ${div_width} 0 L 0 ${div_height}`);
            path.setAttribute('stroke', color);
        }
        // 斜線
        if (document.getElementById('axp_tool_checkbox_gridDiagonal').dataset.checked === 'true') {
            updatePatternDiagonal(
                document.getElementById('axp_canvas_pattern_gridDiagonal'),
                parseInt(document.getElementById('axp_tool_range_gridH').value),
                parseInt(document.getElementById('axp_tool_range_gridV').value),
                document.getElementById('axp_tool_color_gridDiagonal').dataset.colorcode
            );
            svg.appendChild(
                createRect('axp_canvas_pattern_gridDiagonal')
            );
        }

        // pattern作成（格子）
        const updatePatternPX = (element, scalePx, color) => {
            element.setAttribute('viewBox', `0 0 ${scalePx} ${scalePx}`);
            element.setAttribute('width', `${scalePx}`);
            element.setAttribute('height', `${scalePx}`);
            const path = element.querySelector('path');
            path.setAttribute('d', `M ${scalePx} 0 L ${scalePx} ${scalePx} L 0 ${scalePx}`);
            path.setAttribute('stroke', color);
        }
        // ピクセル指定１
        if (document.getElementById('axp_tool_checkbox_gridPixel1').dataset.checked === 'true') {
            // 補助線の細かさに対して、表示に十分な拡大率である場合表示する
            if (this.scale / 800 * document.getElementById('axp_tool_number_gridPixel1').value >= 1) {
                updatePatternPX(
                    document.getElementById('axp_canvas_pattern_gridPixel1'),
                    parseInt(document.getElementById('axp_tool_number_gridPixel1').value) * this.scale / 100,
                    document.getElementById('axp_tool_color_gridPixel1').dataset.colorcode
                );
                svg.appendChild(
                    createRect('axp_canvas_pattern_gridPixel1')
                );
            }
        }
        // ピクセル指定２
        if (document.getElementById('axp_tool_checkbox_gridPixel2').dataset.checked === 'true') {
            // 補助線の細かさに対して、表示に十分な拡大率である場合表示する
            if (this.scale / 800 * document.getElementById('axp_tool_number_gridPixel2').value >= 1) {
                updatePatternPX(
                    document.getElementById('axp_canvas_pattern_gridPixel2'),
                    parseInt(document.getElementById('axp_tool_number_gridPixel2').value) * this.scale / 100,
                    document.getElementById('axp_tool_color_gridPixel2').dataset.colorcode
                );
                svg.appendChild(
                    createRect('axp_canvas_pattern_gridPixel2')
                );
            }
        }

    }
    // 拡大率変更
    setScale(value) {
        this.scale = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.adjustInRange)(value, this.CONST.SCALE_MIN, this.CONST.SCALE_MAX);
        this.refreshCanvas();
        // 拡大率：%1
        this.msg('@AXP0001', this.scale);
    }
    /**
     * キャンバスの縮小
     */
    zoomOutCanvas() {
        if (this.scale <= this.CONST.SCALE_MIN) return;
        // 現在の拡大率より一つ下のvalueのindexをサーチ
        let index = 0;
        for (let idx = 1; idx < this.currentScaleTable.length; idx++) {
            if (this.scale <= this.currentScaleTable[idx]) {
                index = idx - 1;
                break;
            }
        }
        this.scale = this.currentScaleTable[index];
    }
    /**
    * キャンバスの拡大
    */
    zoomInCanvas() {
        if (this.scale >= this.CONST.SCALE_MAX) return;
        // 現在の拡大率より一つ上のvalueのindexをサーチ
        let index = 0;
        for (let idx = this.currentScaleTable.length - 2; idx >= 0; idx--) {
            if (this.scale >= this.currentScaleTable[idx]) {
                index = idx + 1;
                break;
            }
        }
        this.scale = this.currentScaleTable[index];
    }
    /**
    * キャンバスの拡大率リセット
    */
    zoomReset() {
        // 拡大率100%
        this.scale = 100;
        // カメラ座標（キャンバス表示位置）を中央にリセット
        this.cameraX = 0;
        this.cameraY = 0;
    }
    /**
     * ポインタイベントを受け取り、入力の実座標からscale(尺度)を適用したキャンバス上のx,y座標を計算し、返却する
     * @param {Event} e イベント
     * @returns {{x:Number,y:Number}} 座標(x,y)
     */
    calcScaleCoordinates(e) {
        let clientRect_draw = this.CANVAS.main.getBoundingClientRect();
        let calcX = Math.floor((e.clientX - clientRect_draw.left) * 100 / this.scale);
        let calcY = Math.floor((e.clientY - clientRect_draw.top) * 100 / this.scale);
        return {
            x: calcX,
            y: calcY,
        };
    }
    /**
     * マウスホイールイベントを受け取り、設定で割り当てられた機能を呼び出す
     * @param {Event} e イベント
     */
    mouseWheel(e) {
        // 非表示時は無効
        if (this.isClose) { return };
        // キャンバスタブ以外は無効
        if (!this.isCanvasOpen) { return; }

        // モーダルウィンドウ表示中は無効
        if (this.isModalOpen) { return; }

        // 標準の動作（スクロールなど）は無効にする
        // ※判定順序注意：設定、投稿タブでは、上記ifにてこのコードに到達しないため、スクロールが有効になる）
        e.preventDefault();

        // ホイールをサポートしていない環境は無効
        if (e.type !== "wheel") { return; }

        // 回転の向き (< 0 → up, > 0 → down)
        let deltaX = e.deltaX;
        let deltaY = e.deltaY;
        // 回転方向反転反転が設定されている場合
        if (document.getElementById('axp_config_checkbox_mouseWheelDirection').checked) {
            deltaX = -deltaX;
            deltaY = -deltaY;
        }
        const isPinch = !!(e.deltaY % 1);
        //console.log(isPinch ? 'pinch' : 'wheel', deltaX, deltaY, e.deltaX, e.deltaY);
        if (isPinch) {
            if (this.config('axp_config_form_mouseWheelZoom') === 'on') {
                // 拡大率（初期値）に差分を加算する（指定可能範囲を超える場合は補正する）
                this.scale = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.adjustInRange)(this.scale - e.deltaY * 10, this.CONST.SCALE_MIN, this.CONST.SCALE_MAX);
                // キャンバス表示更新
                this.refreshCanvas();
                return;
            }
        }

        const sleepTime = Number(document.getElementById('axp_config_number_mouseWheelSleepTime').value);
        // トラックパッド用の感度補正（一定時間内の連続入力を無視する）
        if (sleepTime) {
            const nowTimeStamp = Date.now();
            if (!e.wheelDelta) {
                this.wheelTimeStamp = nowTimeStamp;
                return;
            }

            const deltaTimeStamp = nowTimeStamp - this.wheelTimeStamp;
            if (deltaTimeStamp < sleepTime) {
                return;
            }
            this.wheelTimeStamp = nowTimeStamp;
        }

        // キャンバス座標計算
        let pos = this.calcScaleCoordinates(e);
        let currentScale = this.scale;

        // ポインタ位置を拡大（カメラ位置調整）
        const adjustCamera = () => {
            if (this.scale !== currentScale) {
                // 表示エリアの中央座標
                const rectView = this.ELEMENT.view.getBoundingClientRect();
                const centerX = rectView.width / 2;
                const centerY = rectView.height / 2;

                // ポインタ座標が原点からどれだけ離れているか
                let pointerDX = e.clientX - centerX;
                let pointerDY = e.clientY - centerY - rectView.top;

                // キャンバス座標が原点からどれだけ離れているか（ポインタがキャンバス外の場合はキャンバス内に補正）
                let canvasX = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.adjustInRange)(pos.x, 0, this.x_size - 1);
                let canvasDX = (canvasX - this.x_size / 2) * this.scale / 100;
                let canvasY = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.adjustInRange)(pos.y, 0, this.y_size - 1);
                let canvasDY = (canvasY - this.y_size / 2) * this.scale / 100;

                // 新しいカメラ位置
                let cameraX = (canvasDX - pointerDX) * 100 / this.scale;
                let cameraY = (canvasDY - pointerDY) * 100 / this.scale;
                this.cameraX = cameraX;
                this.cameraY = cameraY;
                //console.log('cameraX:', pointerDX, canvasDX, cameraX);
                //console.log('cameraY:', pointerDY, canvasDY, cameraY);
            }
        };
        switch (this.config('axp_config_form_mouseWheelRotate')) {
            case 'none':
                break;
            case 'loupe':
                // 拡大／縮小
                if (deltaY < 0) { //奥回転
                    this.zoomOutCanvas();
                }
                if (deltaY > 0) { //手前回転
                    this.zoomInCanvas();
                }
                // ポインタ位置を拡大
                if (document.getElementById('axp_config_checkbox_mouseWheelPointerTracking').checked) {
                    adjustCamera();
                }
                // 拡大率：%1
                this.msg('@AXP0001', this.scale);
                this.refreshCanvas();
                // ペンカーソル表示
                if (e.target.id === this.CANVAS.main.id || e.target.id === this.ELEMENT.view.id) {
                    this.penSystem.penObj[this.penSystem.pen_mode].drawCursor(e);
                }
                break;
            case 'scroll': {
                // スクロール（スクロール移動量に設定されている値を加減算）
                const move_size = Number(document.getElementById('axp_config_number_mouseWheelMoveSize').value);
                if (deltaY < 0) { //奥回転
                    this.moveCanvas(0, move_size);
                }
                if (deltaY > 0) { //手前回転
                    this.moveCanvas(0, -move_size);
                }
                if (deltaX < 0) {
                    this.moveCanvas(move_size, 0);
                }
                if (deltaX > 0) {
                    this.moveCanvas(-move_size, 0);
                }
                break;
            }
        }
    }
    setCanvasSize(x_size, y_size) {
        let x = Number(x_size);
        let y = Number(y_size);
        if (isNaN(x)) {
            x = this.CONST.CANVAS_X_DEFAULT;
        }
        x = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.adjustInRange)(x, this.minWidth, this.maxWidth);
        if (isNaN(y)) {
            y = this.CONST.CANVAS_Y_DEFAULT;
        }
        y = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.adjustInRange)(y, this.minHeight, this.maxHeight);
        this.x_size = x;
        this.y_size = y;
        console.log(`キャンバスサイズ更新:${x} x ${y}`);
    }
    checkCanvasSize_x(x_size) {
        let x = Number(x_size);
        x = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.adjustInRange)(x, this.minWidth, this.maxWidth);
        return x;
    }
    checkCanvasSize_y(y_size) {
        let y = Number(y_size);
        y = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.adjustInRange)(y, this.minHeight, this.maxHeight);
        return y;
    }
    getCanvasSize_X() {
        return this.x_size;
    }
    getCanvasSize_Y() {
        return this.y_size;
    }
    // 投稿タブのキャンバスの描画（ブラウザタブ切り替え時の再描画にも使用する）
    drawPostCanvas() {
        let isTrans = this.assistToolSystem.getIsTransparent();
        if (isTrans) {
            // 画像
            this.postSystem.CANVAS.post_ctx.clearRect(0, 0, this.x_size, this.y_size);
            this.postSystem.CANVAS.post_ctx.drawImage(this.layerSystem.CANVAS.backscreen_trans, 0, 0);
            // サムネ
            this.postSystem.CANVAS.thumbnail_ctx.clearRect(0, 0, this.postSystem.CANVAS.thumbnail.width, this.postSystem.CANVAS.thumbnail.height);
            this.postSystem.CANVAS.thumbnail_ctx.drawImage(
                this.layerSystem.CANVAS.backscreen_trans,
                0,
                0,
                this.postSystem.CANVAS.thumbnail.width,
                this.postSystem.CANVAS.thumbnail.height);
        } else {
            // 画像
            this.postSystem.CANVAS.post_ctx.drawImage(this.layerSystem.CANVAS.backscreen_white, 0, 0);
            // サムネ
            this.postSystem.CANVAS.thumbnail_ctx.fillStyle = '#ffffff';
            this.postSystem.CANVAS.thumbnail_ctx.fillRect(0, 0, this.postSystem.CANVAS.thumbnail.width, this.postSystem.CANVAS.thumbnail.height);
            this.postSystem.CANVAS.thumbnail_ctx.drawImage(
                this.layerSystem.CANVAS.backscreen_white,
                0,
                0,
                this.postSystem.CANVAS.thumbnail.width,
                this.postSystem.CANVAS.thumbnail.height);
        }
    }
    /**
     * 指定の番号のタブに切り替える
     * @param {String} idx タブの番号 '0':キャンバス,'1':設定,'2':投稿,'3':拡張機能
     */
    selectTab(idx) {
        // ハンバーガーメニューを開いている場合、メニューを閉じる
        const elemHamburger = document.getElementById('axp_main_checkbox_hamburger');
        if (elemHamburger.checked) {
            elemHamburger.checked = false;
        }

        // 起動オプションで登録されている拡張機能
        if (idx == '3') {
            // link設定の時は処理しない
            if (this.expansionTab.link) {
                return;
            }
            // function設定の時、正しく関数定義されていない場合はエラー
            if (!this.expansionTab.function) {
                alert('ユーザー拡張機能のプログラムが正しく設定されていません。');
                return;
            };
            // ユーザー定義されたファンクションを呼び出す
            this.expansionTab.function();
            return;
        }

        // 起動オプションで投稿が禁止されている場合は、投稿タブ選択不可
        if (idx == '2') {
            if (this.restrictPost) {
                alert('投稿先掲示板が指定されていないため、投稿することができません。');
                return;
            }
            if (!this.FUNCTION.post) {
                alert('投稿用プログラムが正しく設定されていないため、投稿することができません。');
                return;
            };
        }

        // 全タブの選択状態解除
        var targetElements_tab = document.querySelectorAll('#axp_main_div_tab_menu > div');
        targetElements_tab.forEach(element => {
            if (element.dataset.idx === idx) {
                // idxで指定されたタブを選択状態
                element.dataset.selected = 'true';
            } else {
                // それ以外は選択解除
                element.dataset.selected = 'false';
            }
        });

        var targetElements_article = document.querySelectorAll('#axp_main_div_tabContent > article');
        targetElements_article.forEach(element => {
            element.style.display = 'none';
        });
        targetElements_article[Number(idx)].style.display = 'flex';

        switch (idx) {
            // キャンバス
            case '0':
                this.isCanvasOpen = true;
                break;
            // 設定
            case '1':
                this.isCanvasOpen = false;
                // 設定タブ内のカラーパレット表示更新
                this.configSystem.dispPalettebox(document.getElementById('axp_config_div_paletteBox'), this.colorPaletteSystem.currentPalette);
                break;
            // 投稿
            case '2': {
                this.isCanvasOpen = false;
                // 投稿タブ内の情報更新
                this.drawPostCanvas();

                // 投稿ボタン有効化
                _etc_js__WEBPACK_IMPORTED_MODULE_13__.UTIL.show('axp_post_button_upload_label');
                _etc_js__WEBPACK_IMPORTED_MODULE_13__.UTIL.hide('axp_post_button_upload_loading');
                document.getElementById("axp_post_button_upload").disabled = false;

                // 基にしてお絵カキコ
                let elemRefId = document.getElementById('axp_post_span_referenceOekakiId');

                console.log(this.oekaki_id, this.draftImageFile);
                if (this.draftImageFile !== null) {
                    elemRefId.textContent = `${this._('@COMMON.DRAW_BASED')}:${(0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.getFileNameFromURL)(this.draftImageFile)}`;
                } else if (this.oekaki_id !== null) {
                    elemRefId.textContent = `${this._('@COMMON.DRAW_BASED')}:${this.oekaki_id}.png`;
                } else {
                    elemRefId.textContent = `${this._('@COMMON.DRAW_NEW')}`;
                }
                break;
            }
        }
        //console.log('main select:', idx, this.isCanvasOpen);
    }
    // 選択されているタブのindexを取得
    get selectedTab() {
        let result = null;
        const targetElements_tab = document.querySelectorAll('#axp_main_div_tab_menu > div');
        for (let element of targetElements_tab) {
            if (element.dataset.selected === 'true') {
                result = element.dataset.idx;
                break;
            }
        }
        return result;
    }
    // キャンバス移動
    moveCanvas(dx, dy) {
        this.cameraX += -dx;
        this.cameraY += -dy;
        this.refreshCanvas();
    }
    // タスク呼び出し（キーボードショートカット、カスタムボタン）
    callTask(id, inkey, repeat = false, code = null) {
        // キーカスタマイズ情報を記憶している設定メニューの要素の取得
        const elem = document.getElementById(id);
        if (!elem) {
            // 要素が存在しないキー（対応していないキー）は無効
            console.log('無効なキー:', id);
            return;
        }
        const selectMain = elem.querySelector('select:nth-of-type(1)');
        const inputSizeValue = elem.querySelector('.axpc_config_number_sizeValue');
        const inputScaleValue = elem.querySelector('.axpc_config_number_scaleValue');

        // リピート判定
        if (repeat) {
            if (
                selectMain.value === 'func_scroll_up' ||
                selectMain.value === 'func_scroll_down' ||
                selectMain.value === 'func_scroll_left' ||
                selectMain.value === 'func_scroll_right'
            ) {
                // 上記の機能は、押しっぱなし入力を受け付ける
            } else {
                // その他の機能は、押しっぱなし状態のとき、それ以上は処理しない
                return;
            }
        }

        // 割り当てられている機能を実行
        switch (selectMain.value) {
            case 'func_loupe':
                // 拡大率
                this.setScale(Number(inputScaleValue.value));
                break;
            case 'func_size':
                // ペンの太さ
                this.penSystem.setPenSize(Number(inputSizeValue.value));
                break;
            case 'none':
                // 機能無し
                // [%1]キーには機能が割り当てられていません。（※設定で変更可能）
                this.msg('@CAU0002', inkey);
                break;
            default:
                console.log('カスタマイズTask呼び出し:', selectMain.value);
                // その他の機能
                this.TASK[selectMain.value](inkey, code);
                break;
        }
    }
    initTask() {
        // キャンバスの拡大率
        this.TASK['func_loupe_down'] = () => {
            this.zoomOutCanvas();
            // 拡大率：%1
            this.msg('@AXP0001', this.scale);
            this.refreshCanvas();
        }

        this.TASK['func_loupe_up'] = () => {
            this.zoomInCanvas();
            // 拡大率：%1
            this.msg('@AXP0001', this.scale);
            this.refreshCanvas();
        }

        this.TASK['func_loupe_reset'] = () => {
            this.zoomReset();
            // 拡大率とキャンバスの位置をリセットしました。
            this.msg('@INF0002');
            this.refreshCanvas();
        }

        // ペンツール選択
        const switchPenMain = (id, inkey) => {
            const element = document.getElementById(id);
            this.penSystem.switchMainButton(element, inkey);
            this.msg(
                element.dataset.msg,
                element.dataset.key ? `${element.dataset.key}:` : '',
                // サブボタンのメッセージIDの文章を取得し、先頭の%1を除外する
                _message_js__WEBPACK_IMPORTED_MODULE_14__.Message.getMessage(element.dataset.addmsg).slice(2),
            );
        }
        this.TASK['func_switch_pen'] = (inkey) => {
            switchPenMain('axp_pen_button_penBase', inkey);
        }
        this.TASK['func_switch_eraser'] = (inkey) => {
            switchPenMain('axp_pen_button_eraserBase', inkey);
        }
        this.TASK['func_switch_fill'] = (inkey) => {
            switchPenMain('axp_pen_button_fillBase', inkey);
        }
        this.TASK['func_switch_hand'] = (inkey) => {
            switchPenMain('axp_pen_button_handBase', inkey);
        }
        this.TASK['func_switch_spuit'] = (inkey) => {
            switchPenMain('axp_pen_button_spuitBase', inkey);
        }
        this.TASK['func_switch_toggle'] = (inkey) => {
            const isNotPen = document.getElementById('axp_pen_button_penBase').dataset.selected !== 'true';
            // ペン以外が選択されている時はペンに、ペンが選択されているときは消しゴムに切り替え
            if (isNotPen) {
                this.penSystem.switchMainButton(document.getElementById('axp_pen_button_penBase'), inkey);
            } else {
                this.penSystem.switchMainButton(document.getElementById('axp_pen_button_eraserBase'), inkey);
            }
            let shortcut = '';
            const key = this.configSystem.getShortcutFunction('func_switch_toggle');
            if (key) {
                shortcut = `${key}:`;
            }
            // @AXP0010,%1ペン／消しゴム切替(%2)
            this.msg('@AXP0010', shortcut, isNotPen ? 'ペン' : '消しゴム');
        }

        // 種別選択
        const switchPenSub = (id) => {
            const element = document.getElementById(id);
            this.penSystem.switchSubButton(element);
            this.msg(
                element.dataset.msg,
                element.dataset.key ? `${element.dataset.key}:` : '',
            );
        }
        this.TASK['func_switch_axp_penmode_round'] = () => {
            switchPenSub('axp_penmode_round');
        }
        this.TASK['func_switch_axp_penmode_square'] = () => {
            switchPenSub('axp_penmode_square');
        }
        this.TASK['func_switch_axp_penmode_dot'] = () => {
            switchPenSub('axp_penmode_dot');
        }
        this.TASK['func_switch_axp_penmode_fude'] = () => {
            switchPenSub('axp_penmode_fude');
        }
        this.TASK['func_switch_axp_penmode_crayon'] = () => {
            switchPenSub('axp_penmode_crayon');
        }
        this.TASK['func_switch_axp_penmode_brush'] = () => {
            switchPenSub('axp_penmode_brush');
        }
        this.TASK['func_switch_axp_penmode_eraser_round'] = () => {
            switchPenSub('axp_penmode_eraser_round');
        }
        this.TASK['func_switch_axp_penmode_eraser_dot'] = () => {
            switchPenSub('axp_penmode_eraser_dot');
        }
        this.TASK['func_switch_axp_penmode_fill'] = () => {
            switchPenSub('axp_penmode_fill');
        }
        this.TASK['func_switch_axp_penmode_fillgradation'] = () => {
            switchPenSub('axp_penmode_fillgradation');
        }
        this.TASK['func_switch_axp_penmode_hand'] = () => {
            switchPenSub('axp_penmode_hand');
        }
        this.TASK['func_switch_axp_penmode_move'] = () => {
            switchPenSub('axp_penmode_move');
        }

        // アンドゥ
        this.TASK['func_undo'] = () => {
            this.undoSystem.undo();
        }
        // リドゥ
        this.TASK['func_redo'] = () => {
            this.undoSystem.redo();
        }
        // 自動保存から復元
        this.TASK['func_restore'] = () => {
            this.saveSystem.restore();
        }
        // セーブ
        this.TASK['func_save'] = () => {
            this.saveSystem.save();
        }
        // ロード
        this.TASK['func_load'] = () => {
            this.saveSystem.load();
        }
        // 左右反転
        this.TASK['func_flip_h'] = () => {
            this.assistToolSystem.flip_h();
        }
        // 上下反転
        this.TASK['func_flip_v'] = () => {
            this.assistToolSystem.flip_v();
        }
        // 背景透過
        this.TASK['func_transparent'] = () => {
            this.assistToolSystem.transparent();
        }
        // 補助線
        this.TASK['func_grid'] = () => {
            this.assistToolSystem.grid();
        }
        // ツールウィンドウ位置の初期化
        this.TASK['func_init_window_positon'] = () => {
            this.dragWindow.resetPosition();
            // ツールウィンドウの位置を初期化しました。
            this.msg('@INF0003');
        }
        // 背景タイル表示（キーボードショートカット専用）
        this.TASK['func_backgroundimage'] = () => {
            this.isBackgroundimage = !this.isBackgroundimage;
            if (this.isBackgroundimage) {
                this.url_backgroundimage = this.layerSystem.CANVAS.backscreen_white.toDataURL("image/png");
                this.ELEMENT.view.style.backgroundImage = "url(" + this.url_backgroundimage + ")";
            } else {
                this.ELEMENT.view.style.backgroundImage = null;
            }
            // ガイド
            var msgtext = this.isBackgroundimage ? "表示" : "非表示";
            // 背景のタイルプレビューを切り替えました。（現在の状態:%1）
            this.msg('@INF0005', msgtext);
        }

        // 画像をpngファイルとしてダウンロード
        this.TASK['func_download'] = () => {
            this.layerSystem.downloadImage();
        }

        // メインカラーを選択
        this.TASK['func_switch_maincolor'] = () => {
            this.colorMakerSystem.selectMainColor();
        }
        // サブカラーを選択
        this.TASK['func_switch_subcolor'] = () => {
            this.colorMakerSystem.selectSubColor();
        }
        // 透明色を選択
        this.TASK['func_switch_transparent'] = () => {
            this.colorMakerSystem.selectTransparent();
        }

        // メインとサブの色をスワップ
        this.TASK['func_swap_maincolor'] = () => {
            this.colorMakerSystem.swap_maincolor();
        }

        // 透明色とメインカラーを切替
        this.TASK['func_swap_transparent'] = () => {
            this.colorMakerSystem.swap_transparent();
        }

        // レイヤーの新規作成
        this.TASK['func_layer_create'] = () => {
            this.layerSystem.buttonCreateLayer()
        }
        // レイヤーの統合
        this.TASK['func_layer_integrate'] = () => {
            this.layerSystem.buttonIntegrateLayer()
        }
        // レイヤーのコピー
        this.TASK['func_layer_copy'] = () => {
            this.layerSystem.buttonCopyLayer()
        }
        // レイヤーの削除
        this.TASK['func_layer_delete'] = () => {
            this.layerSystem.buttonDeleteLayer()
        }
        // レイヤーのクリア
        this.TASK['func_layer_clear'] = () => {
            this.layerSystem.buttonClearLayer()
        }

        // キャンバス全塗り潰し
        this.TASK['func_fill_all'] = () => {
            // 書き込み不可状態チェック
            if (this.layerSystem.isWriteProtection()) {
                let layerName = this.layerSystem.getName();
                let reasonText = this.layerSystem.getReasonTextForWriteProtection();
                // %1が%2のため、全面塗り潰しできません。
                this.msg('@CAU0003', layerName, reasonText);
                return;
            }
            // ペンモードのチェック（ペンまたは消しゴム以外のときは、不透明度が参照できないため処理しない）
            switch (this.penSystem.getType()) {
                case 'draw':
                case 'eraser':
                case 'fill':
                    break;
                default:
                    // 全面塗り潰しを使用する際は、ペン、消しゴム、バケツのいずれかを選択した状態にしてください。
                    this.msg('@CAU0004');
                    return
            }
            this.penSystem.fillAll();
            let layerName = this.layerSystem.getName();
            // %1を全面塗り潰ししました。
            this.msg('@INF0006', layerName);
        }

        // 90°回転
        this.TASK['func_rotate'] = () => {
            // 書き込み不可状態チェック
            if (this.layerSystem.isWriteProtection()) {
                let layerName = this.layerSystem.getName();
                let reasonText = this.layerSystem.getReasonTextForWriteProtection();
                // %1が%2のため、90°回転できません。
                this.msg('@CAU0005', layerName, reasonText);
                return;
            }
            this.penSystem.rotate90();
            let layerName = this.layerSystem.getName();
            // %1を90°回転しました。
            this.msg('@INF0007', layerName);
        }
        // ペンの太さを１段階下げる
        this.TASK['func_size_down'] = () => {
            this.penSystem.downPenSize();
        }
        // ペンの太さを１段階上げる
        this.TASK['func_size_up'] = () => {
            this.penSystem.upPenSize();
        }
        // ペンの不透明度を１段階下げる
        this.TASK['func_alpha_down'] = () => {
            this.penSystem.changePenAlpha('down');
        }
        // ペンの不透明度を１段階上げる
        this.TASK['func_alpha_up'] = () => {
            this.penSystem.changePenAlpha('up');
        }

        // キャンバス全体のぼかしの切り替え
        this.TASK['func_swap_pixelated'] = () => {
            const radioForm = document.getElementById('axp_config_form_antialiasing');
            const isTurnON = this.config('axp_config_form_antialiasing') !== 'on';
            if (isTurnON) {
                radioForm.elements[1].checked = true;
            } else {
                radioForm.elements[0].checked = true;
            }
            // 状態変更
            this.configSystem.set_canvas_antialiasing();
            // コンフィグ保存
            this.configSystem.saveConfig(`RADIO_axp_config_form_antialiasing`, isTurnON ? 'on' : 'off');
            // キャンバス全体のぼかしを切り替えました。(現在の状態:%1)
            this.msg('@INF0009', isTurnON ? 'あり' : 'なし');
        }

        const func_scroll = (x, y) => {
            const move_size = Number(document.getElementById('axp_config_number_moveSize').value);
            // 方向（設定で反転がチェックされている場合、移動方向を反転させる）
            const move_vector = document.getElementById('axp_config_checkbox_moveDirection').checked ? -1 : 1;
            this.moveCanvas(
                x * move_size * move_vector,
                y * move_size * move_vector
            );
        }
        // 画面の上スクロール
        this.TASK['func_scroll_up'] = () => {
            func_scroll(0, 1);
        }
        // 画面の下スクロール
        this.TASK['func_scroll_down'] = () => {
            func_scroll(0, -1);
        }
        // 画面の左スクロール
        this.TASK['func_scroll_left'] = () => {
            func_scroll(1, 0);
        }
        // 画面の右スクロール
        this.TASK['func_scroll_right'] = () => {
            func_scroll(-1, 0);
        }

        const func_grid = (inkey) => {
            // 補助線分割数
            if (this.assistToolSystem.isGrid) {
                let div_h = document.getElementById('axp_tool_form_gridH').volume.value;
                let div_v = document.getElementById('axp_tool_form_gridV').volume.value;
                switch (inkey) {
                    // 縦
                    case 'up_v':
                        if (div_v < 16) div_v++;
                        // 連動
                        if (document.getElementById('axp_tool_checkbox_gridVHLink').checked) {
                            div_h = div_v;
                        }
                        break;
                    case 'down_v':
                        if (div_v > 2) div_v--;
                        // 連動
                        if (document.getElementById('axp_tool_checkbox_gridVHLink').checked) {
                            div_h = div_v;
                        }
                        break;
                    // 横
                    case 'up_h':
                        if (div_h < 16) div_h++;
                        // 連動
                        if (document.getElementById('axp_tool_checkbox_gridVHLink').checked) {
                            div_v = div_h;
                        }
                        break;
                    case 'down_h':
                        if (div_h > 2) div_h--;
                        // 連動
                        if (document.getElementById('axp_tool_checkbox_gridVHLink').checked) {
                            div_v = div_h;
                        }
                        break;
                }
                // スライダー更新
                document.getElementById('axp_tool_form_gridH').volume.value = div_h;
                document.getElementById('axp_tool_form_gridH').result.value = div_h;
                document.getElementById('axp_tool_form_gridV').volume.value = div_v;
                document.getElementById('axp_tool_form_gridV').result.value = div_v;
                this.updateGrid();
                // コンフィグ保存
                this.configSystem.saveConfig('RANGE_axp_tool_form_gridH', div_h);
                this.configSystem.saveConfig('RANGE_axp_tool_form_gridV', div_v);
                // 補助線分割数 横：%1 / 縦：%2
                this.msg('@AXP0004', div_h, div_v);
            } else {
                // 補助線が表示されているときに有効なショートカットです。
                this.msg('@CAU0206');
            }
        }
        // 分割数:横を増やす
        this.TASK['func_grid_up_h'] = () => {
            func_grid('up_h');
        }
        // 分割数:横を減らす
        this.TASK['func_grid_down_h'] = () => {
            func_grid('down_h');
        }
        // 分割数:縦を増やす
        this.TASK['func_grid_up_v'] = () => {
            func_grid('up_v');
        }
        // 分割数:縦を減らす
        this.TASK['func_grid_down_v'] = () => {
            func_grid('down_v');
        }

        // ペンの太さ調整
        this.TASK['func_size_change'] = (inkey, code) => {
            if (!inkey) {
                throw new Error('内部エラー：引数にキーが指定されていません（キーボード専用機能です）');
            }
            this.penSystem.modeChangeSizeOn(inkey, code);
        }

    }
    // 表示系メソッド
    /**
     * 画面下部のメッセージエリアに引数で指定されたIDに対応するメッセージテキストを表示する。
     * IDの種類に応じてアイコンを表示する
     * INF:information
     * CAU:caution
     * COL:colormaker
     * ERR:ng
     * @param {String} text 表示するメッセージID（または文字列）
     * @param {String} addText 任意の数の追加テキスト。元メッセージの%nの部分を追加テキストで順番に置換する。
     */
    msg(text, ...addText) {
        let msgType = text.substring(0, 4);
        // 重要なメッセージ
        let isImportantMessage = false;
        switch (msgType) {
            case '@INF':
            case '@CAU':
            case '@ERR':
                isImportantMessage = true;
                break;
        }
        // 重要なメッセージの表示継続中（タイマー起動中）は、通常メッセージの表示をスキップする。
        if (!isImportantMessage && this.messageTimerID) {
            //console.log('メッセージスキップ:', text);
            return;
        }

        // アイコン表示
        let iconElement = document.getElementById('axp_footer_div_icon');
        iconElement.classList.remove(...iconElement.classList);
        switch (msgType) {
            case '@INF':
                iconElement.classList.add('axpc_icon_msg_information');
                break;
            case '@CAU':
                iconElement.classList.add('axpc_icon_msg_caution');
                break;
            case '@COL':
                iconElement.classList.add('axpc_icon_msg_color');
                break;
            case '@ERR':
                iconElement.classList.add('axpc_icon_msg_ng');
                break;
        }
        let replaceText;
        if (text.substring(0, 1) === '@') {
            const id = text.substring(0, 8);
            //console.log('変換対象のメッセージ', id);
            replaceText = _message_js__WEBPACK_IMPORTED_MODULE_14__.Message.getMessage(id);
        } else {
            replaceText = text;
        }
        // 特殊ワード時のメッセージリダイレクト
        if (replaceText === '%penPreviewGuide') {
            let name = this.penSystem.getName();
            // 描画タイプに対応したメッセージ変動
            switch (this.penSystem.getType()) {
                case 'draw':
                case 'eraser':
                    this.msg('@PEN0201', name);
                    break;
                case 'fill':
                    if (this.penSystem.pen_mode === 'axp_penmode_fillgradation') {
                        this.msg('@PEN0203', name);
                    } else {
                        this.msg('@PEN0202', name);
                    }
                    break;
                case 'spuit':
                    this.msg('@PEN0204');
                    break;
            }
            return;
        }
        // 特殊ワードの置換
        replaceText = replaceText.replace('%drawingColorName', this.colorMakerSystem.drawingColorName);
        replaceText = replaceText.replace('%addPaletteName', this.colorMakerSystem.addPaletteName);

        // 追加テキストの置換
        for (let idx = 0; idx < addText.length; idx++) {
            if (replaceText.indexOf(`%${idx + 1}`) !== -1) {
                //console.log(`%${idx + 1}を置換`);
                replaceText = replaceText.replace(`%${idx + 1}`, addText[idx]);
            }
        }

        // テキスト表示
        this.ELEMENT.info.textContent = replaceText;

        // 重要なメッセージのタイマーセット
        if (isImportantMessage) {
            // タイマーセット
            this.messageTimerID = setTimeout(() => {
                this.messageTimerID = null;
            }, this.CONST.MESSAGE_KEEP_TIME);
        }
    }
    /**
     * 背景タイルプレビューを表示する
     */
    drawBackground() {
        // Firefoxだと更新時にちらつきが発生するため、１つ前の状態の画像と重ねて指定する
        // 新旧の画像で透過状態が異なると、描画に不具合が発生するため、常に白地背景とする。
        let url_newimage = this.layerSystem.CANVAS.backscreen_white.toDataURL("image/png");
        this.ELEMENT.view.style.backgroundImage = "url(" + url_newimage + ")" + ",url(" + this.url_backgroundimage + ")";
        this.url_backgroundimage = url_newimage;
    }
    // GETパラメータ取得
    getURLParms() {
        const url = new URL(window.location.href);
        let params = url.searchParams;
        this.oekaki_id = params.get('oekaki_id');
        this.oekaki_width = params.get('oekaki_width');
        this.oekaki_height = params.get('oekaki_height');

        // 実行環境URL
        console.log('exec_URL:', url.href);
        // メモ: url.href にはGETパラメータが含まれる（url.pathnameには含まれない）
        //console.log('url.origin:', url.origin);
        //console.log('url.pathname:', url.pathname);
        //console.log('url.href:', url.href);
        // 同一掲示板チェックのため、url.pathnameとHTMLの<title>を保存する
        this.post_bbs_pageno = url.pathname;
        this.post_bbs_title = document.getElementsByTagName('title')[0].innerText;

        console.log('url.pathname:', this.post_bbs_pageno);
        console.log('ページタイトル:', this.post_bbs_title);
    }
    exec() {
        //console.log('devicePixelRatio:', window.devicePixelRatio);

        // 各種初期化（非同期処理を含むため、処理順序を厳密にする）
        (async () => {
            this.getURLParms();

            // キャンバスサイズ初期値
            // 起動オプションでデフォルト値が指定されている場合はその値を使う
            if (this.option_width) {
                this.x_size = Number(this.option_width);
            } else {
                // ※この後に範囲チェックでサイズ修整を行うため、最大最小が変更されていた場合も一旦デフォルト値を設定しておく
                this.x_size = this.CONST.CANVAS_X_DEFAULT;
            }
            if (this.option_height) {
                this.y_size = Number(this.option_height);
            } else {
                this.y_size = this.CONST.CANVAS_Y_DEFAULT;
            }

            // 下書き機能を使用する場合の判定
            let isDraftLoaded = false;
            let imageload_src = null;
            let imageload_filename = null;
            // 読み込み画像ファイル名の決定
            if (this.draftImageFile !== null) {
                // 起動オプション指定時（優先）
                imageload_src = this.draftImageFile;
                // URLパラメータ指定があっても無効にする
                this.oekaki_id = null;
            } else if (this.oekakiURL !== null && this.oekaki_id !== null) {
                // URLパラメータ指定時
                imageload_src = this.oekakiURL + this.oekaki_id + '.png';
            } else {
                // 起動オプションoekakiURLが指定されていない場合は、URLパラメータ無効
                this.oekaki_id = null;
            }
            // 画像読み込み
            if (imageload_src !== null) {
                // パスを除いたファイル名だけを取り出す
                imageload_filename = (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.getFileNameFromURL)(imageload_src);
                // テキスト表示（※初期化前なので、this.msg()はまだ使用できない）
                document.getElementById('axp_footer_div_message').textContent = `[${imageload_filename}]を読み込みしています...`;
                // 基にしてお絵カキコする画像のロード
                await (0,_etc_js__WEBPACK_IMPORTED_MODULE_13__.loadImageWithTimeout)(imageload_src, this.oekakiTimeout)
                    .then(image => {
                        // 読み込み成功
                        this.oekaki_base = image;
                        // キャンバス汚染確認（ローカルファイルを読み込ませた場合getImageDataで例外が発生する）
                        // 汚染されたキャンバスは廃棄する
                        const checkTaintCanvas = document.createElement('canvas');
                        const checkTaintCanvas_ctx = checkTaintCanvas.getContext('2d');
                        checkTaintCanvas_ctx.drawImage(this.oekaki_base, 0, 0);
                        checkTaintCanvas_ctx.getImageData(0, 0, 1, 1);
                        // キャンバス情報更新
                        this.x_size = this.oekaki_base.naturalWidth;
                        this.y_size = this.oekaki_base.naturalHeight;
                        // 下書き情報保存
                        this.oekaki_bbs_pageno = this.post_bbs_pageno;
                        this.oekaki_bbs_title = this.post_bbs_title;
                        console.log('下書き画像:', this.x_size, this.y_size, this.oekaki_id, this.draftImageFile);
                        // 下書きロード済
                        isDraftLoaded = true;
                    })
                    .catch(error => {
                        // 画像読み込みエラー
                        console.error(error);
                        alert(`下書き画像の読み込みに失敗しました。\n新規キャンバスを作成します。\n${error}`);
                        // テキスト表示クリア
                        document.getElementById('axp_footer_div_message').textContent = '';
                        this.oekaki_id = null;
                        this.draftImageFile = null;
                    });
            } else {
                // 新規描画（通常時）
                // URLパラメータでキャンバスサイズが指定されている場合はその値を優先して使う
                if (this.oekaki_width) {
                    this.x_size = Number(this.oekaki_width);
                }
                if (this.oekaki_height) {
                    this.y_size = Number(this.oekaki_height);
                }
            }

            // キャンバスサイズチェック
            this.setCanvasSize(this.x_size, this.y_size);
            // ここで最終的なキャンバスサイズが確定

            // 起動後に１度だけ行う初期化処理
            this.init();

            // 拡張機能
            if (_extensions__WEBPACK_IMPORTED_MODULE_17__.isExtenstions) {
                this.exTool = new _extensions__WEBPACK_IMPORTED_MODULE_17__.ExTool(this);
                this.exTool.init();
            }

            // 設定のHTMLを展開（ユーザー設定を受け取る準備）
            this.configSystem.deployHTML();

            // キャンバス初期化
            this.resetCanvas();

            // DB初期処理(indexedDBは非同期で動作するため、awaitで実行完了を待つ)
            if (await this.saveSystem.initDB()) {
                //console.log('1:コンフィグ読込');
                // ユーザー設定読込
                let result;
                try {
                    result = await this.saveSystem.load_config();
                    if (result) {
                        this.configSystem.restoreConfig(result);
                    } else {
                        // ユーザー設定データが存在しない場合、初回起動と判定する
                        this.ENV.isFirstLaunch = true;
                    }
                } catch (error) {
                    console.log(error);
                    alert('エラー:ユーザー設定の読み込みに失敗しました。デフォルト設定で起動します。');
                }
                //console.log('2:パレット初期化');
                // カラーパレット初期化
                if (this.config('axp_config_form_saveLastPalleteColor') === 'off') {
                    // 設定で、パレット情報初期化が指定されている場合は、パレット情報読込をスキップ
                } else {
                    // ユーザー設定パレット情報読込
                    let result;
                    try {
                        result = await this.saveSystem.load_palette();
                        if (result) {
                            this.colorPaletteSystem.setPaletteArray(result);
                        }
                        // 保存されているパレット情報がない場合は更新しない（デフォルトパレット使用）
                    } catch (error) {
                        console.log(error);
                        alert('エラー:ユーザーパレットの読み込みに失敗しました。デフォルト設定で起動します。');
                    }
                }
            }
            // ユーザー設定の復元が完了した後に行う処理 ------------------------------------------------

            // URLパラメータでキャンバスサイズの指定がされていた場合、補正後のキャンバスサイズを登録する
            if (this.oekaki_width || this.oekaki_height) {
                // キャンバスサイズ履歴への追加と表示更新
                this.configSystem.addCanvasSizeHistory(this.x_size, this.y_size);
                this.configSystem.updateCanvasSizeHistory();
            }

            // 初期レイヤー作成（※合成モード表示の設定があるため、設定復元完了後に行う必要がある）
            this.layerSystem.newLayer();

            // アンドゥ使用可能最大数
            this.undo_max = document.getElementById('axp_config_form_undoMaxValue').result.value;
            // カスタムボタンツールウィンドウ表示切替
            this.dispCustomButton();
            // 色作成ツールウィンドウ表示切替
            this.colorMakerSystem.updateMakeColorType();
            //console.log('3:パレット作成');
            this.colorPaletteSystem.createPalette();

            // 設定に拡大率テーブルを作成
            this.configSystem.createConfigScaleTable(this.currentScaleTable);
            // キーカスタマイズに拡大率テーブルを反映
            this.configSystem.updateKeyCustomizationScaleTable(this.currentScaleTable);
            // キーカスタマイズの折りたたみ
            this.configSystem.switchNofuncKeytable();
            this.configSystem.updateShortcutMessage();
            // キャンバスぼかし
            this.configSystem.set_canvas_antialiasing();
            // 座標表示
            this.configSystem.set_display_position();
            // 長押しスポイト
            this.configSystem.set_longtap_use();
            // ツールウィンドウ位置初期化
            this.dragWindow.initPosition();
            // ユーザー設定が復元された後のペンツールの再描画
            this.penSystem.changePenMode();
            // 初回起動かつモバイル端末の場合、単一ウィンドウモードを強制設定
            if (this.ENV.isFirstLaunch && this.ENV.isMobileWidth) {
                document.getElementById('axp_config_checkbox_singleWindowMode').checked = true;
                this.configSystem.saveConfig('CHECK_axp_config_checkbox_singleWindowMode', true);
                // 単一ウィンドウモード
                this.launcher.setSingleWindowMode(true, false);
                alert('* 初回起動設定 *\n画面幅が600px未満のため、単一ウィンドウモードに設定しました。[設定]-[ツールウィンドウ]で変更が可能です。');
            } else {
                if (document.getElementById('axp_config_checkbox_singleWindowMode').checked) {
                    // 単一ウィンドウモード、復元時
                    this.launcher.setSingleWindowMode(true, true);
                }
            }

            // 下書き読込
            if (isDraftLoaded) {
                // 基にしてお絵カキコ
                this.layerSystem.CANVAS.tmp_ctx.drawImage(this.oekaki_base, 0, 0);
                // レイヤー更新
                this.layerSystem.write(this.layerSystem.CANVAS.tmp_ctx.getImageData(0, 0, this.x_size, this.y_size));
                // [%1.png]を読み込みました。(画像サイズ 横:%2 × 縦:%3)
                this.msg('@INF0050', imageload_filename, this.x_size, this.y_size);
            }

            // キャンバス更新
            this.layerSystem.updateCanvas();

            // キャンバス座標センタリング（起動時限定の処理）
            let base_x = this.paintBodyElement.clientWidth;
            let etc_y = 30 + 32;
            let base_y = this.paintBodyElement.clientHeight - etc_y; // ヘッダとフッターのサイズを引く
            let center_x = base_x / 2 - this.x_size / 2;
            let center_y = base_y / 2 - this.y_size / 2;
            this.CANVAS.main.style.left = center_x + 'px';
            this.CANVAS.main.style.top = center_y + 'px';

            // イベント受付開始
            this.startEvent();
            // 拡張機能イベント受付開始
            if (this.exTool) {
                this.exTool.startEvent();
            }
        })();
    }
    config(id) {
        let element = document.getElementById(id);
        if (element) {
            return element.elements[id].value;
        }
        return;
    }
    // カスタムボタンの表示切替
    dispCustomButton() {
        const list = document.querySelectorAll('#axp_config_div_customButtonFunction > select,#axp_config_div_customButtonFunction > input');
        if (this.config('axp_config_form_useCustomButton') === 'on') {
            this.customButtonSystem.windowElement.style.display = '';
            for (const item of list) {
                item.disabled = false;
            }
            document.getElementById('axp_config_div_customButtonFunction').style.opacity = '1';
        } else {
            this.customButtonSystem.windowElement.style.display = 'none';
            for (const item of list) {
                item.disabled = true;
            }
            document.getElementById('axp_config_div_customButtonFunction').style.opacity = '0.5';
        }
    }
    // サブウィンドウクローズ
    closeSubwindow = (id) => {
        this.isModalOpen = false;
        _etc_js__WEBPACK_IMPORTED_MODULE_13__.UTIL.hide(id);
    }
    // サブウィンドウオープン
    openSubwindow = (id, baseElement) => {
        this.isModalOpen = true;
        // 非表示だとwindowHeightが取得できないため、先にshowを行う
        _etc_js__WEBPACK_IMPORTED_MODULE_13__.UTIL.show(id);
        const elementSubwindow = document.querySelector(`#${id}>div`);
        // キャンバスタブエリア
        const canvasRect = document.getElementById('axp_canvas').getBoundingClientRect();
        // サブウィンドウの高さ
        const windowHeight = elementSubwindow.getBoundingClientRect().height;
        // 押されたボタンの矩形情報
        const baseElementRect = baseElement.getBoundingClientRect();
        let x, y;
        x = baseElementRect.left - canvasRect.left;
        // キャンバスタブエリアのトップ＋キャンバスタブエリアの高さから、baseElement要素のボトム座標を引いた残りが、
        // サブウィンドウの高さ以上ならば、下側にはみ出すことなく表示可能
        if (canvasRect.top + canvasRect.height - baseElementRect.bottom > windowHeight) {
            // 要素の下側
            y = baseElementRect.bottom - canvasRect.top;
        } else {
            // 要素の上側
            y = baseElementRect.top - windowHeight - canvasRect.top;
        }
        elementSubwindow.style.marginLeft = `${x}px`;
        elementSubwindow.style.marginTop = `${y}px`;
    }
    debugStatus() {
        this.debugLog.status(
            this.evCache.length,
            this.fingerCount,
            this.isDrawing, this.isDrawn, this.isDrawCancel,
        );
    }
}


/***/ }),

/***/ "./src/js/config.js":
/*!**************************!*\
  !*** ./src/js/config.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigSystem: () => (/* binding */ ConfigSystem)
/* harmony export */ });
/* harmony import */ var _alert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alert.js */ "./src/js/alert.js");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./etc.js */ "./src/js/etc.js");
/* harmony import */ var _html_config_txt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../html/config.txt */ "./src/html/config.txt");
/* harmony import */ var _pendefine_rangeindex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pendefine/rangeindex.js */ "./src/js/pendefine/rangeindex.js");
// @description 設定（ユーザーカスタマイズ機能）





// css適用
__webpack_require__(/*! ../css/config.css */ "./src/css/config.css");

// ショートカットキーバインド
const objButtonFunction = [
    ['1', '1', 'func_undo'],
    ['2', '2', 'none'],
    ['3', '3', 'none'],
]
const objKeyFunction = [
    ['*', 'ASTERISK', 'none'],
    ['+', 'PLUS', 'func_loupe_up'],
    [',', 'COMMA', 'none'],
    ['-', 'MINUS', 'func_loupe_down'],
    ['.', 'DOT', 'none'],
    ['/', 'SLASH', 'none'],
    ['1', '1', 'none'],
    ['2', '2', 'none'],
    ['3', '3', 'none'],
    ['4', '4', 'none'],
    ['5', '5', 'none'],
    ['6', '6', 'none'],
    ['7', '7', 'none'],
    ['8', '8', 'none'],
    ['9', '9', 'none'],
    ['0', '0', 'func_loupe_reset'],
    [':', 'COLON', 'none'],
    [';', 'SEMICOLON', 'func_loupe_up'],
    ['A', 'A', 'none'],
    ['B', 'B', 'func_backgroundimage'],
    ['C', 'C', 'func_swap_transparent'],
    ['D', 'D', 'none'],
    ['E', 'E', 'func_size_up'],
    ['F', 'F', 'none'],
    ['G', 'G', 'func_grid'],
    ['H', 'H', 'func_flip_h'],
    ['I', 'I', 'func_init_window_positon'],
    ['J', 'J', 'none'],
    ['K', 'K', 'func_rotate'],
    ['L', 'L', 'func_load'],
    ['M', 'M', 'func_flip_h'],
    ['N', 'N', 'none'],
    ['O', 'O', 'none'],
    ['P', 'P', 'func_swap_pixelated'],
    ['Q', 'Q', 'func_size_change'],
    ['R', 'R', 'func_restore'],
    ['S', 'S', 'func_save'],
    ['T', 'T', 'func_transparent'],
    ['U', 'U', 'func_fill_all'],
    ['V', 'V', 'func_flip_v'],
    ['W', 'W', 'func_size_down'],
    ['X', 'X', 'func_swap_maincolor'],
    ['Y', 'Y', 'func_redo'],
    ['Z', 'Z', 'func_undo'],
    ['Backspace', 'BACKSPACE', 'func_undo'],
    ['Enter', 'ENTER', 'none'],
    ['↑', 'ARROWUP', 'func_scroll_up'],
    ['↓', 'ARROWDOWN', 'func_scroll_down'],
    ['←', 'ARROWLEFT', 'func_scroll_left'],
    ['→', 'ARROWRIGHT', 'func_scroll_right'],
];

const mapFunction = new Map();

// 設定機能制御オブジェクト
class ConfigSystem {
    axpObj;
    CONST = {
        // キャンバスサイズの過去履歴保存数
        CANVAS_SIZE_HISTORY_MAX: 8,
    }
    // ユーザー設定を保存する連想配列
    configObj;
    // キャンバスサイズ履歴
    configCanvasSizeHistory = [];
    // 数字キーのカスタマイズ用セレクトボックスのオプション定義
    optionlist = [
        { value: 'optgroup', name: '機能無し' },
        { value: 'none', name: '---' },
        { value: '/optgroup' },
        { value: 'optgroup', name: 'ペンツール選択' },
        { value: 'func_switch_pen', name: '選択:ペン' },
        { value: 'func_switch_eraser', name: '選択:消しゴム' },
        { value: 'func_switch_fill', name: '選択:バケツ' },
        { value: 'func_switch_hand', name: '選択:ツール' },
        { value: 'func_switch_spuit', name: '選択:スポイト' },
        { value: 'func_switch_toggle', name: '選択:ペン／消しゴム切替' },
        { value: '/optgroup' },
        { value: 'optgroup', name: 'ペン種別' },
        { value: 'func_switch_axp_penmode_round', name: 'ペン種別:丸ペン' },
        { value: 'func_switch_axp_penmode_square', name: 'ペン種別:角ペン' },
        { value: 'func_switch_axp_penmode_dot', name: 'ペン種別:ドットペン' },
        { value: 'func_switch_axp_penmode_fude', name: 'ペン種別:筆ペン' },
        { value: 'func_switch_axp_penmode_crayon', name: 'ペン種別:クレヨン' },
        { value: 'func_switch_axp_penmode_brush', name: 'ペン種別:エアブラシ' },
        { value: '/optgroup' },
        { value: 'optgroup', name: '消しゴム種別' },
        { value: 'func_switch_axp_penmode_eraser_round', name: '消しゴム種別:消しゴム' },
        { value: 'func_switch_axp_penmode_eraser_dot', name: '消しゴム種別:角消しゴム' },
        { value: '/optgroup' },
        { value: 'optgroup', name: 'バケツ種別' },
        { value: 'func_switch_axp_penmode_fill', name: 'バケツ種別:バケツ' },
        { value: 'func_switch_axp_penmode_fillgradation', name: 'バケツ種別:階調バケツ' },
        { value: '/optgroup' },
        { value: 'optgroup', name: 'ツール種別' },
        { value: 'func_switch_axp_penmode_hand', name: 'ツール種別:ハンド' },
        { value: 'func_switch_axp_penmode_move', name: 'ツール種別:移動ツール' },
        { value: '/optgroup' },
        { value: 'optgroup', name: 'ペンの太さ' },
        { value: 'func_size', name: 'ペンの太さ（値指定）' },
        { value: 'func_size_change', name: 'ペンの太さ調整' },
        { value: 'func_size_up', name: 'ペンの太さを１段階上げる' },
        { value: 'func_size_down', name: 'ペンの太さを１段階下げる' },
        { value: '/optgroup' },
        { value: 'optgroup', name: 'ペンの不透明度' },
        { value: 'func_alpha_up', name: 'ペンの不透明度を１段階上げる' },
        { value: 'func_alpha_down', name: 'ペンの不透明度を１段階下げる' },
        { value: '/optgroup' },
        { value: 'optgroup', name: '描画色の選択' },
        { value: 'func_switch_maincolor', name: 'メインカラーを選択' },
        { value: 'func_switch_subcolor', name: 'サブカラーを選択' },
        { value: 'func_switch_transparent', name: '透明色を選択' },
        { value: 'func_swap_maincolor', name: 'メイン／サブカラー切替' },
        { value: 'func_swap_transparent', name: 'メイン／透過色切替' },
        { value: '/optgroup' },
        { value: 'optgroup', name: 'レイヤー操作' },
        { value: 'func_layer_create', name: 'レイヤーの新規作成' },
        { value: 'func_layer_integrate', name: 'レイヤーの統合' },
        { value: 'func_layer_copy', name: 'レイヤーのコピー' },
        { value: 'func_layer_delete', name: 'レイヤーの削除' },
        { value: 'func_layer_clear', name: 'レイヤーのクリア' },
        { value: 'func_fill_all', name: '全面塗り潰し' },
        { value: 'func_rotate', name: '90°回転' },
        { value: '/optgroup' },
        { value: 'optgroup', name: '補助ツール' },
        { value: 'func_undo', name: 'アンドゥ' },
        { value: 'func_redo', name: 'リドゥ' },
        { value: 'func_restore', name: '自動保存から復元' },
        { value: 'func_save', name: 'セーブ' },
        { value: 'func_load', name: 'ロード' },
        { value: 'func_flip_h', name: '全レイヤー左右反転' },
        { value: 'func_flip_v', name: '全レイヤー上下反転' },
        { value: 'func_transparent', name: '背景透過' },
        { value: 'func_grid', name: '補助線' },
        { value: '/optgroup' },
        { value: 'optgroup', name: '拡大率' },
        { value: 'func_loupe', name: '拡大率（値指定）' },
        { value: 'func_loupe_down', name: '拡大率を１段階縮小' },
        { value: 'func_loupe_reset', name: '拡大率とキャンバス位置のリセット' },
        { value: 'func_loupe_up', name: '拡大率を１段階拡大' },
        { value: '/optgroup' },
        { value: 'optgroup', name: '画面スクロール' },
        { value: 'func_scroll_up', name: '画面を上スクロール' },
        { value: 'func_scroll_down', name: '画面を下スクロール' },
        { value: 'func_scroll_left', name: '画面を左スクロール' },
        { value: 'func_scroll_right', name: '画面を右スクロール' },
        { value: '/optgroup' },
        { value: 'optgroup', name: '補助線分割数' },
        { value: 'func_grid_up_h', name: '分割数:横を増やす' },
        { value: 'func_grid_down_h', name: '分割数:横を減らす' },
        { value: 'func_grid_up_v', name: '分割数:縦を増やす' },
        { value: 'func_grid_down_v', name: '分割数:縦を減らす' },
        { value: '/optgroup' },
        { value: 'optgroup', name: 'その他' },
        { value: 'func_init_window_positon', name: 'ツールウィンドウの位置初期化' },
        { value: 'func_swap_pixelated', name: 'キャンバス全体のぼかし切替' },
        { value: 'func_backgroundimage', name: '背景タイルプレビュー' },
        { value: 'func_download', name: '画像をPNG形式でファイルに保存' },
        { value: '/optgroup' },
    ];
    constructor(axpObj) {
        this.axpObj = axpObj;
        this.configObj = new Map();
    }
    // 初期化
    init() {
        // HTML生成
        let targetElement = document.getElementById('axp_config');
        targetElement.insertAdjacentHTML('afterbegin', this.axpObj.translateHTML(_html_config_txt__WEBPACK_IMPORTED_MODULE_2__));
        // バージョン情報の表示
        document.getElementById('axp_config_div_versionInfo').textContent = `${this.axpObj.CONST.APP_TITLE} version ${"2.4.0"} (${"2026-01-11T10:33:35.901Z"})`
    }
    // HTML展開
    deployHTML() {
        // カテゴリヘッダ生成
        const elementsHeader = document.querySelectorAll('.axpc_config_section');
        for (const div of elementsHeader) {
            // ヘッダdiv
            const newDiv = document.createElement('div');
            newDiv.setAttribute('class', 'axpc_config_sectionHeader');
            // アイコン表示部
            const newSpanIcon = document.createElement('span');
            if (div.dataset.icon) {
                newSpanIcon.classList.add('axpc_icon_span');
                newSpanIcon.classList.add(div.dataset.icon);
            }
            // タイトル表示部
            const newSpanTitle = document.createElement('span');
            newSpanTitle.textContent = div.dataset.title;
            newDiv.appendChild(newSpanIcon);
            newDiv.appendChild(newSpanTitle);

            // 直下（最初の子の前）に挿入
            div.insertAdjacentElement('afterbegin', newDiv);
        }

        // カテゴリ内グループヘッダ生成
        const elementsGroupHeader = document.querySelectorAll('.axpc_config_group');
        for (const div of elementsGroupHeader) {
            // header
            const newDiv = document.createElement('div');
            newDiv.setAttribute('class', 'axpc_config_groupHeader');
            newDiv.textContent = div.dataset.title;
            // 要素自体の前
            div.insertAdjacentElement('beforebegin', newDiv);
        }

        // ラジオボタン生成
        const elementsRadioForm = document.querySelectorAll('.axpc_radio');
        for (const form of elementsRadioForm) {
            //console.log(form.id);
            form.classList.add('axpc_SAVE');
            // form内部のspanをラジオボタンに変換する
            const elementsSpan = form.querySelectorAll('span');
            for (let idx = 0; idx < elementsSpan.length; idx++) {
                // input
                const newInput = document.createElement('input');
                const id = `${form.id}${idx}`;
                //console.log(id);
                newInput.setAttribute('type', 'radio');
                newInput.setAttribute('id', id);
                newInput.setAttribute('name', form.id);
                newInput.setAttribute('value', elementsSpan[idx].dataset.value);
                if (elementsSpan[idx].dataset.default) {
                    newInput.checked = true;
                }
                form.appendChild(newInput);
                // label
                const newLabel = document.createElement('label');
                newLabel.setAttribute('for', id);
                newLabel.setAttribute('class', 'axpc_MSG');
                newLabel.dataset.msg = elementsSpan[idx].dataset.msg;
                newLabel.textContent = elementsSpan[idx].textContent;
                form.appendChild(newLabel);
            }
        }
        // カスタムボタン用セレクトボックスの生成
        const elementsTbodyCustom = document.querySelector('#axp_config_table_customButton>tbody');
        for (let idx = 0; idx < objButtonFunction.length; idx++) {
            let tr = this.createKeyConfigHTML('button', objButtonFunction[idx]);
            // 連動するカスタムボタンのindexを指定（表示オン／オフ用）
            tr.dataset.linkIndex = idx + 1;
            elementsTbodyCustom.appendChild(tr);
            this.selectCustom(tr.id);
        }
        // キーボードショートカット用セレクトボックスの生成
        const elementsTbody = document.querySelector('#axp_config_table_shortcutKey>tbody');
        for (let idx = 0; idx < objKeyFunction.length; idx++) {
            let tr = this.createKeyConfigHTML('key', objKeyFunction[idx]);
            elementsTbody.appendChild(tr);
            this.selectCustom(tr.id);
        }
    }

    startEvent() {
        // ◆共通 ----------------------------------------------------------------
        // スクロール時のナビボタン連動
        // ボタン色変更共通
        const activateButton = (element) => {
            // すでにアクティブになっている目次を選択
            const currentActiveIndex = document.querySelector('#axp_config_div_navButton .axpc_ACTIVE');
            // すでにアクティブになっているものが0個の時（=null）以外は、axpc_ACTIVEクラスを除去
            if (currentActiveIndex !== null) {
                currentActiveIndex.classList.remove('axpc_ACTIVE');
            }
            // 引数で渡されたbutton要素に、axpc_ACTIVEクラスを付与
            element.classList.add('axpc_ACTIVE');
        }
        // 交差検知共通
        const doWhenIntersect = (entries) => {
            // 交差検知をしたもののなかで、isIntersectingがtrueのDOMを色を変える関数に渡す
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    // console.log('考査検知:', entry.target.dataset.title);
                    // ボタンの点灯を連動させる
                    const elementButton = document.querySelector(`#axp_config_div_navButton > button:nth-of-type(${entry.target.dataset.idx})`);
                    activateButton(elementButton);
                }
            });
        }
        const options = {
            root: document.querySelector('#axp_config_div_pageMain'),// 対象ルート要素
            rootMargin: "0px 0px -100% 0px", // 一番上を判定基準にする
            threshold: 0 // 閾値は0
        };
        const observer = new IntersectionObserver(doWhenIntersect, options);
        // 交差監視する要素（各セクション）
        const boxes = document.querySelectorAll('.axpc_config_section');
        // それぞれのboxを監視する（ページ末端の１件は除く）
        for (let idx = 0; idx < boxes.length - 1; idx++) {
            //console.log(idx, boxes[idx].dataset.title);
            // ボタンとのペアリング添え字（cssセレクタを使用するため開始添え字１）
            boxes[idx].dataset.idx = idx + 1;
            observer.observe(boxes[idx]);
        };
        /*
        // 慣性監視（廃止）
        let isScrolling = false;
        const callbackScrollEnd = () => { isScrolling = false; }
        document.getElementById('axp_config_div_pageMain').addEventListener('scroll', () => {
            isScrolling = true;
            clearTimeout(window.scrollEndTimer);
            window.scrollEndTimer = setTimeout(callbackScrollEnd, 200);
        });
        */
        // ボタンによるページジャンプ
        const elementsNavButton = document.querySelectorAll('#axp_config_div_navButton button');
        const elementsSection = document.querySelectorAll('.axpc_config_section');
        for (let i = 0; i < elementsNavButton.length; i++) {
            elementsNavButton[i].addEventListener('click', (e) => {
                // 要素の位置までスクロール
                if (this.axpObj.browser === 'Safari') {
                    // safariの場合、スムーススクロールにしないと表示バグ
                    elementsSection[i].scrollIntoView({ behavior: "smooth" });
                } else {
                    elementsSection[i].scrollIntoView();
                    // firefoxの場合連動にずれが生じるため、押されたボタンにaxpc_ACTIVE強制設定
                    activateButton(e.target);
                }
            });
        }

        // ユーザーが設定を変更したとき、変更内容をコンフィグオブジェクトへ保存する
        // classに'axpc_SAVE'を指定されている要素を対象とする
        const elems_config = document.getElementsByClassName('axpc_SAVE');
        for (const item of elems_config) {
            // 値が変更されると呼び出される関数を登録する
            item.addEventListener('change', (e) => {
                //console.log('操作された要素', e.target.id, e.target.type);
                //console.log('登録する要素', e.currentTarget.id);

                // コンフィグオブジェクトの更新
                switch (e.target.type) {
                    case 'range':
                        // レンジスライダー
                        this.saveConfig(`RANGE_${e.currentTarget.id}`, e.target.value);
                        break;
                    case 'checkbox':
                        // チェックボックス
                        this.saveConfig(`CHECK_${e.currentTarget.id}`, e.target.checked);
                        break;
                    case 'radio':
                        // ラジオボックス
                        this.saveConfig(`RADIO_${e.currentTarget.id}`, e.target.value);
                        break;
                    case 'number': {
                        // 数値入力
                        // 共通処理
                        let value = Number(e.target.value);
                        // 数値以外(空白や指数表現eなど)が入力されていたら、最小値に置き換え
                        if (isNaN(value)) {
                            value = e.target.min;
                        }
                        // 既定の範囲内から外れる場合、範囲内に補正
                        value =
                            (0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.adjustInRange)(
                                Number(value),
                                e.target.min,
                                e.target.max
                            );
                        // 要素の値を補正後の値に更新
                        e.target.value = value;
                        this.saveConfig(`VALUE_${e.target.id}`, value);
                        break;
                    }
                }
            })
        };

        // ◆キャンバス ----------------------------------------------------------------

        document.getElementById('axp_config_span_canvasSizeLimit').textContent =
            `(※最小${this.axpObj.minWidth}×${this.axpObj.minHeight} ～ 最大${this.axpObj.maxWidth}×${this.axpObj.maxHeight})`;

        const inputWidth = document.getElementById('axp_config_number_oekakiWidth');
        inputWidth.min = this.axpObj.minWidth;
        inputWidth.max = this.axpObj.maxWidth;
        inputWidth.value = this.axpObj.x_size;

        const inputHeight = document.getElementById('axp_config_number_oekakiHeight');
        inputHeight.min = this.axpObj.minHeight;
        inputHeight.max = this.axpObj.maxHeight;
        inputHeight.value = this.axpObj.y_size;

        // テキストボックス：お絵カキコのサイズ数値変更
        inputWidth.onchange = () => {
            // キャンバスサイズの範囲チェック
            inputWidth.value = this.axpObj.checkCanvasSize_x(inputWidth.value);
        }
        inputHeight.onchange = () => {
            // キャンバスサイズの範囲チェック
            inputHeight.value = this.axpObj.checkCanvasSize_y(inputHeight.value);
        }
        // ボタン：新規キャンバス
        document.getElementById('axp_config_button_newCanvas').onclick = () => {
            // キャンバスサイズの範囲チェック
            let x = inputWidth.value = this.axpObj.checkCanvasSize_x(inputWidth.value);
            let y = inputHeight.value = this.axpObj.checkCanvasSize_y(inputHeight.value);

            // 確認ダイアログ表示
            (0,_alert_js__WEBPACK_IMPORTED_MODULE_0__.confirmExPromise)(`現在の描画内容を破棄して新規キャンバス（${x}×${y}）を作成します。\nよろしいですか？\n（※この処理はアンドゥできません）`)
                .then(() => {
                    // ※OK時の処理
                    // タブをキャンバスに変更
                    this.axpObj.selectTab('0');
                    // キャンバス初期化
                    this.axpObj.setCanvasSize(x, y);
                    this.axpObj.resetCanvas();
                    // 初期レイヤー作成
                    this.axpObj.layerSystem.newLayer();
                    // 表示更新
                    this.axpObj.layerSystem.updateCanvas();

                    // キャンバスサイズ履歴への追加と表示更新
                    this.addCanvasSizeHistory(x, y);
                    this.updateCanvasSizeHistory();

                    // 「基にしてお絵カキコ」情報のリセット
                    this.axpObj.oekaki_id = null;
                    this.axpObj.draftImageFile = null;
                    this.axpObj.oekaki_bbs_pageno = null;
                    this.axpObj.oekaki_bbs_title = null;

                    alert(`新規キャンバスを作成しました。横:${x} 縦:${y}`);
                })
                .catch(() => {
                    // ※Cancel時の処理
                    // 処理なし
                });
        }
        // ボタン：お絵カキコのサイズ変更
        document.getElementById('axp_config_button_changeCanvasSize').onpointerdown = () => {

            // 起動オプションで、下書き機能使用時のキャンバスサイズの変更が制限されている場合
            if (this.axpObj.restrictDraftCanvasResizing) {
                if (this.axpObj.oekaki_id !== null || this.axpObj.draftImageFile !== null) {
                    alert('下書き機能を利用したキャンバスは、サイズの変更ができません。');
                    return;
                }
            }

            // キャンバスサイズの範囲チェック
            let x = inputWidth.value = this.axpObj.checkCanvasSize_x(inputWidth.value);
            let y = inputHeight.value = this.axpObj.checkCanvasSize_y(inputHeight.value);

            // 確認ダイアログ表示
            (0,_alert_js__WEBPACK_IMPORTED_MODULE_0__.confirmExPromise)(`キャンバスサイズを${x}×${y}に変更します。\nよろしいですか？\n（※この処理はアンドゥできません）`)
                .then(() => {
                    // ※OK時の処理
                    // タブをキャンバスに変更
                    this.axpObj.selectTab('0');
                    // レイヤーオブジェクトをコピーして一時保存
                    let obj = this.axpObj.layerSystem.layerObj;
                    var copy_layerOBJ = obj.map(obj => ({ ...obj }));

                    // キャンバスサイズ設定
                    this.axpObj.setCanvasSize(x, y);

                    // レイヤーオブジェクトのimagedataサイズを新しいサイズに変更する（全レイヤー分繰り返す）
                    const newCanvas = document.createElement('canvas');
                    newCanvas.width = x;
                    newCanvas.height = y;
                    const newCanvas_ctx = newCanvas.getContext('2d', { willReadFrequently: true });

                    for (let item of copy_layerOBJ) {
                        newCanvas_ctx.clearRect(0, 0, x, y);
                        newCanvas_ctx.putImageData(item.image, 0, 0);
                        item.image = newCanvas_ctx.getImageData(0, 0, x, y);
                    }

                    var data = {
                        version: this.axpObj.saveSystem.CONST.DATA_VERSION,
                        id: null,
                        created: null,
                        src: null,
                        x_max: x,
                        y_max: y,
                        counter: this.axpObj.layerSystem.layer_counter,
                        layer: copy_layerOBJ,
                        transparent: this.axpObj.assistToolSystem.getIsTransparent(),
                    }
                    // 復元処理
                    this.axpObj.saveSystem.restoreData(data);

                    copy_layerOBJ = null;
                    data = null;

                    // キャンバスサイズ履歴への追加と表示更新
                    this.addCanvasSizeHistory(x, y);
                    this.updateCanvasSizeHistory();

                    alert(`キャンバスサイズを変更しました。横:${x} 縦:${y}`);
                })
                .catch(() => {
                    // ※Cancel時の処理
                    // 処理なし
                });
        }
        // ラジオボタン：キャンバスぼかし
        document.getElementById('axp_config_form_antialiasing').onchange = () => {
            this.set_canvas_antialiasing();
        }
        // 画像をダウンロード
        document.getElementById('axp_config_button_pngDownload').onmousedown = () => {
            this.axpObj.TASK['func_download']();
        }

        // ラジオボタン：ポインタ座標表示
        document.getElementById('axp_config_form_displayPosition').onchange = () => {
            this.set_display_position();
        }

        // ◆ツールウィンドウ ----------------------------------------------------------------
        // ウィンドウ位置リセット
        document.getElementById('axp_config_button_resetWindow').addEventListener('click', () => {
            this.axpObj.dragWindow.resetPosition();
            alert('全ウィンドウ位置を初期化しました。');
        })

        // ツールウィンドウ位置の自動調整
        document.getElementById('axp_config_form_windowAutoAdjust').onchange = () => {
            // 全ツールウィンドウのcss（left,top）を更新
            this.axpObj.dragWindow.changeAutoAdjustPosition();
        };
        // アイコンサイズ
        document.getElementById('axp_config_form_minimizeButtonType').onchange = (e) => {
            this.axpObj.launcher.setButtonSize(e.target.value);
        };
        // 単一ウィンドウモード
        document.getElementById('axp_config_checkbox_singleWindowMode').onchange = (e) => {
            this.axpObj.launcher.setSingleWindowMode(e.target.checked);
        };

        // ◆ペンツール ----------------------------------------------------------------
        // ラジオボタン：トーン濃度レンジスライダー
        document.getElementById('axp_config_form_ToneLevel').onchange = () => {
            this.axpObj.penSystem.changePenMode();
        }
        // ラジオボタン：ぼかし度レンジスライダー
        document.getElementById('axp_config_form_blurLevel').onchange = () => {
            this.axpObj.penSystem.changePenMode();
        }
        // ラジオボタン：不透明度と太さの表示順序
        document.getElementById('axp_config_form_pentoolRangeOrder').onchange = () => {
            this.axpObj.penSystem.changeOrderSlider();
        }
        // チェックボックス：手ぶれ補正 ペンツールウィンドウ内で変更可能にする
        document.getElementById('axp_config_checkbox_stabilize').onchange = () => {
            this.axpObj.penSystem.changePenMode();
        }
        // レンジスライダー：手ぶれ補正 連動
        // 設定タブ側
        document.getElementById('axp_config_form_stabilizerValue').onchange = (e) => {
            document.getElementById('axp_pen_form_stabilizer').volume.value = e.target.value;
            document.getElementById('axp_pen_form_stabilizer').result.value = e.target.value;
        }
        // ペンツール側
        document.getElementById('axp_pen_form_stabilizer').onchange = (e) => {
            document.getElementById('axp_config_form_stabilizerValue').volume.value = e.target.value;
            document.getElementById('axp_config_form_stabilizerValue').result.value = e.target.value;
            this.saveConfig('RANGE_axp_config_form_stabilizerValue', e.target.value);
        }

        // ラジオボタン：長押しスポイト
        document.getElementById('axp_config_form_useLongtap').onchange = () => {
            this.set_longtap_use();
        }
        // 初回リセット用
        this.set_longtap_use();

        // ◆色作成ツール ----------------------------------------------------------------
        // 使用する色作成ツール
        document.getElementById('axp_config_form_makeColorTypeRGB').addEventListener('change', () => {
            this.axpObj.colorMakerSystem.updateMakeColorType();
        });
        document.getElementById('axp_config_form_makeColorTypePicker').addEventListener('change', () => {
            this.axpObj.colorMakerSystem.updateMakeColorType();
        });
        document.getElementById('axp_config_form_makeColorTypeMixed').addEventListener('change', () => {
            this.axpObj.colorMakerSystem.updateMakeColorType();
        });
        // ◆カラーパレット ----------------------------------------------------------------

        // カラーパレットの列数
        document.getElementById('axp_config_form_paletteColumnValue').addEventListener('input', (e) => {
            this.axpObj.colorPaletteSystem.setPaletteColumn(e.target.value);
        });

        // カラーパレットのファイル保存
        document.getElementById('axp_config_button_saveColor').onclick = () => {
            // カラーパレットのテキストデータを生成
            let colortext = new Array();
            // 列数
            colortext.push(
                'column,' + this.axpObj.colorPaletteSystem.currentPalette.column + '\n');
            // パレット配列の中身（#付きカラーコード）を１色ずつテキストに書き出す
            for (const color of this.axpObj.colorPaletteSystem.currentPalette.palette) {
                colortext.push(color + '\n');
            }
            var filename = "ap_color" + (0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.dispDate)(new Date(), 'YYYYMMDD_hhmmss') + ".txt"
            var blob = new Blob(colortext, { type: 'text/plain' });
            var link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }
        // カラーパレットのファイル読込
        document.getElementById('axp_config_button_loadColor').onclick = () => {
            // ファイルオープンダイアログを開く
            document.getElementById('axp_config_file_loadColor').click();
        }
        // ダイアログオープン時
        document.getElementById('axp_config_file_loadColor').onclick = (e) => {
            // ２度同じファイルを選択したとき、onchangeが発火しない不具合を回避するため値を初期化する
            e.target.value = '';
        }
        //ダイアログでファイルが選択された時
        document.getElementById('axp_config_file_loadColor').onchange = (e) => {
            var file = e.target.files;
            // ファイルが選択されていない場合（キャンセル）
            if (file.length === 0) return;

            //FileReaderの作成
            var reader = new FileReader();
            //テキスト形式で読み込む
            reader.readAsText(file[0]);

            //読込終了後の処理
            reader.onload = () => {
                // 読み込んだテキストを配列に分割
                var arr = reader.result.split(/\r\n|\n/);
                var loopend = arr.length - 1;
                if (loopend === 0) {
                    // データなし
                    alert("有効なデータファイルではありません。");
                    return;
                }
                let newPalette = {
                    column: 5,
                    palette: [],
                }

                for (var i = 0; i < loopend; i++) {
                    let data = arr[i];

                    // 列データの場合
                    if (data.substr(0, 6) === 'column') {
                        let column = data.split(',')[1];
                        if (isNaN(column) ||
                            !(0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.inRange)(Number(column), 0, this.axpObj.colorPaletteSystem.CONST.COLOR_MAX)) {
                            alert("columnが不正な値のため、読込を中止しました。\n行数:" + (i + 1) + " 内容:" + data);
                            return;
                        }
                        console.log('column:', column);
                        newPalette.column = Number(column);
                        continue;

                    }
                    // 横ボタンデータの場合スキップ（廃止項目）
                    if (data.substr(0, 4) === 'side') {
                        continue;
                    }
                    // 最大パレット数を超えるデータは無視する
                    if (newPalette.palette.length >= this.axpObj.colorPaletteSystem.CONST.COLOR_MAX) break;
                    let code = data;
                    //if (code.slice(0, 1) == "#") code = code.slice(1); //先頭の#を外す
                    if ((0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.isColor)(code)) {
                        // 正常なカラーコードであれば、パレットオブジェクトに格納
                        newPalette.palette.push(code);
                    } else {
                        alert("カラーコードに誤りがあるため、読込を中止しました。\n行数:" + (i + 1) + " 内容:" + data);
                        return;
                    }
                }

                if (newPalette.palette.length === 0) {
                    // 有効な色データなし
                    alert("パレットデータが１色もありません。");
                    return;
                }

                // 処理正常
                // カラーパレットデータ更新
                this.axpObj.colorPaletteSystem.setPaletteArray(newPalette.palette);
                this.axpObj.colorPaletteSystem.currentPalette.column = newPalette.column;
                // カラーパレット生成
                this.axpObj.colorPaletteSystem.createPalette();
                // 設定用カラーパレット表示更新
                this.dispPalettebox(document.getElementById('axp_config_div_paletteBox'), newPalette);
                // DBへ保存
                this.axpObj.saveSystem.save_palette(newPalette.palette);
                this.axpObj.configSystem.saveConfig('PLTCO', newPalette.column);
                alert("カラーパレットを正常に読み込みました。\nパレット数:" + newPalette.palette.length);
            }
        }
        // カラーパレットの初期化
        document.getElementById('axp_config_button_resetColor').onclick = () => {
            // 確認ダイアログ表示
            ;(0,_alert_js__WEBPACK_IMPORTED_MODULE_0__.confirmExPromise)(`カラーパレットを初期状態に戻します。\nよろしいですか？\n（※この処理はアンドゥできません）`)
                .then(() => {
                    // ※OK時の処理
                    // カラーパレットデータ更新
                    this.axpObj.colorPaletteSystem.setPaletteArray();
                    // カラーパレット更新
                    this.axpObj.colorPaletteSystem.createPalette();
                    // 設定用カラーパレット表示更新
                    this.dispPalettebox(document.getElementById('axp_config_div_paletteBox'), this.axpObj.colorPaletteSystem.currentPalette);
                    // DBへ保存
                    this.axpObj.saveSystem.save_palette(this.axpObj.colorPaletteSystem.currentPalette.palette);
                    this.axpObj.configSystem.saveConfig('PLTCO', this.axpObj.colorPaletteSystem.currentPalette.column);
                    alert("カラーパレットを初期化しました。");
                })
                .catch(() => {
                    // ※Cancel時の処理
                    // 処理なし
                });
        }

        // ◆レイヤー ----------------------------------------------------------------
        // 合成モードの表示
        document.getElementById('axp_config_form_blendModeDisplayType').onchange = () => {
            this.axpObj.layerSystem.updateBlendModeDisplayAll();
        }
        // カラータグ名の初期化
        document.getElementById('axp_config_button_resetColorTag').onclick = () => {
            // 確認ダイアログ表示
            ;(0,_alert_js__WEBPACK_IMPORTED_MODULE_0__.confirmExPromise)(`カラータグ名を初期状態に戻します。\nよろしいですか？\n（※この処理はアンドゥできません）`)
                .then(() => {
                    // ※OK時の処理
                    // カラータグリスト初期化
                    this.axpObj.layerSystem.resetColorTagList();
                    // レイヤー名変更サブウィンドウのボタン表示、設定タブのテキストに反映
                    this.axpObj.layerSystem.updateAllColorTag();
                    // コンフィグ保存
                    this.axpObj.configSystem.deleteConfig('COTAG');
                    alert('カラータグ名を初期化しました。');
                })
                .catch(() => {
                    // ※Cancel時の処理
                    // 処理なし
                });
        }

        // ◆補助ツール ----------------------------------------------------------------
        // 拡大率テーブル変更
        const setCurrentScaleTable = () => {
            const elements_li = document.querySelectorAll('#axp_config_ul_scale>li');
            this.axpObj.currentScaleTable = [];
            for (const item of elements_li) {
                this.axpObj.currentScaleTable.push(Number(item.dataset.value));
            }
            // キーカスタマイズ連動
            this.updateKeyCustomizationScaleTable(this.axpObj.currentScaleTable);
        }
        // 拡大率追加
        document.getElementById('axp_config_button_addScale').addEventListener('click', () => {
            const inputValue = Number(document.getElementById('axp_config_number_scale').value);
            const min = this.axpObj.CONST.SCALE_MIN;
            const max = this.axpObj.CONST.SCALE_MAX;
            const tableMax = this.axpObj.CONST.SCALE_TABLE_MAX;
            if ((0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.inRange)(inputValue, min, max)) {
                // 挿入位置をサーチ
                const elements_li = document.querySelectorAll('#axp_config_ul_scale>li');
                if (elements_li.length >= tableMax) {
                    this.axpObj.msg('@CAU0100', tableMax);
                    return;
                }
                let index = -1;
                for (let idx = 0; idx < elements_li.length; idx++) {
                    if (inputValue === Number(elements_li[idx].dataset.value)) {
                        index = -999;
                        break;
                    }
                    if (inputValue < Number(elements_li[idx].dataset.value)) {
                        index = idx;
                        break;
                    }
                }

                if (index === -999) {
                    // 拡大率%1%は既に追加されています。
                    this.axpObj.msg('@CAU0101', inputValue);
                } else {
                    // 要素追加
                    const element = document.getElementById('axp_config_ul_scale');
                    const list = document.createElement('li');
                    list.dataset.value = String(inputValue);
                    list.textContent = `${inputValue}%`;
                    if (index === -1) {
                        // 集合の中で最も大きい値の場合、最後尾
                        element.appendChild(this.createHTMLListScale(inputValue));
                    } else {
                        // 集合の間に挿入
                        element.insertBefore(
                            this.createHTMLListScale(inputValue),
                            elements_li[index]
                        );
                    }
                    // 拡大率テーブル更新
                    setCurrentScaleTable();
                    // コンフィグ保存
                    this.saveConfig('SCALE', this.axpObj.currentScaleTable);
                    // 拡大率%1%を追加しました。
                    this.axpObj.msg('@INF0100', inputValue);
                }
            } else {
                // 追加できる拡大率は%1～%2%です。
                this.axpObj.msg('@CAU0102', min, max);
            }
        });
        // 拡大率削除
        document.getElementById('axp_config_button_deleteScale').addEventListener('click', () => {
            const elements_li = document.querySelectorAll('#axp_config_ul_scale>li');
            let target = null;
            for (const item of elements_li) {
                if (item.dataset.selected === 'true') {
                    target = item;
                    break;
                }
            }
            if (target) {
                if (target.dataset.value === '100') {
                    // ※拡大率100%は選択できないので、正常ケースでは実行されない
                } else {
                    // 要素の削除
                    target.remove();
                    // 拡大率テーブル更新
                    setCurrentScaleTable();
                    // コンフィグ保存
                    this.saveConfig('SCALE', this.axpObj.currentScaleTable);
                    // 拡大率%1%を削除しました。
                    this.axpObj.msg('@INF0101', target.dataset.value);
                }
            } else {
                // 削除する拡大率が選択されていません。
                this.axpObj.msg('@CAU0103');
            }
        });
        // 拡大率初期化
        document.getElementById('axp_config_button_resetScale').addEventListener('click', () => {
            // 確認ダイアログ表示
            (0,_alert_js__WEBPACK_IMPORTED_MODULE_0__.confirmExPromise)('拡大率の設定を初期状態に戻します。\nよろしいですか？')
                .then(() => {
                    // ※OK時の処理
                    // テーブル初期化
                    this.axpObj.currentScaleTable = this.axpObj.CONST.SCALE_VALUE;
                    // 設定画面表示用テーブルの作成
                    this.createConfigScaleTable(this.axpObj.currentScaleTable);
                    // キーカスタマイズセレクトボックス連動
                    this.updateKeyCustomizationScaleTable(this.axpObj.currentScaleTable);
                    // コンフィグ保存
                    this.saveConfig('SCALE', this.axpObj.currentScaleTable);
                    alert('拡大率の設定を初期化しました。');
                })
                .catch(() => {
                    // ※Cancel時の処理
                    // 処理なし
                });
        });

        // ◆カスタムボタン --------------------------------------------------------------
        // カスタムボタンの使用の変更
        document.getElementById('axp_config_form_useCustomButton').onchange = () => {
            this.axpObj.dispCustomButton();
        }

        // ◆マウス ----------------------------------------------------------------

        // ◆キーボード ----------------------------------------------------------------

        // 割り当て無しのキーを非表示にする
        document.getElementById('axp_config_checkbox_shortcutKeyHiddenNofunc').addEventListener('change', () => {
            this.switchNofuncKeytable();
        });
        // ショートカットのファイル保存
        document.getElementById('axp_config_button_saveShortcut').addEventListener('click', () => {
            // セーブテキスト
            const saveText = new Array();
            saveText.push('// @name\tAXNOSPaintSHORTCUT\n');
            saveText.push(`// @version\t${"2.4.0"}\n`);
            // キーコンフィグ要素の取得
            const elementsTr = document.querySelectorAll('.axpc_config_custom_key');
            for (const tr of elementsTr) {
                let text = tr.id.slice('axp_config_custom_key'.length) + ':' + this.getSaveCustomText(tr.id);
                saveText.push(text + '\n');
            }
            const filename = "ap_shortcut" + (0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.dispDate)(new Date(), 'YYYYMMDD_hhmmss') + ".txt"
            const blob = new Blob(saveText, { type: 'text/plain' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        });
        // カラーパレットのファイル読込
        document.getElementById('axp_config_button_loadShortcut').onclick = () => {
            // ２度同じファイルを選択したとき、onchangeが発火しない不具合を回避するため値を初期化する
            document.getElementById('axp_config_file_loadShortcut').value = '';
            // ファイルオープンダイアログを開く
            document.getElementById('axp_config_file_loadShortcut').click();
        }
        //ダイアログでファイルが選択された時
        document.getElementById('axp_config_file_loadShortcut').onchange = (e) => {
            const file = e.target.files;
            // ファイルが選択されていない場合（キャンセル）
            if (file.length === 0) return;
            //FileReaderの作成
            const reader = new FileReader();
            //テキスト形式で読み込む
            reader.readAsText(file[0]);

            //読込終了後の処理
            reader.onload = () => {
                // 読み込んだテキストを配列に分割
                const arr = reader.result.split(/\r\n|\n/);
                const loopend = arr.length - 1;
                let isErrorFile = false;
                if (loopend === 0) {
                    isErrorFile = true;
                } else {
                    const dataname = arr[0].split(/\t/)[1];
                    if (dataname !== 'AXNOSPaintSHORTCUT') {
                        isErrorFile = true;
                    }
                }
                if (isErrorFile) {
                    alert('AXNOS Paintのショートカットファイルではありません。');
                    return;
                }

                // ヘッダを読み飛ばし、３行目から１行ずつ処理
                for (let i = 2; i < loopend; i++) {
                    const data = arr[i].split(':');
                    const elememtId = 'axp_config_custom_key' + data[0];
                    const key = 'CFUNC_' + elememtId;
                    const value = data[1];
                    if (document.getElementById(elememtId)) {
                        // 親セレクトボックス要素を取得
                        const elemSelectParent = document.querySelector(`#${elememtId} select:nth-of-type(1)`);
                        // valueの値を分解
                        let valueAry = value.split(',');
                        // 親セレクトボックスを、コンフィグ値の機能種別に変更
                        const found = this.optionlist.find(e => e.value === valueAry[0]);
                        if (typeof found === 'undefined') {
                            // 対応機能が廃止などの理由で見つからなかった場合、機能なしを強制設定
                            elemSelectParent.value = 'none';
                        } else {
                            // 対応機能を選択
                            elemSelectParent.value = valueAry[0];
                        }
                        // サブオプションの生成と設定
                        if (valueAry.length > 1) {
                            // 値指定あり
                            this.selectCustom(elememtId, valueAry[1]);
                        } else {
                            // 値指定なし
                            this.selectCustom(elememtId, null);
                        }
                    } else {
                        alert("ショートカットファイルの内容に誤りがあるため、読込を中止しました。\n行数:" + (i + 1) + " 内容:" + arr[i]);
                        return;
                    }
                    this.configObj.set(key, value);
                }
                // コンフィグオブジェクトをDBに保存
                this.saveConfig();
                this.switchNofuncKeytable();
                this.updateShortcutMessage();
                alert('ショートカットファイルを正常に読み込みました。');
            }
        }
        // ショートカットの初期化
        document.getElementById('axp_config_button_resetShortcut').onclick = () => {
            // 確認ダイアログ表示
            ;(0,_alert_js__WEBPACK_IMPORTED_MODULE_0__.confirmExPromise)(`ショートカットを初期状態に戻します。\nよろしいですか？\n（※この処理はアンドゥできません）`)
                .then(() => {
                    // キーコンフィグ要素の初期化
                    for (let i = 0; i < objKeyFunction.length; i++) {
                        const id = `axp_config_custom_key${objKeyFunction[i][1]}`;
                        const key = `CFUNC_${id}`;
                        const value = objKeyFunction[i][2];
                        const selectMain = document.querySelector(`#${id} select:nth-of-type(1)`);
                        selectMain.value = value;
                        this.selectCustom(id);
                        this.configObj.delete(key);
                    }
                    // コンフィグオブジェクトをDBに保存
                    this.saveConfig();
                    this.switchNofuncKeytable();
                    this.updateShortcutMessage();
                    alert('ショートカットを初期化しました。');
                })
                .catch(() => {
                    console.log('NG');
                    // ※Cancel時の処理
                    // 処理なし
                });
        }
        // デバッグ情報表示チェックボックス
        document.getElementById('axp_config_checkbox_useDebugMode').onchange = (e) => {
            this.axpObj.debugLog.isDebugMode = e.target.checked;
        }
    }

    // キーコンフィグ用メソッド --------------------------------------------------------
    // キーコンフィグのDB保存用textを取得する
    getSaveCustomText(id) {
        let result;
        // 要素の取得
        const elem = document.getElementById(id);
        const selectMain = elem.querySelector('select:nth-of-type(1)');
        const inputSizeValue = elem.querySelector('.axpc_config_number_sizeValue');
        const inputScaleValue = elem.querySelector('.axpc_config_number_scaleValue');
        // コンフィグオブジェクトの更新
        switch (selectMain.value) {
            case 'func_loupe':
                // 拡大率
                inputScaleValue.value =
                    (0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.adjustInRange)(
                        Number(inputScaleValue.value),
                        Number(inputScaleValue.min),
                        Number(inputScaleValue.max)
                    );
                // 機能種別＋選択中の拡大率indexを加えて保存
                result = selectMain.value + ',' + inputScaleValue.value;
                break;
            case 'func_size':
                // ペンの太さ
                // 数値範囲丸め
                inputSizeValue.value =
                    (0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.adjustInRange)(
                        Number(inputSizeValue.value),
                        Number(inputSizeValue.min),
                        Number(inputSizeValue.max)
                    );
                // 機能種別＋ペンの太さの数字を加えて保存
                result = selectMain.value + ',' + inputSizeValue.value;
                break;
            default:
                // その他
                // 機能種別のみを保存
                result = selectMain.value;
        }
        return result;
    }
    // キーコンフィグが変更されたとき、変更内容に応じたコンフィグ設定のDB保存を行う
    saveCustom(id) {
        this.saveConfig(`CFUNC_${id}`, this.getSaveCustomText(id));
    }
    // 選択（changeイベント、設定復元時に呼び出し）
    // 指定された値(setvalue)を設定する
    // setvalue=null（初期化の場合）、初期値を設定する
    selectCustom(id, setValue = null) {
        // 要素の取得
        const elem = document.getElementById(id);
        const selectMain = elem.querySelector('select:nth-of-type(1)');
        const selectScale = elem.querySelector('.axpc_config_select_scaleTable');
        const inputSizeValue = elem.querySelector('.axpc_config_number_sizeValue');
        const inputScaleValue = elem.querySelector('.axpc_config_number_scaleValue');
        //console.log(id, selectMain.value, setValue);
        // 選択された機能セレクトボックスのオプションに応じて、必要な処理を行う
        switch (selectMain.value) {
            // 拡大率
            case 'func_loupe':
                // 初期値未選択
                selectScale.selectedIndex = -1;
                if (setValue !== null) {
                    inputScaleValue.value = setValue;
                } else {
                    // 初期値100%
                    inputScaleValue.value = 100;
                }
                // 各要素の表示設定
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.show(selectScale);
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.hide(inputSizeValue);
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.show(inputScaleValue);
                break;

            // ペンの太さ
            case 'func_size':
                if (setValue !== null) {
                    inputSizeValue.value = setValue;
                } else {
                    // 初期値1
                    inputSizeValue.value = 1;
                }
                // 各要素の表示設定
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.hide(selectScale);
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.show(inputSizeValue);
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.hide(inputScaleValue);
                break;
            default:
                // 各要素の表示設定
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.hide(selectScale);
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.hide(inputSizeValue);
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.hide(inputScaleValue);
        }

        // カスタムボタンの場合、ボタンの表示オン／オフ切り替え
        if (elem.dataset.linkIndex) {
            // index番目のボタン要素を取得
            const elementButton = document.querySelector(`#axp_custom_div_buttons>button:nth-of-type(${elem.dataset.linkIndex})`);
            if (selectMain.value === 'none') {
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.hide(elementButton);
            } else {
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.show(elementButton);
            }
            const found = this.optionlist.find(e => e.value === selectMain.value);
            elementButton.dataset.msg = `カスタムボタン：[ ${found.name} ]`;
        }
    };
    // 機能なしを非表示
    switchNofuncKeytable() {
        const checked = document.getElementById('axp_config_checkbox_shortcutKeyHiddenNofunc').checked;
        const elementTable = document.getElementById('axp_config_table_shortcutKey');
        const elementsTr = elementTable.querySelectorAll('.axpc_config_custom_key');
        for (const tr of elementsTr) {
            const elementSelectbox = tr.querySelector('select');
            if (checked && elementSelectbox.value === 'none') {
                tr.classList.add('axpc_NONE');
            } else {
                tr.classList.remove('axpc_NONE');
            }
        }
    }
    // ガイドメッセージに表示するショートカット表示用データの更新
    updateShortcutMessage() {
        // 機能に対応するショートカットキーのMAPを作成
        mapFunction.clear();
        const elementsTr = document.querySelectorAll('.axpc_config_custom_key');
        for (const tr of elementsTr) {
            const selectMain = tr.querySelector('select:nth-of-type(1)');
            if (!mapFunction.has(selectMain.value)) {
                mapFunction.set(selectMain.value, tr.querySelector('td').textContent);
            }
        }
        // ショートカット表示用データの更新
        const messagesFunction = document.querySelectorAll('.axpc_FUNC');
        for (const item of messagesFunction) {
            if (mapFunction.has(item.dataset.function)) {
                item.dataset.key = mapFunction.get(item.dataset.function);
            } else {
                item.dataset.key = '';
            }
        }
    }
    // 指定した機能IDのショートカットを取得
    getShortcutFunction(func_id) {
        let result = null;
        if (mapFunction.has(func_id)) {
            result = mapFunction.get(func_id);
        }
        return result;
    }
    createKeyConfigHTML(id, keybind) {
        const name = keybind[0];
        const idx = keybind[1];
        const func = keybind[2];

        const tr = document.createElement('tr');
        tr.setAttribute('id', `axp_config_custom_${id}${idx}`);
        // キーボードショートカット用class
        if (id === 'key') {
            tr.setAttribute('class', 'axpc_config_custom_key');
        }

        // キーの名前
        const td_name = document.createElement('td');
        td_name.textContent = `[ ${name} ]`;

        // 機能セレクトボックス
        const td_func = document.createElement('td');

        const selectMain = document.createElement('select');
        selectMain.setAttribute('id', `axp_config_select_main_${id}${idx}`);
        let isGroup = false;
        let optgroup = null;
        // 機能セレクトボックスにoption要素を追加する
        for (const item of this.optionlist) {
            if (item.value === 'optgroup') {
                optgroup = document.createElement('optgroup');
                optgroup.setAttribute('label', item.name);
                isGroup = true;
            } else if (item.value === '/optgroup') {
                selectMain.appendChild(optgroup);
                isGroup = false;
            } else {
                // ペンの太さ調整はカスタムボタンでは使用不可とするため、登録をスキップする
                if (id === 'button' && item.value === 'func_size_change') {
                    continue;
                }
                const option = document.createElement('option');
                option.value = item.value;
                option.textContent = item.name;
                if (isGroup) {
                    optgroup.appendChild(option);
                } else {
                    selectMain.appendChild(option);
                }
            }
        }
        selectMain.value = func;

        // 機能セレクトボックスが変更された時
        selectMain.addEventListener('change', () => {
            this.selectCustom(tr.id);
            this.saveCustom(tr.id);
            this.updateShortcutMessage();
        })

        // 描画サイズテキストエリア
        const inputSizeValue = document.createElement('input');
        inputSizeValue.setAttribute('id', `axpc_config_number_sizeValue_${id}${idx}`);
        inputSizeValue.classList.add('axpc_config_number_sizeValue');
        inputSizeValue.setAttribute('type', 'number');
        inputSizeValue.setAttribute('maxlength', '3');
        inputSizeValue.setAttribute('min', '1');
        inputSizeValue.setAttribute('max', '200');
        inputSizeValue.setAttribute('size', '3');
        // 描画サイズテキストエリアが変更された時
        inputSizeValue.addEventListener('change', () => {
            this.saveCustom(tr.id);
        })

        // 拡大率テキストエリア
        const inputScaleValue = document.createElement('input');
        inputScaleValue.setAttribute('id', `axpc_config_number_scaleValue_${id}${idx}`);
        inputScaleValue.classList.add('axpc_config_number_scaleValue');
        inputScaleValue.setAttribute('type', 'number');
        inputScaleValue.setAttribute('maxlength', '4');
        inputScaleValue.setAttribute('min', '25');
        inputScaleValue.setAttribute('max', '1600');
        inputScaleValue.setAttribute('size', '4');
        // 拡大率テキストエリアが変更された時
        inputScaleValue.addEventListener('change', () => {
            this.saveCustom(tr.id);
        })

        // 拡大率セレクトボックス（この時点では中身のoptionは設定しない）
        const selectScale = document.createElement('select');
        selectScale.setAttribute('id', `axpc_config_select_scaleTable_${id}${idx}`);
        selectScale.classList.add('axpc_config_select_scaleTable');
        // 拡大率セレクトボックスが変更された時
        selectScale.addEventListener('change', (e) => {
            inputScaleValue.value = e.target.value;
            this.saveCustom(tr.id);
        })

        td_func.appendChild(selectMain);
        td_func.appendChild(inputSizeValue);
        td_func.appendChild(inputScaleValue);
        td_func.appendChild(selectScale);

        tr.appendChild(td_name);
        tr.appendChild(td_func);

        return tr;
    }

    // --------------------------------------------------------
    // キャンバスサイズ履歴の追加
    addCanvasSizeHistory(x, y) {
        let history = `${x},${y}`;
        // 既に同一のサイズが履歴に存在する場合、先頭へ移動するために、その履歴を削除
        for (let i = 0; i < this.configCanvasSizeHistory.length; i++) {
            if (this.configCanvasSizeHistory[i] == history) {
                this.configCanvasSizeHistory.splice(i, 1);

            }
        }
        // 配列の先頭に追加
        this.configCanvasSizeHistory.unshift(history);
        // 最大件数を超える場合、末尾１件削除
        if (this.configCanvasSizeHistory.length > this.CONST.CANVAS_SIZE_HISTORY_MAX) {
            this.configCanvasSizeHistory.pop();
        }
        // コンフィグ保存
        this.saveConfig('CHIST', this.configCanvasSizeHistory);
    }
    // キャンバスサイズ履歴の表示更新
    updateCanvasSizeHistory() {
        let element = document.getElementById('axp_config_ul_canvasSizeHistory');
        // 全クリア
        while (element.lastChild) {
            element.onclick = null;
            element.removeChild(element.lastChild);
        }
        // 履歴データからli要素を作成する
        for (const item of this.configCanvasSizeHistory) {
            element.appendChild(this.createHTMLListCanvasSizeHistory(item));
        }
    }
    // 拡大率テーブルの作成（HTML生成）
    createHTMLListCanvasSizeHistory(value) {
        const list = document.createElement('li');
        list.dataset.value = String(value);
        let sizeStrings = value.split(',');
        let x = sizeStrings[0];
        let y = sizeStrings[1];
        list.textContent = `${x} × ${y}`;
        list.onclick = (e) => {
            const elements_li = document.querySelectorAll('#axp_config_ul_canvasSizeHistory>li');
            for (const item of elements_li) {
                item.dataset.selected = '';
            }
            e.target.dataset.selected = 'true';

            const value = list.dataset.value;
            let sizeStrings = value.split(',');
            let x = sizeStrings[0];
            let y = sizeStrings[1];
            // テキストエリアにキャンバスサイズの値を復元
            document.getElementById('axp_config_number_oekakiWidth').value = Number(x);
            document.getElementById('axp_config_number_oekakiHeight').value = Number(y);
        }
        return list;
    }
    // キャンバスぼかし
    set_canvas_antialiasing() {
        if (this.axpObj.config('axp_config_form_antialiasing') === 'on') {
            // ぼかしあり
            this.axpObj.CANVAS.main.style.imageRendering = 'auto';
        } else {
            // ぼかしなし
            this.axpObj.CANVAS.main.style.imageRendering = 'pixelated';
        }
    }
    // 座標表示
    set_display_position() {
        const targetElement = document.getElementById('axp_canvas_div_pointerPosition');
        switch (this.axpObj.config('axp_config_form_displayPosition')) {
            case 'off':
                // 表示しない
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.hide(targetElement);
                break;
            case 'upperleft':
                // 左上
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.show(targetElement);
                targetElement.style.right = 'auto';
                targetElement.style.bottom = 'auto';
                break;
            case 'lowerleft':
                // 左下
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.show(targetElement);
                targetElement.style.right = 'auto';
                targetElement.style.bottom = '0';
                break;
            case 'upperright':
                // 右上
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.show(targetElement);
                targetElement.style.right = '0';
                targetElement.style.bottom = 'auto';
                break;
            case 'lowerright':
                // 右下
                _etc_js__WEBPACK_IMPORTED_MODULE_1__.UTIL.show(targetElement);
                targetElement.style.right = '0';
                targetElement.style.bottom = '0';
                break;
        }
    }
    // 長押しスポイトのスライダ切り替え
    set_longtap_use() {
        if (this.axpObj.config('axp_config_form_useLongtap') === 'on') {
            // 補正の強さレンジスライダー有効
            document.getElementById('axp_config_form_longtapDurationValue').volume.disabled = false;
            document.getElementById('axp_config_form_longtapDurationValue').style.opacity = '1';
            document.getElementById('axp_config_form_longtapStabilizerValue').volume.disabled = false;
            document.getElementById('axp_config_form_longtapStabilizerValue').style.opacity = '1';
        } else {
            // 補正の強さレンジスライダー無効
            document.getElementById('axp_config_form_longtapDurationValue').volume.disabled = true;
            document.getElementById('axp_config_form_longtapDurationValue').style.opacity = '0.3';
            document.getElementById('axp_config_form_longtapStabilizerValue').volume.disabled = true;
            document.getElementById('axp_config_form_longtapStabilizerValue').style.opacity = '0.3';
        }
    }
    // ユーザー設定の保存
    saveConfig(key, value) {
        // key指定ありなら、コンフィグオブジェクトを更新（指定なしだとDBへの書き込みのみ行う）
        if (key !== undefined) {
            console.log('設定保存:', key, value);
            // Map更新
            this.configObj.set(key, value);
        }
        //console.log(this.configObj);
        // DBに保存
        this.axpObj.saveSystem.save_config(this.configObj);
    }
    // ユーザー設定から指定したkeyを削除
    deleteConfig(key) {
        this.configObj.delete(key);
        console.log('設定削除:', key);
        // DBに保存
        this.axpObj.saveSystem.save_config(this.configObj);
    }
    // ユーザー設定から指定したkeyに対応するvalueを返却
    getConfig(key) {
        return this.configObj.get(key);
    }
    // ユーザー設定の復元
    restoreConfig(map) {
        // 共通処理
        // ラジオボタン設定共通
        const setRadioValue = (id, value) => {
            //console.log('id', id);
            //console.log('value', value);
            let isFound = false;
            const elementsRadio = document.querySelectorAll(`#${id} input[type="radio"]`);
            for (const item of elementsRadio) {
                //console.log(item.value);
                // valueが一致しているコントロールを有効化する
                if (item.value === value) {
                    item.checked = true;
                    isFound = true;
                    break;
                }
            }
            return isFound;
        }
        // 先行処理用ラジオボタン設定共通
        const setRadio = (key) => {
            if (map.has(key)) {
                const value = map.get(key);
                const elememtId = key.substring(6);
                if (setRadioValue(elememtId, value)) {
                    // 後続の処理で二重処理しないためにmapから削除
                    map.delete(key);
                    // コンフィグオブジェクトに格納（有効なデータのみ残して引き継ぐ）
                    this.configObj.set(key, value);
                    //console.log('復元成功:', key, value);
                } else {
                    console.log('無効なconfig:', key, value);
                }
            } else {
                //console.log('存在せず:', key);
            }
        }
        // ペンツールの各種値設定共通
        const setPenValue = (dataType, elememtId, value) => {
            const pObj = this.axpObj.penSystem.penObj;
            let isFound = false;
            if (elememtId in pObj) {
                isFound = true;
                switch (dataType) {
                    // ペンの太さ
                    case 'P-SIZ':
                        pObj[elememtId].size = Number(value);
                        pObj[elememtId].index = (0,_pendefine_rangeindex_js__WEBPACK_IMPORTED_MODULE_3__.range_index)(Number(value));
                        break;
                    // ペンの不透明度
                    case 'P-ALP':
                        pObj[elememtId].alpha = Number(value);
                        break;
                    // 塗り残し補正
                    case 'P-THR':
                        pObj[elememtId].threshold = Number(value);
                        break;
                    // ぼかし
                    case 'P-BLU':
                        pObj[elememtId].blurLevel = Number(value);
                        break;
                    // トーン濃度
                    case 'P-TON':
                        pObj[elememtId].toneLevel = Number(value);
                        break;
                    // グラデーション角度
                    case 'P-DEG':
                        pObj[elememtId].gradation = Number(value);
                        break;
                    // 丸み
                    case 'P-RAD':
                        pObj[elememtId].radius = Number(value);
                        pObj[elememtId].borderRadius = Number(value);
                        break;
                }
            }
            return isFound;
        }

        // 先行して復元する必要がある項目
        setRadio('RADIO_axp_config_form_saveLastWindowPosition');
        setRadio('RADIO_axp_config_form_saveLastPenValue');

        // 連想配列から順番に値を取り出す
        map.forEach((value, key) => {
            //console.log('config_data:' + key, value);
            // 読み込んだデータの異常を検知した場合、falseにする
            let isAvailable = true;
            // 条件により読み込んだデータを使用せずスキップする場合、trueにする
            let isSkiped = false;
            // データタイプ
            const dataType = key.substring(0, 5);
            const elememtId = key.substring(6);
            switch (dataType) {
                // レンジスライダー（ペンツールを除く）
                case 'RANGE':
                    if (document.getElementById(elememtId)) {
                        document.getElementById(elememtId).volume.value = value;
                        document.getElementById(elememtId).result.value = value;
                    } else {
                        isAvailable = false;
                    }
                    break;
                // チェックボックス
                case 'CHECK':
                    if (document.getElementById(elememtId)) {
                        document.getElementById(elememtId).checked = value;
                    } else {
                        isAvailable = false;
                    }
                    break;
                // ラジオボタン
                case 'RADIO':
                    if (!setRadioValue(elememtId, value)) {
                        // 設定失敗時
                        isAvailable = false;
                    }
                    break;
                // トグルスイッチ
                case 'TOGSW':
                    if (document.getElementById(elememtId)) {
                        document.getElementById(elememtId).querySelector('input').checked = value;
                    } else {
                        isAvailable = false;
                    }
                    break;
                // テキストボックスなど（valueの単純代入で処理できるもの）
                case 'VALUE':
                    if (document.getElementById(elememtId)) {
                        document.getElementById(elememtId).value = value;
                    } else {
                        isAvailable = false;
                    }
                    break;
                // 補助線カラーコード
                case 'GRIDC':
                    if (document.getElementById(elememtId)) {
                        document.getElementById(elememtId).dataset.colorcode = value;
                        document.getElementById(elememtId).style.backgroundColor = value.substring(0, 7);
                    } else {
                        isAvailable = false;
                    }
                    break;
                // 拡大率テーブル
                case 'SCALE':
                    this.axpObj.currentScaleTable = value;
                    break;
                // キャンバスサイズ履歴
                case 'CHIST':
                    this.configCanvasSizeHistory = value;
                    // 表示更新
                    this.updateCanvasSizeHistory();
                    break;
                // ツールウィンドウ座標
                case 'WDPOS':
                    // 初期化する設定の場合、復元を行わない
                    if (this.axpObj.config('axp_config_form_saveLastWindowPosition') === 'off') {
                        // スキップしたことを記憶
                        isSkiped = true;
                    } else {
                        // 復元処理
                        // データ値を分割
                        const wdpos = value.split(',');
                        // wdpos[0]:left
                        // wdpos[1]:top
                        if (!this.axpObj.dragWindow.setInitPosition(elememtId, wdpos[0], wdpos[1])) {
                            // 座標の設定に失敗（無効なID）した場合、データを無効とする
                            isAvailable = false;
                        }
                    }
                    break
                // ツールウィンドウ最小化
                case 'WDMIN':
                    // 初期化する設定の場合、復元を行わない
                    if (this.axpObj.config('axp_config_form_saveLastWindowPosition') === 'off') {
                        // スキップしたことを記憶
                        isSkiped = true;
                    } else {
                        // 復元処理
                        if (!this.axpObj.dragWindow.restoreMinimize(elememtId)) {
                            // 最小化の設定に失敗（無効なID）した場合、データを無効とする
                            isAvailable = false;
                        }
                    }
                    break;
                // ペンツールの各種値
                case 'P-SIZ':
                case 'P-ALP':
                case 'P-THR':
                case 'P-BLU':
                case 'P-TON':
                case 'P-DEG':
                case 'P-RAD':
                    // 初期化する設定の場合、復元を行わない
                    if (this.axpObj.config('axp_config_form_saveLastPenValue') === 'off') {
                        // スキップしたことを記憶
                        isSkiped = true;
                    } else {
                        // 復元処理
                        if (!setPenValue(dataType, elememtId, value)) {
                            isAvailable = false;
                        }
                    }
                    break;
                // 機能割り当て
                case 'CFUNC':
                    if (document.getElementById(elememtId)) {
                        // 親セレクトボックス要素を取得
                        const elemSelectParent = document.querySelector(`#${elememtId} select:nth-of-type(1)`);
                        // valueの値を分解
                        let valueAry = value.split(',');
                        // 親セレクトボックスを、コンフィグ値の機能種別に変更
                        const found = this.optionlist.find(e => e.value === valueAry[0]);
                        if (typeof found === 'undefined') {
                            // 対応機能が廃止などの理由で見つからなかった場合、機能なしを強制設定
                            elemSelectParent.value = 'none';
                        } else {
                            // 対応機能を選択
                            elemSelectParent.value = valueAry[0];
                        }
                        // サブオプションの生成と設定
                        if (valueAry.length > 1) {
                            // 値指定あり
                            this.selectCustom(elememtId, valueAry[1]);
                        } else {
                            // 値指定なし
                            this.selectCustom(elememtId, null);
                        }
                    } else {
                        isAvailable = false;
                    }
                    break;
                // パレット列数
                case 'PLTCO':
                    // ※0:無制限
                    if (typeof value === 'number') {
                        this.axpObj.colorPaletteSystem.currentPalette.column = Number(value);
                    } else {
                        isAvailable = false;
                    }
                    break;
                // カラータグリスト
                case 'COTAG':
                    this.axpObj.layerSystem.resetColorTagList(value);
                    break;
                // その他
                default:
                    isAvailable = false;
            }
            // コンフィグオブジェクトに格納（有効なデータのみ残して引き継ぐ）
            if (isAvailable) {
                if (isSkiped) {
                    //console.log('復元スキップ:', key, value);
                } else {
                    this.configObj.set(key, value);
                    //console.log('復元成功:', key, value);
                }
            } else {
                console.log('無効なconfig:', key, value);
            }
        })
    }
    /**
     * 設定のカラーパレット表示用HTMLを、カラーパレット配列を基に生成する
     * @param {HTMLElement} elementPaletteBox 生成先DOM要素
     * @param {Object} objPalette カラーパレットオブジェクト
     */
    dispPalettebox(elementPaletteBox, objPalette) {
        // パレットボックスの要素の全削除
        while (elementPaletteBox.firstChild) {
            elementPaletteBox.removeChild(elementPaletteBox.firstChild);
        }
        const length = objPalette.palette.length;
        const column = objPalette.column !== 0 ? objPalette.column : length;

        // 列数に応じた幅を設定
        let palette_size = 22;
        elementPaletteBox.style.width = 8 + column * palette_size + 'px';

        // 色数、列数、行数のテキスト表示
        let row = Math.ceil(length / column);
        let text = `${length}色（${column}列×${row}行）`;
        if (objPalette.column === 0) {
            text = text + ' ※常に１行を維持';
        }
        document.getElementById('axp_config_div_paletteText').textContent = text;

        // カラーパレット（単体）のHTML生成
        const createPaletteHTML = (colorcode) => {
            var newDiv = document.createElement('div');
            newDiv.setAttribute('class', 'axpc_config_colorRect');
            newDiv.style.backgroundColor = colorcode;
            return newDiv;
        }
        for (const item of objPalette.palette) {
            // 画面に作成したカラーパレットを追加
            elementPaletteBox.appendChild(createPaletteHTML(item));
        }
    }
    // 拡大率テーブルの作成
    createConfigScaleTable(table) {
        const element = document.getElementById('axp_config_ul_scale');
        // 対象のオプションを全クリア
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
        for (let idx = 0; idx < table.length; idx++) {
            const value = table[idx];
            element.appendChild(this.createHTMLListScale(value));
        }
    }
    // 拡大率テーブルの作成（HTML生成）
    createHTMLListScale(value) {
        const list = document.createElement('li');
        list.dataset.value = String(value);
        list.textContent = `${value}%`;
        list.addEventListener('click', (e) => {
            if (e.target.dataset.value === '100') {
                // 拡大率100%は変更できません。
                this.axpObj.msg(`@CAU0104`);
                return;
            }
            const elements_li = document.querySelectorAll('#axp_config_ul_scale>li');
            for (const item of elements_li) {
                item.dataset.selected = '';
            }
            e.target.dataset.selected = 'true';
        })
        return list;
    }
    // 拡大率テーブルの変更をキーカスタマイズのセレクトボックスに反映させる
    updateKeyCustomizationScaleTable(table) {
        const elementsSelectScaleTable = document.querySelectorAll('.axpc_config_select_scaleTable');
        for (const selectbox of elementsSelectScaleTable) {
            // 対象のオプションを全クリア
            while (selectbox.firstChild) {
                selectbox.removeChild(selectbox.firstChild);
            }
            for (const value of table) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = `${value}%`;
                selectbox.appendChild(option);
            }
            // 無指定を選択
            selectbox.selectedIndex = -1;
        }
    }
}


/***/ }),

/***/ "./src/js/debuglog.js":
/*!****************************!*\
  !*** ./src/js/debuglog.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DebugLog: () => (/* binding */ DebugLog)
/* harmony export */ });
/* harmony import */ var _src_js_etc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/js/etc.js */ "./src/js/etc.js");
// @description デバッグ情報表示


const MAX_LINE = 300;
// デバッグログ表示
class DebugLog {
    elementDiv;
    elementStatus;
    elementLog;
    mode = false;
    lineCount = 0;
    constructor(id, flag) {
        this.elementDiv = document.getElementById(id);
        this.elementStatus = this.elementDiv.querySelector('div:nth-of-type(1)');
        this.elementLog = this.elementDiv.querySelector('div:nth-of-type(2)');
        if (flag) {
            this.mode = true;
            _src_js_etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.show(this.elementDiv);
        }
    }
    status(touch, maxtouch, isDrawing, isDrawn, isDrawCancel) {
        if (!this.mode) return;
        const drawing = (isDrawing) ? 'O' : '-';
        const drawn = (isDrawn) ? 'O' : '-';
        const drawCancel = (isDrawCancel) ? 'O' : '-';
        this.elementStatus.textContent =
            `タッチ数:${touch} max(${maxtouch}) ` +
            `開始:${drawing} 確定:${drawn} 中止:${drawCancel}`;
    }
    log(text) {
        if (!this.mode) return;

        const type = text.substring(0, 7);
        let addStyle = ''
        let addText = '';
        switch (type) {
            case '[DRAW_]':
                addStyle = '<span style="color:#0f0">';
                break;
            case '[MOVE_]':
                addStyle = '<span style="color:#aaa">';
                break;
            case '[EXEC_]':
                addStyle = '<span style="color:#f0f">';
                break;
            case '[TIMER]':
                addStyle = '<span style="color:#ff0">';
                break;
            default:
                addStyle = '<span>';
        }
        addText = addStyle + text + '</span><br>';
        if (this.lineCount >= MAX_LINE) {
            this.elementLog.removeChild(this.elementLog.firstChild);
            this.elementLog.removeChild(this.elementLog.firstChild);
        } else {
            this.lineCount++;
        }
        this.elementLog.insertAdjacentHTML('beforeend', addText);
        this.elementLog.scrollTop = this.elementLog.scrollHeight;

    }
    get isDebugMode() {
        return this.mode;
    }
    set isDebugMode(flag) {
        if (flag) {
            this.mode = true;
            _src_js_etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.show(this.elementDiv);
        } else {
            this.mode = false;
            _src_js_etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide(this.elementDiv);
        }
    }
}

/***/ }),

/***/ "./src/js/dragwindow.js":
/*!******************************!*\
  !*** ./src/js/dragwindow.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DragWindow: () => (/* binding */ DragWindow)
/* harmony export */ });
// @description ツールウィンドウのドラッグ＆ドロップ制御

// 要素内のクリック座標保持用
var drag_x;
var drag_y;
// ツールウィンドウ制御
class DragWindow {
    axpObj;
    windowSystems = [];
    zIndex_max = 1000;
    constructor(axpObj) {
        this.axpObj = axpObj;
    }
    add(objSystem) {
        this.windowSystems.push(objSystem);
        let element = objSystem.windowElement;
        // z-index（ウィンドウの表示優先順位）割り当て
        this.zIndex_max++;
        element.style.zIndex = this.zIndex_max;
        element.addEventListener('pointerenter', (e) => { this.enter(e, objSystem) });
        element.addEventListener('pointerleave', (e) => { this.leave(e) });
        element.addEventListener('pointerup', (e) => { this.up(e) });
        element.addEventListener('pointerdown', (e) => { this.down(e, objSystem) });
    }
    // 登録済みウィンドウオブジェクトからIDが一致するオブジェクトを検索
    getSystem(id) {
        for (const item of this.windowSystems) {
            if (item.id === id) {
                return item;
            }
        }
        return null;
    }
    unminimize(id) {
        const objSystem = this.getSystem(id);
        if (objSystem) {
            // ツールウィンドウ表示
            objSystem.unminimize();
        }
    }
    minimize(id) {
        const objSystem = this.getSystem(id);
        if (objSystem) {
            // ツールウィンドウ消去
            objSystem.minimize();
        }
    }
    // 非表示クラスの全体付与／解除
    changeAllWindowHiddenClass(isHidden) {
        for (const item of this.windowSystems) {
            if (item.isCanMinimize) {
                isHidden ? item.hidden() : item.visible();
            }
        }
    }
    allVisible() {
        this.changeAllWindowHiddenClass(false);
    }
    allHidden() {
        this.changeAllWindowHiddenClass(true);
    }
    // 再起動時の復元用
    restoreMinimize(id) {
        // 全体ボタン
        if (id === 'axp_all') {
            // ツールウィンドウ消去
            this.allHidden();
            // ランチャーのボタンに反映
            this.axpObj.launcher.minimizeButton(id);
            // 成功
            return true;
        }
        const objSystem = this.getSystem(id);
        if (objSystem) {
            // ツールウィンドウ消去
            this.minimize(id);
            // ランチャーのボタンに反映
            this.axpObj.launcher.minimizeButton(id);
            // 成功
            return true;
        } else {
            // 失敗
            return false;
        }
    }
    //エンター時
    enter(e) {
        if (this.axpObj.isDrawing) {
            // 描画中にツールウィンドウに被った場合は、ツールウィンドウを半透明化
            e.currentTarget.style.opacity = '0.25';
        } else {
            // ペンの太さカーソル非表示
            this.axpObj.ELEMENT.cursor.style.visibility = 'hidden';
        }
    }
    //離れた時
    leave(e) {
        e.currentTarget.style.opacity = '1';
        this.axpObj.msg('');
    }
    //ポインタアップ
    up(e) {
        e.currentTarget.style.opacity = '1';
    }
    //
    updateZIndex(elem) {
        //最後に操作したウィンドウが最前面になるように重なるようにz-indexの値を再設定
        if (elem.style.zIndex === this.zIndex_max) {
            // 既に最前面の場合は処理しない（２度同じウィンドウを操作した時など）
        } else {
            // 操作したウィンドウの現在のz_indexを保持しておく
            let zIndex_target = elem.style.zIndex;
            for (const item of this.windowSystems) {
                if (item.windowElement === elem) {
                    // 操作したウィンドウは最前面
                    item.windowElement.style.zIndex = this.zIndex_max;
                } else {
                    // その他のウィンドウ
                    if (item.windowElement.style.zIndex > zIndex_target) {
                        // 現在値より高い場合は１つ下げる
                        item.windowElement.style.zIndex--;
                    }
                }
            }
        }
    }
    down(e, objSystem) {
        if (this.axpObj.isDrawing) {
            // 描画処理中は、処理しない
            return;
        } else {
            // ツールウィンドウの操作時は、描画処理を作動させない
            // イベントバブリング抑止
            e.stopPropagation();
        }
        let elem = e.currentTarget;
        this.updateZIndex(elem);

        //最小化ボタンが押された場合
        if (e.target.classList.contains('axpc_window_header_minimizeButton')) {
            this.minimize(objSystem.windowElement.id);
            // ランチャーのボタンに反映
            this.axpObj.launcher.minimizeButton(objSystem.windowElement.id);
            // 状態保存
            this.axpObj.configSystem.saveConfig('WDMIN_' + objSystem.windowElement.id, true);
            return;
        }

        //ドラッグ可能エリア外操作
        if (!e.target.classList.contains('axpc_window_header_dragZone')) {
            return;
        }

        //要素内の相対座標を取得
        drag_x = e.pageX - elem.offsetLeft;
        drag_y = e.pageY - elem.offsetTop;

        // ドラッグ中

        const calcPosition = (x, y) => {
            //ドラッグ範囲制限
            var new_x = x - drag_x;
            var new_y = y - drag_y;
            var rect = this.axpObj.ELEMENT.base.getBoundingClientRect();
            // 横方向への移動可能最大値（ツールウィンドウの横幅分だけ残す）
            var limit_width = rect.width - objSystem.windowElement.clientWidth;
            // 下方向への移動可能最大値（ツールウィンドウのヘッダ部分だけ残す）
            var limit_height = rect.height - 30;

            if (new_x < 0) new_x = 0;
            if (new_y < 0) new_y = 0;
            if (new_x >= limit_width) new_x = limit_width;
            if (new_y >= limit_height) new_y = limit_height;

            return { x: new_x, y: new_y };
        }
        const onPointerMove = (e) => {

            let pos = calcPosition(e.pageX, e.pageY);
            //マウスが動いた場所に要素を動かす
            objSystem.setPosition(
                pos.x,
                pos.y
            );
        };
        const onPointerUp = (e) => {
            // ドロップ
            let pos = calcPosition(e.pageX, e.pageY);
            //マウスが動いた場所に要素を動かす
            objSystem.setPosition(
                pos.x,
                pos.y
            );
            //ウィンドウの座標をデータ化してコンフィグオブジェクトに格納
            let savedata = pos.x + ',' + pos.y;
            this.axpObj.configSystem.saveConfig('WDPOS_' + objSystem.windowElement.id, savedata);
            // イベントリスナー解除
            window.removeEventListener('pointermove', onPointerMove);
            window.removeEventListener('pointerup', onPointerUp);
        };
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
    }
    /**
     * 指定idと一致したツールウィンドウ要素をサーチし、見つかった場合、初期座標を更新する
     * @param {*} id ツールウィンドウ要素のID
     * @param {*} x left座標
     * @param {*} y top座標
     * @return 要素が見つかった場合:true 見つからなかった場合（仕様変更などにより存在しないIDの設定データが受け渡された場合）:false
     */
    setInitPosition(id, x, y) {
        let isFound = false;
        for (let index = 0; index < this.windowSystems.length; index++) {
            if (this.windowSystems[index].id === id) {
                // 初期座標更新
                this.windowSystems[index].window_left = x;
                this.windowSystems[index].window_top = y;
                isFound = true;
            }
        }
        return isFound;
    }
    /**
     * 全ツールウィンドウ位置の初期設定（事前にユーザー設定復元でwindow_leftとwindow_topを更新しておくこと）
     */
    initPosition() {
        for (let item of this.windowSystems) {
            item.setPosition();
        }
    }
    /**
     * 全ツールウィンドウ位置をデフォルトにリセット
     */
    resetPosition() {
        for (let item of this.windowSystems) {
            item.resetPosition();
            let key = 'WDPOS_' + item.windowElement.id;
            this.axpObj.configSystem.deleteConfig(key);
        }
    }
    changeAutoAdjustPosition() {
        for (let item of this.windowSystems) {
            item.setPosition();
        }
    }
}


/***/ }),

/***/ "./src/js/etc.js":
/*!***********************!*\
  !*** ./src/js/etc.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UTIL: () => (/* binding */ UTIL),
/* harmony export */   adjustColorValue: () => (/* binding */ adjustColorValue),
/* harmony export */   adjustInRange: () => (/* binding */ adjustInRange),
/* harmony export */   calcDistance: () => (/* binding */ calcDistance),
/* harmony export */   calcMidPointBetween: () => (/* binding */ calcMidPointBetween),
/* harmony export */   compareImages: () => (/* binding */ compareImages),
/* harmony export */   createTonePattern: () => (/* binding */ createTonePattern),
/* harmony export */   dispDate: () => (/* binding */ dispDate),
/* harmony export */   flip_horizontal: () => (/* binding */ flip_horizontal),
/* harmony export */   flip_vertical: () => (/* binding */ flip_vertical),
/* harmony export */   getBrowserType: () => (/* binding */ getBrowserType),
/* harmony export */   getFileNameFromURL: () => (/* binding */ getFileNameFromURL),
/* harmony export */   getRectSize: () => (/* binding */ getRectSize),
/* harmony export */   hex2rgb: () => (/* binding */ hex2rgb),
/* harmony export */   inRange: () => (/* binding */ inRange),
/* harmony export */   isBlankImage: () => (/* binding */ isBlankImage),
/* harmony export */   isColor: () => (/* binding */ isColor),
/* harmony export */   loadImageWithTimeout: () => (/* binding */ loadImageWithTimeout),
/* harmony export */   rgb2hex: () => (/* binding */ rgb2hex)
/* harmony export */ });
// @description ユーティリティ（独立した関数ライブラリ）

/**
 * AXNOS Paint用ユーティリティ（staticメソッド）
 */
class UTIL {
    /**
     * 要素の非表示
     * @param {*} element 非表示にする要素のobjectまたはid(string)
     */
    static hide(element) {
        let target;
        if (typeof element === 'string') {
            // IDが指定された時
            target = document.getElementById(element);
        } else {
            // 要素が指定された時
            target = element;
        }
        target.classList.add('axpc_NONE');
    }
    /**
     * 要素の表示
     * @param {*} element 表示する要素のobjectまたはid(string)
     */
    static show(element) {
        let target;
        if (typeof element === 'string') {
            // IDが指定された時
            target = document.getElementById(element);
        } else {
            // 要素が指定された時
            target = element;
        }
        target.classList.remove('axpc_NONE');
    }
}
/**
 * ブラウザ種別取得
 * @returns 
 */
function getBrowserType() {
    const agent = window.navigator.userAgent.toLowerCase();
    let type;

    if (agent.indexOf("msie") != -1 || agent.indexOf("trident") != -1) {
        type = "IE";
    } else if (agent.indexOf("edg") != -1 || agent.indexOf("edge") != -1) {
        type = "Edge";
    } else if (agent.indexOf("opr") != -1 || agent.indexOf("opera") != -1) {
        type = "Opera";
    } else if (agent.indexOf("chrome") != -1) {
        type = "Chrome";
    } else if (agent.indexOf("safari") != -1) {
        type = "Safari";
    } else if (agent.indexOf("firefox") != -1) {
        type = "FireFox";
    } else {
        type = "unknown";
    }
    return type;
}

// ファイルパスからファイル名部分だけ切り抜いて返却する
function getFileNameFromURL(input) {
    const baseUrl = window.location.href; // 現在のページのURL
    const absoluteUrl = new URL(input, baseUrl).href;
    // ファイル名抽出（例として、最後のスラッシュ以降の部分を取得）
    const fileName = absoluteUrl.split('/').pop();
    //console.log(input, fileName);
    return fileName;
}

/**
 * ２点間の距離
 * @param {*} x1 
 * @param {*} y1 
 * @param {*} x2 
 * @param {*} y2 
 * @returns 
 */
function calcDistance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}
/**
 * ２点の中点
 * @param {*} p1 
 * @param {*} p2 
 * @returns 
 */
function calcMidPointBetween(p1, p2) {
    return {
        x: (p2.x + p1.x) / 2,
        y: (p2.y + p1.y) / 2
    };
}

// 共通処理：HEXをRGBに変換
function hex2rgb(hex) {
    // #つきのカラーコードの場合は#を取り除く
    if (hex.slice(0, 1) == "#") hex = hex.slice(1);
    if (hex.length == 3) hex = hex.slice(0, 1) + hex.slice(0, 1) + hex.slice(1, 2) + hex.slice(1, 2) + hex.slice(2, 3) + hex.slice(2, 3);

    return [hex.slice(0, 2), hex.slice(2, 4), hex.slice(4, 6)].map(function (str) {
        return parseInt(str, 16);
    });
}

// 共通処理：RGBをHEXに変換
function rgb2hex(rgb) {
    let hex = rgb.map(function (value) {
        return ("0" + value.toString(16)).slice(-2);
    }).join("");
    // 大文字で返却
    return hex.toUpperCase();
}

// 左右反転用関数
// ImageData:canvasのgetImageDataで取得したデータ
function flip_horizontal(ImageData) {
    var idx_base;
    var idx_swap;
    for (var y = 0; y < ImageData.height; y++) {
        for (var x = 0; x < ImageData.width / 2; x++) {
            idx_base = (y * ImageData.width + x) * 4;
            idx_swap = (y * ImageData.width + ImageData.width - x - 1) * 4;
            var tmp0 = ImageData.data[idx_base + 0];
            var tmp1 = ImageData.data[idx_base + 1];
            var tmp2 = ImageData.data[idx_base + 2];
            var tmp3 = ImageData.data[idx_base + 3];
            ImageData.data[idx_base + 0] = ImageData.data[idx_swap + 0];
            ImageData.data[idx_base + 1] = ImageData.data[idx_swap + 1];
            ImageData.data[idx_base + 2] = ImageData.data[idx_swap + 2];
            ImageData.data[idx_base + 3] = ImageData.data[idx_swap + 3];
            ImageData.data[idx_swap + 0] = tmp0;
            ImageData.data[idx_swap + 1] = tmp1;
            ImageData.data[idx_swap + 2] = tmp2;
            ImageData.data[idx_swap + 3] = tmp3;
        }
    }
}

// 上下反転用関数
// ImageData:canvasのgetImageDataで取得したデータ
function flip_vertical(ImageData) {
    var idx_base;
    var idx_swap;
    for (var y = 0; y < ImageData.height / 2; y++) {
        for (var x = 0; x < ImageData.width; x++) {
            idx_base = (y * ImageData.width + x) * 4;
            idx_swap = ((ImageData.height - y - 1) * ImageData.width + x) * 4;
            var tmp0 = ImageData.data[idx_base + 0];
            var tmp1 = ImageData.data[idx_base + 1];
            var tmp2 = ImageData.data[idx_base + 2];
            var tmp3 = ImageData.data[idx_base + 3];
            ImageData.data[idx_base + 0] = ImageData.data[idx_swap + 0];
            ImageData.data[idx_base + 1] = ImageData.data[idx_swap + 1];
            ImageData.data[idx_base + 2] = ImageData.data[idx_swap + 2];
            ImageData.data[idx_base + 3] = ImageData.data[idx_swap + 3];
            ImageData.data[idx_swap + 0] = tmp0;
            ImageData.data[idx_swap + 1] = tmp1;
            ImageData.data[idx_swap + 2] = tmp2;
            ImageData.data[idx_swap + 3] = tmp3;
        }
    }
}

// 数値範囲内チェック-------------------------------------------------------------------------------
function inRange(x, min, max) {
    return ((x - min) * (x - max) <= 0);
}

function adjustInRange(x, min, max) {
    let result = x;
    if (x < min) result = min;
    if (x > max) result = max;
    return result;
}

// 日付の表示フォーマット変換----------------------------------------------------------------------------------------
// 使用例：filename = "ap_data" + dispDate(new Date(), 'YYYYMMDD_hhmmss') + ".axp"
function dispDate(date, format) {
    format = format.replace(/YYYY/, date.getFullYear());
    format = format.replace(/MM/, ("0" + (date.getMonth() + 1)).slice(-2));
    format = format.replace(/DD/, ("0" + date.getDate()).slice(-2));
    format = format.replace(/hh/, ("0" + date.getHours()).slice(-2));
    format = format.replace(/mm/, ("0" + date.getMinutes()).slice(-2));
    format = format.replace(/ss/, ("0" + date.getSeconds()).slice(-2));
    return format;
}

// カラーコード妥当性チェック----------------------------------------------------------------------------------------
// 引数colorに格納されている６桁or３桁が正常なカラーコードであればtrue、異常であればfalseを返却する
function isColor(color) {
    if (color.slice(0, 1) == "#") color = color.slice(1);
    return color.match(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/) !== null;
}

// カラー数値妥当性チェック
function adjustColorValue(value) {
    var result = value;
    if (isNaN(result)) { result = 0 }; // 数字でなければ0に変換
    result = Math.min(255, result); // 255を超えていたら255に変換
    result = Math.max(0, result); // 0より小さければ0に変換
    return result;
}

// 画像の読み込み（タイムアウト指定あり）
function loadImageWithTimeout(url, timeout) {
    return new Promise((resolve, reject) => {
        let image = new Image();

        let timer = setTimeout(() => {
            image.src = ''; // 画像の読み込みを中止
            reject(new Error('タイムアウトしました'));
        }, timeout);

        image.onload = () => {
            clearTimeout(timer);
            resolve(image);
        };

        image.onerror = () => {
            clearTimeout(timer);
            reject(new Error('画像の読み込みエラー'));
        };

        image.src = url;
    });
}

// イメージ比較（描画によってイメージが更新されたかどうかを判別する）
function compareImages(img1, img2) {
    if (img1.data.length != img2.data.length)
        return false;
    for (var i = 0; i < img1.data.length; ++i) {
        if (img1.data[i] != img2.data[i])
            return false;
    }
    return true;
}

// イメージ描画範囲を取得
function getRectSize(img) {
    let x0 = img.width;
    let y0 = img.height;
    let x1 = 0;
    let y1 = 0;
    // 描画情報あり（アルファチャンネルが１以上）なら矩形範囲更新
    for (var y = 0; y < img.height; y++) {
        for (var x = 0; x < img.width; x++) {
            let idx = (x + y * img.height) * 4;
            if (img.data[idx + 3] !== 0) {
                x0 = Math.min(x, x0);
                y0 = Math.min(y, y0);
                x1 = Math.max(x, x1);
                y1 = Math.max(y, y1);
            }
        }
    }
    /*
        if (x1 - x0 >= 0) {
            console.log('rect', x0, y0, x1, y1);
        } else {
            console.log('データなし');
        }
    */
    return {
        x0: x0,
        y0: y0,
        x1: x1,
        y1: y1
    }
}

// イメージが空白であるかの判定
function isBlankImage(img) {
    // 描画情報あり（アルファチャンネルが１以上）なら矩形範囲更新
    for (var y = 0; y < img.height; y++) {
        for (var x = 0; x < img.width; x++) {
            let idx = (x + y * img.height) * 4;
            if (img.data[idx + 3] !== 0) {
                // 空白ではない
                return false;
            }
        }
    }
    // 空白
    return true;
}

function createTonePattern(toneLevel, color) {
    let colorRGB = hex2rgb(color);
    let patternCanvas = document.createElement('canvas'),
        ctx = patternCanvas.getContext('2d');
    patternCanvas.width = 4;
    patternCanvas.height = 4;
    // トーンパターン配列（ベイヤーマトリクス）
    const arrayTonePatternTable = [0, 10, 2, 8, 5, 15, 7, 13, 1, 11, 3, 9, 4, 14, 6, 12];
    // スクリーントーン生成
    let img = new ImageData(4, 4);

    // トーンレベルで指定された濃さになるまで、順番に既定の位置にドットを打つ
    let maxLevel = toneLevel;
    for (let idx = 0; idx < maxLevel; idx++) {
        let i = arrayTonePatternTable[idx] * 4;
        img.data[i + 0] = colorRGB[0];
        img.data[i + 1] = colorRGB[1];
        img.data[i + 2] = colorRGB[2];
        img.data[i + 3] = 255;
    }
    ctx.putImageData(img, 0, 0);

    return ctx.createPattern(patternCanvas, 'repeat');

}



/***/ }),

/***/ "./src/js/keyboard.js":
/*!****************************!*\
  !*** ./src/js/keyboard.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyboardSystem: () => (/* binding */ KeyboardSystem)
/* harmony export */ });
// @description キーボード入力処理

class KeyboardSystem {
    axpObj;
    constructor(axpObj) {
        this.axpObj = axpObj;
    }
    // 初期化
    init() {
    }
    startEvent() {
        // ウィンドウ非アクティブの時、強制的に押しているキーを解除
        window.addEventListener('blur', () => {
            if (this.axpObj.isSPACE) {
                this.axpObj.penSystem.restorePenModeTemporary('axp_penmode_hand');
                this.axpObj.isSPACE = false;
            }
            if (this.axpObj.isCTRL) {
                this.axpObj.penSystem.restorePenModeTemporary('axp_penmode_spuit');
                this.axpObj.isCTRL = false;
            }
            if (this.axpObj.isSHIFT) {
                this.axpObj.isSHIFT = false;
            }
            if (this.axpObj.codeCHANGE_SIZE_KEY) {
                this.axpObj.codeCHANGE_SIZE_KEY = null;
            }
        });

        // キーが離された時
        window.addEventListener('keyup', (e) => {
            // e.keyが有効の場合のみ処理する（オートコンプリートによるイベントを無視）
            if (!e.key) return;

            let inkey = e.key.toUpperCase();
            switch (inkey) {
                case ' ':
                    this.axpObj.penSystem.restorePenModeTemporary('axp_penmode_hand');
                    this.axpObj.isSPACE = false;
                    break;
                case 'CONTROL':
                    this.axpObj.penSystem.restorePenModeTemporary('axp_penmode_spuit');
                    this.axpObj.isCTRL = false;
                    break;
                case 'SHIFT':
                    this.axpObj.isSHIFT = false;
                    break;
            }
            // ショートカット「ペンの太さ調整」で押された物理キー
            if (e.code === this.axpObj.codeCHANGE_SIZE_KEY) {
                this.axpObj.penSystem.modeChangeSizeOff();
            }
        });
        // キーが押された時（キーボードショートカット）
        window.addEventListener('keydown', (e) => {

            // 非表示時は無効
            if (this.axpObj.isClose) { return };

            // キャンバスタブ以外の画面（設定、投稿）は無効
            if (!this.axpObj.isCanvasOpen) { return; }

            // モーダルウィンドウ表示中（セーブロード、レイヤー名変更入力時）は無効
            if (this.axpObj.isModalOpen) { return; }

            // キー入力可能な要素にフォーカス中の場合は無効
            if (document.activeElement.type === 'number' || document.activeElement.type === 'text') {
                return;
            }

            // OS本来の操作を抑止
            e.preventDefault();

            let inkey = e.key.toUpperCase(); // 入力されたキーを大文字に変換
            // 描画中は無効
            if (this.axpObj.isDrawing) {
                if (inkey === 'SHIFT') {
                    // SHIFTキーで描画途中からでも直線描画モードに移行
                    this.axpObj.isLine = true;
                }
                return;
            }

            if (e.repeat) {
                if (
                    inkey === ' ' ||
                    inkey === 'CONTROL' ||
                    inkey === 'ALT' ||
                    inkey === 'SHIFT'
                ) {
                    // 上記のキーは、押しっぱなし入力を無効とする
                    return;
                } else {
                    // その他のキーは、呼び出す機能に応じて、後続の処理で判定を行う
                }
            }

            let keyId = inkey;
            // 記号を文字に変換
            switch (keyId) {
                case '*':
                    keyId = 'ASTERISK';
                    break;
                case '+':
                    keyId = 'PLUS';
                    break;
                case ',':
                    keyId = 'COMMA';
                    break;
                case '-':
                    keyId = 'MINUS';
                    break;
                case '.':
                    keyId = 'DOT';
                    break;
                case '/':
                    keyId = 'SLASH';
                    break;
                case ':':
                    keyId = 'COLON';
                    break;
                case ';':
                    keyId = 'SEMICOLON';
                    break;
            }
            console.log('keyboard:', e.code, e.key, '->', inkey, keyId);
            // e.code : 物理キーコード
            // e.key : 入力されたキーコード
            // keyId : 要素ID用
            // inkey : 画面表示用キー
            switch (inkey) {
                case ' ':
                    this.axpObj.isSPACE = true;
                    this.axpObj.penSystem.changePenModeTemporary('axp_penmode_hand');
                    break;
                case 'CONTROL':
                    this.axpObj.isCTRL = true;
                    this.axpObj.penSystem.changePenModeTemporary('axp_penmode_spuit');
                    break;
                case 'ALT':
                    break;
                case 'SHIFT':
                    this.axpObj.isSHIFT = true;
                    break;
                default:
                    this.axpObj.callTask(`axp_config_custom_key${keyId}`, inkey, e.repeat, e.code);
                    break;
            }
        });
    }
}


/***/ }),

/***/ "./src/js/lang.js":
/*!************************!*\
  !*** ./src/js/lang.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDictionaryJSON: () => (/* binding */ getDictionaryJSON)
/* harmony export */ });
// @description 指定されたパスから追加辞書JSONをロードする

async function getDictionaryJSON(dictionaryURL) {
    // 辞書ファイル存在確認
    async function checkFileExists(url) {
        try {
            const response = await fetch(url, { method: 'HEAD' });
            return response.ok;
        } catch (error) {
            console.error('Error:', error);
            return false;
        }
    }
    // 辞書ファイルフェッチ
    async function loadJSON(url) {
        try {
            const response = await fetch(url);
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error:', error);
            return false;
        }
    }
    if (await checkFileExists(dictionaryURL)) {
        const loadedJSON = await loadJSON(dictionaryURL)
        if (loadedJSON) {
            // 読込成功
            return loadedJSON;
        } else {
            return 'SYNTAX_ERROR';
        }
    } else {
        return 'NOT_FOUND';
    }
}


/***/ }),

/***/ "./src/js/message.js":
/*!***************************!*\
  !*** ./src/js/message.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Message: () => (/* binding */ Message)
/* harmony export */ });
/* harmony import */ var _text_msg_txt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../text/msg.txt */ "./src/text/msg.txt");
// @description 画面左下のガイドメッセージ用データロード処理

// メッセージテキスト

const textArray = _text_msg_txt__WEBPACK_IMPORTED_MODULE_0__.split(/\r\n|\n/);
const talk = new Map();
for (let index = 0; index < textArray.length; index++) {
    let splitText = textArray[index].split(',');
    let type = splitText[0];
    let text = splitText[1];
    if (splitText[1] === '') {
        throw (`メッセージデータに不正があります type:${type} index:${index}`);
    }
    if (!talk.has(type)) {
        talk.set(type, text);
    } else {
        throw (`メッセージデータにID重複があります type:${type} index:${index}`);
    }
}
//
class Message {
    static getMessage(id) {
        let text = "";
        if (talk.has(id)) {
            text = talk.get(id);
        };
        //console.log('text:', text);
        return text;
    }
}

/***/ }),

/***/ "./src/js/pendefine/_penobj.js":
/*!*************************************!*\
  !*** ./src/js/pendefine/_penobj.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PenObj: () => (/* binding */ PenObj)
/* harmony export */ });
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../etc.js */ "./src/js/etc.js");
// @description ペン定義：親クラス



// ペンオブジェクト
class PenObj {
    constructor() {
        this.base_x = 0; // 描画開始X座標
        this.base_y = 0; // 描画開始Y座標
        this.base_index = 0;
        this.old_x = 0; // 前回の入力X座標
        this.old_y = 0; // 前回の入力Y座標
        this.end_x = 0; // 描画終了X座標
        this.end_y = 0; // 描画終了Y座標
        this.drawmode = null;
        this.isLastDrawing = false;
        this.input_position = [];
        // 値
        this.name = null
        this.type = null;
        this.size = null;
        this.index = null;
        this.alpha = null;
        this.threshold = null;
        this.toneLevel = null;
        this.blurLevel = null;
        this.gradation = null;
        this.radius = null;
        this.cursor = 'auto';
        // 制御
        this.usePenGuide = false;
        this.usePenPreview = false;
        this.usePenLock = false;
        this.usePenStyle = false;
        this.canUndo = false;
        // 描画
        this.borderRadius = null;
        this.borderStyle = null;
        this.lineCap = null;
        this.lineJoin = null;

    }
    // 太さ、不透明度の初期値の保存（初期化用）
    init_save() {
        this.init_size = this.size;
        this.init_index = this.index;
        this.init_alpha = this.alpha;
    }
    // 太さ、不透明度の初期化
    init() {
        this.size = this.init_size;
        this.index = this.init_index;
        this.alpha = this.init_alpha;
    }
    getColor() {
        return this.axpObj.colorMakerSystem.getAdjustColor();
    }
    getColorRGB() {
        return this.axpObj.colorMakerSystem.getAdjustColorRGB();
    }
    // ぼかし設定
    blur(level) {
        this.CANVAS.draw_ctx.shadowColor = this.getColor();
        var blur_value;
        if (level === undefined) {
            // ぼかしスライダー有効時のみ適用
            if (this.axpObj.config('axp_config_form_blurLevel') === 'on') {
                blur_value = this.blurLevel;
            } else {
                blur_value = 0;
            }
        } else {
            blur_value = Number(level);
        }
        if (blur_value > 0) {
            // ぼかしをかける場合、色が重なって濃くなるため、不透明度を補正する
            // ただし、不透明度100%のときは補正しない
            if (this.CANVAS.draw_ctx.globalAlpha !== 1) {
                this.CANVAS.draw_ctx.globalAlpha = this.CANVAS.draw_ctx.globalAlpha / Math.sqrt(2);
            }
        }
        // console.log('blu', blur_value);
        this.CANVAS.draw_ctx.shadowBlur = blur_value;
        this.CANVAS.draw_ctx.shadowOffsetX = 0;
        this.CANVAS.draw_ctx.shadowOffsetY = 0;
    }
    // カーソル表示
    drawCursor(e) {
        if (this.usePenLock) {
            // ロックの影響を受けるタイプ
            if (this.axpObj.layerSystem.isWriteProtection()) {
                // レイヤー書き込み不可状態のときは、注意喚起のため表示しない
                // マウスポインタ：不許可
                this.axpObj.ELEMENT.view.style.cursor = 'not-allowed';
                // ペンガイド線非表示
                this.axpObj.ELEMENT.cursor.style.visibility = 'hidden';
                // 処理終了
                return;
            }
        }
        // マウスポインタの形状を指定
        this.axpObj.ELEMENT.view.style.cursor = this.cursor;
        // マウスポインタの場所に、ペンの太さを示すガイド線を表示
        if (this.usePenGuide) {
            // ペンガイド線を表示するタイプの処理（丸ペン、筆ペン、エアブラシなど）
            this.axpObj.ELEMENT.cursor.style.visibility = 'visible';
            this.axpObj.ELEMENT.cursor.style.borderRadius = `${this.borderRadius}%`;
            // ガイド線の色設定
            if (this.borderStyle === 'normal') {
                // 透明色を考慮するパターン指定
                if (document.getElementById('axp_makecolor_div_transparent').dataset.selected === 'true') {
                    // 透明色の場合、破線にする
                    this.axpObj.ELEMENT.cursor.style.borderStyle = 'dashed';
                } else {
                    this.axpObj.ELEMENT.cursor.style.borderStyle = 'solid';
                }
            } else {
                this.axpObj.ELEMENT.cursor.style.borderStyle = this.borderStyle;
            }
            if (this.radius !== null) {
                // クレヨン丸み
                this.axpObj.ELEMENT.cursor.style.borderRadius = `${this.radius}%`;
            }
            const size = parseInt(this.size * this.axpObj.scale / 100);
            this.axpObj.ELEMENT.cursor.style.width = size + 'px';
            this.axpObj.ELEMENT.cursor.style.height = size + 'px';
            const pos = this.getCursorPosition(e);
            this.axpObj.ELEMENT.cursor.style.left = pos.x + 'px';
            this.axpObj.ELEMENT.cursor.style.top = pos.y + 'px';

        } else {
            // ペンガイド線を表示しないタイプの処理（バケツ、ハンド、スポイトなど）
            // ペンガイド線非表示
            this.axpObj.ELEMENT.cursor.style.visibility = 'hidden';
        }
    }
    // ペンガイド表示座標（子クラスと孫クラスで変更できるように階層定義）
    getCursorPosition(e) {
        const pos = this.getCursorPositionNormal(e);
        return { x: pos.x, y: pos.y };
    }
    // 通常用
    getCursorPositionNormal(e) {
        const size = parseInt(this.size * this.axpObj.scale / 100);
        // ヘッダを表示している場合、座標がズレるので補正する
        const rect = this.axpObj.ELEMENT.view.getBoundingClientRect();
        const x = parseInt((e.clientX - rect.left) - size / 2);
        const y = parseInt((e.clientY - rect.top) - size / 2);
        return { x: x, y: y };
    }
    // 各種モードの設定
    set_modeflag() {
        this.drawmode = this.axpObj.CONST.DRAW_FREEHAND;
        if (this.axpObj.isSHIFT) { this.axpObj.isLine = true; } // シフトを押していたら直線モード
        // 描画モード指定
        switch (document.getElementById('axp_pen_select_drawMode').value) {
            case 'option_line':
                this.axpObj.isLine = true;
                break;
            case 'option_rectangle':
                this.axpObj.isRect = true;
                this.drawmode = this.axpObj.CONST.DRAW_RECT;
                break;
            case 'option_circle':
                this.drawmode = this.axpObj.CONST.DRAW_CIRCLE;
                break;
        }
        this.axpObj.isDrawing = true;
        this.axpObj.isDrawn = false;
        this.axpObj.isDrawCancel = false;
        this.isLastDrawing = false;
    }
    reset_modeflag() {
        this.axpObj.isDrawing = false;
        this.axpObj.isDrawn = false;
        this.axpObj.isDrawCancel = false;
        this.axpObj.isLine = false;
        this.axpObj.isRect = false;
        this.axpObj.isCircle = false;
    }
    init_globalCompositeOperation(option) {
        // 合成モードと不透明度
        let type;
        if (typeof option.task !== 'undefined' && option.task == 'transdraw') {
            // 透明色描画（マウス右ボタン／ホイールボタン）
            type = 'destination-out';
        } else {
            if (document.getElementById('axp_makecolor_div_transparent').dataset.selected === 'true') {
                // 透明色
                type = 'destination-out';
            } else {
                if (this.axpObj.layerSystem.getMasked()) {
                    // 透明部分の保護
                    type = 'source-atop';
                } else {
                    type = 'source-over';
                }
            }
        }
        this.axpObj.penSystem.CANVAS.draw_ctx.globalCompositeOperation = type;
    }
    // 描画開始
    start() {
        // ペンの種類ごとに子クラスでオーバーライドする
    }
    // 描画中
    move() {
        // ペンの種類ごとに子クラスでオーバーライドする
    }
    // 描画終了
    end() {
        // ペンの種類ごとに子クラスでオーバーライドする
    }
    init_brush() {
        // ペンの種類ごとに子クラスでオーバーライドする
    }
    draw() {
        // ペンの種類ごとに子クラスでオーバーライドする
    }
    // レイヤー更新
    write() {
        // 描画した線に透明度を適用して、元画像と合成する
        this.CANVAS.draw_ctx.putImageData(this.axpObj.layerSystem.load(), 0, 0);
        this.CANVAS.draw_ctx.drawImage(this.CANVAS.brush, 0, 0);
        // レイヤー更新
        this.axpObj.layerSystem.write(
            this.CANVAS.draw_ctx.getImageData(0, 0, this.axpObj.x_size, this.axpObj.y_size)
        );
        this.axpObj.layerSystem.updateCanvas();
    }
    // 描画終了 - 共通処理
    end_common() {
        if (this.axpObj.isDrawing) {
            // アンドゥ対象の機能かつ描画キャンセルされていない時アンドゥデータ作成
            if (this.canUndo && !this.axpObj.isDrawCancel) {
                // 描画前と描画後を比較し、差分があればアンドゥ用記録
                // キャンバス外で描画操作を行った場合にアンドゥ対象としないための処理
                // キャンバス外から太いペンでキャンバス内に描画したり、直線描画時にキャンバス外の２点を指定された場合を考慮
                if (!(0,_etc_js__WEBPACK_IMPORTED_MODULE_0__.compareImages)(
                    this.axpObj.layerSystem.load(),
                    this.axpObj.layerSystem.getCurrentLayerImage()
                )
                ) {
                    // アンドゥデータ作成
                    this.axpObj.undoSystem.setUndo({
                        type: 'draw',
                        detail: this.type,
                        layerObj: {
                            id: this.axpObj.layerSystem.getId(),
                            index: this.axpObj.layerSystem.getIndex(),
                            mode: this.axpObj.layerSystem.getMode(),
                            alpha: this.axpObj.layerSystem.getAlpha(),
                            checked: this.axpObj.layerSystem.getChecked(),
                            locked: this.axpObj.layerSystem.getLocked(),
                            masked: this.axpObj.layerSystem.getMasked(),
                            name: this.axpObj.layerSystem.getName(),
                            image: this.axpObj.layerSystem.load(),
                        },
                    });
                    // 背景タイルプレビュー表示
                    if (this.axpObj.isBackgroundimage) {
                        this.axpObj.drawBackground();
                    }
                    // 自動保存（10回の描画に一度、保存処理を実行する）
                    this.axpObj.saveSystem.autoSave();
                }
            }
            // 描画フラグリセット
            this.reset_modeflag();
        }
    }
    // ペンの太さプレビュー表示
    previewPenSize() {
        // 更新キャンバス
        let canvas = this.axpObj.penSystem.CANVAS.pensize;
        let ctx = this.axpObj.penSystem.CANVAS.pensize_ctx;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // スポイトキャンバスのクリア
        let canvas_spuit = this.axpObj.penSystem.CANVAS.spuit;
        let ctx_spuit = this.axpObj.penSystem.CANVAS.spuit_ctx;
        ctx_spuit.clearRect(0, 0, canvas_spuit.width, canvas_spuit.height);

        if (!this.usePenPreview) {
            // ペンガイド線を表示しないタイプの処理（バケツ、ハンドなど）
            // 表示クリアのみ
            return;
        }
        // ※注意：スポイトはオーバーライドで独自処理

        // 透明色と消しゴムの場合は、破線で表示するため、事前判定を行う
        let isDashed;
        if (this.borderStyle === 'normal') {
            // 透明色を考慮するパターン指定
            if (document.getElementById('axp_makecolor_div_transparent').dataset.selected === 'true') {
                // 透明色の場合、破線にする
                isDashed = true;
            } else {
                isDashed = false;
            }
        } else {
            isDashed = true;
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = this.alpha / 100;

        ctx.lineCap = this.lineCap;
        ctx.lineJoin = this.lineJoin;

        // size指定できないタイプ(null)の場合、固定値
        let size;
        if (this.size !== null) {
            size = this.size * (this.axpObj.scale / 100);
        } else {
            // バケツ時の表示サイズ
            size = 80;
        }

        let radius = size * this.borderRadius / 100;
        this.createRoundRectPath(ctx, 49.5 - size / 2, 49.5 - size / 2, size, size, radius);
        if (isDashed) {
            // 透明色の場合の破線
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.stroke();
            ctx.setLineDash([]);
        } else {
            // トーン濃度使用時
            if (this.axpObj.config('axp_config_form_ToneLevel') === 'on' &&
                this.toneLevel !== null &&
                this.toneLevel !== 16) {
                // トーンパターン生成
                ctx.fillStyle = (0,_etc_js__WEBPACK_IMPORTED_MODULE_0__.createTonePattern)(this.toneLevel, this.getColor());
            } else {
                ctx.fillStyle = this.getColor();
            }
            ctx.fill();
        }

        if (this.size !== null) {
            // 補助線を引く
            ctx.globalAlpha = 1;
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#333";
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.beginPath();
            ctx.moveTo(49.5, 0);
            ctx.lineTo(49.5, 99);
            ctx.moveTo(0, 49.5);
            ctx.lineTo(99, 49.5);
            ctx.stroke();
        }
    }
    /*
    * 角が丸い四角形のパスを作成する
    * @param  {CanvasRenderingContext2D} ctx コンテキスト
    * @param  {Number} x   左上隅のX座標
    * @param  {Number} y   左上隅のY座標
    * @param  {Number} w   幅
    * @param  {Number} h   高さ
    * @param  {Number} r   半径
    */
    createRoundRectPath(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.arc(x + w - r, y + r, r, Math.PI * (3 / 2), 0, false);
        ctx.lineTo(x + w, y + h - r);
        ctx.arc(x + w - r, y + h - r, r, 0, Math.PI * (1 / 2), false);
        ctx.lineTo(x + r, y + h);
        ctx.arc(x + r, y + h - r, r, Math.PI * (1 / 2), Math.PI, false);
        ctx.lineTo(x, y + r);
        ctx.arc(x + r, y + r, r, Math.PI, Math.PI * (3 / 2), false);
        ctx.closePath();
    }

}

/***/ }),

/***/ "./src/js/pendefine/brush.js":
/*!***********************************!*\
  !*** ./src/js/pendefine/brush.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Brush: () => (/* binding */ Brush)
/* harmony export */ });
/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./round.js */ "./src/js/pendefine/round.js");
// @description ペン定義：親クラス＞丸ペン＞エアブラシ



// ブラシ
class Brush extends _round_js__WEBPACK_IMPORTED_MODULE_0__.Round {
    constructor(option) {
        super(option);
        // 値（Roundからの差分）
        this.name = this.axpObj._('@PENNAME.AIRBRUSH');
        this.size = 100;
        this.alpha = 30;
        this.toneLevel = null;
        // 制御
        this.usePenStyle = false;
        // 描画

        this.init_save();
    }
    init_brush(option) {
        // 合成モードと不透明度
        this.init_globalCompositeOperation(option);
        this.CANVAS.draw_ctx.globalAlpha = this.alpha / 100;
        // ブラシ
        this.CANVAS.brush_ctx.globalCompositeOperation = 'source-over';
        this.CANVAS.brush_ctx.globalAlpha = 1; // 先に不透明度100%の描画データを作成する
        this.CANVAS.brush_ctx.clearRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);
        this.blur();
    }
    // 描画中
    move(x, y) {
        // 描画継続中
        if (this.axpObj.isDrawing && !this.axpObj.isDrawCancel) {
            // 描画確定済み
            this.axpObj.isDrawn = true;
            // 入力座標の記憶
            this.input_position.push({ x, y });
            // 描画
            this.draw();
        }
    }
    draw() {
        var radius = this.size / 2; // 半径指定
        var grad = this.CANVAS.brush_ctx.createRadialGradient(
            this.input_position.at(-1).x,
            this.input_position.at(-1).y,
            0,
            this.input_position.at(-1).x,
            this.input_position.at(-1).y,
            radius);
        var rgb = this.getColorRGB();
        var rbga = 'rgba(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ',' + this.alpha / 100 + ')';
        var rbga0 = 'rgba(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ',0)';
        grad.addColorStop(0, rbga);
        grad.addColorStop(1, rbga0);
        this.CANVAS.brush_ctx.fillStyle = grad;
        this.CANVAS.brush_ctx.fillRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);
        this.write();
    }
}

/***/ }),

/***/ "./src/js/pendefine/crayon.js":
/*!************************************!*\
  !*** ./src/js/pendefine/crayon.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Crayon: () => (/* binding */ Crayon)
/* harmony export */ });
/* harmony import */ var _dot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dot.js */ "./src/js/pendefine/dot.js");
// @description ペン定義：親クラス＞ドットペン＞クレヨン



// クレヨン
class Crayon extends _dot_js__WEBPACK_IMPORTED_MODULE_0__.Dot {
    constructor(option) {
        super(option);
        // 値（Roundからの差分）
        this.name = this.axpObj._('@PENNAME.CRAYON');
        this.size = 15;
        this.toneLevel = null;
        this.radius = 50;
        // 制御
        // 描画
        this.borderRadius = 50;
        this.borderStyle = 'normal';
        this.lineCap = 'square';
        this.lineJoin = 'bevel';

        this.init_save();
    }
    // ペンガイド表示座標（クレヨンはDotを継承するが、ガイドは_penObjと同等の処理を行う）
    getCursorPosition(e) {
        const pos = this.getCursorPositionNormal(e);
        return { x: pos.x, y: pos.y };
    }
    // ドット座標の変換は行わない
    trans_dot(point) {
        return point;
    }
    // 角丸の範囲内に収まるランダムな座標を生成
    getRandomPosition(size) {
        let x, y;
        // 単位円の丸みを帯びない範囲
        let width0 = 1 - this.radius / 50;
        // 単位円の丸みを帯びる範囲
        let width1 = 1 - width0;

        while (true) {
            x = Math.random() * 2 - 1;
            y = Math.random() * 2 - 1;

            const absX = Math.abs(x);
            const absY = Math.abs(y);
            // 丸みを帯びない矩形の範囲内であれば有効値とする
            if (absX > width0 && absY > width0) {
                // 次の判定へ
            } else {
                break;
            }

            // 丸みを帯びる範囲の場合
            let dx = (absX - width0) / width1;
            let dy = (absY - width0) / width1;
            const root = (dx * dx) + (dy * dy);
            // 原点からの距離が1未満であれば単位円の範囲（丸みを帯びる領域の範囲）に収まるので有効値とする
            if (root < 1) {
                break;
            }
        }

        x = parseInt(x * size / 2);
        y = parseInt(y * size / 2);

        return { x: x, y: y };
    }
    // クレヨン描画
    drawLine(
        imageData,
        x0,
        y0,
        x1,
        y1,
        lineWidth,
        color,
    ) {
        const { width, data } = imageData;
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;
        const TIMES = 20 + lineWidth * 2;

        let err = dx - dy;
        let vx = x0;
        let vy = y0;
        let old_divx0 = -1;
        let old_divy0 = -1;

        while (true) {
            // setpixel
            let divx0 = vx;
            let divy0 = vy;
            // 計算座標が前回描画位置から変化した場合、その座標に幅lineWidthの正方形を描画
            if (divx0 !== old_divx0 || divy0 !== old_divy0) {

                for (let i = 0; i < TIMES; i++) {
                    // 角丸の範囲内のランダムノイズ描画
                    let pos = this.getRandomPosition(lineWidth);
                    let x = pos.x + divx0;
                    let y = pos.y + divy0;

                    let a = parseInt(Math.random() * 30) + 20;
                    // 正方形がキャンバスをはみ出す部分は、描画しない
                    if (x >= 0 && x < this.axpObj.x_size && y >= 0 && y < this.axpObj.y_size) {
                        //console.log(x,y);
                        const i = (x + y * width) * 4
                        data[i + 0] = color[0]
                        data[i + 1] = color[1]
                        data[i + 2] = color[2]
                        data[i + 3] = a;
                    }
                }
                // 前回描画位置の更新
                old_divx0 = divx0;
                old_divy0 = divy0;
            }
            // 終点まで走査したら終了
            if (vx === x1 && vy === y1) break;

            // 次の座標を計算
            let e2 = 2 * err;
            if (e2 > -dy) {
                err = err - dy;
                vx = vx + sx;
            }
            if (e2 < dx) {
                err = err + dx;
                vy = vy + sy;
            }
        }
    }
    drawCircle(
        imageData,
        x0,
        y0,
        x1,
        y1,
        lineWidth,
        color,
    ) {
        const { width, data } = imageData;
        const TIMES = 20 + lineWidth * 2;
        const diff = parseInt(lineWidth / 2);
        const r = parseInt(Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)));
        if (r <= 0) { return };

        var xx = parseInt(128 * r);
        var yy = 0;
        var x = 0;
        var y = 0;

        const SetPixel = (divx0, divy0) => {
            let divx1 = divx0 + lineWidth;
            let divy1 = divy0 + lineWidth;

            for (let i = 0; i < TIMES; i++) {
                // 正方形の範囲内でランダムノイズ描画
                let x = parseInt(Math.random() * (divx1 - divx0) + divx0) - diff;
                let y = parseInt(Math.random() * (divy1 - divy0) + divy0) - diff;
                let a = parseInt(Math.random() * 30) + 20;
                // 正方形がキャンバスをはみ出す部分は、描画しない
                if (x >= 0 && x < this.axpObj.x_size && y >= 0 && y < this.axpObj.y_size) {
                    //console.log(x,y);
                    const i = (x + y * width) * 4
                    data[i + 0] = color[0]
                    data[i + 1] = color[1]
                    data[i + 2] = color[2]
                    data[i + 3] = a;
                }
            }
        }
        while (yy <= xx) {
            x = parseInt(xx / 128);
            y = parseInt(yy / 128);
            SetPixel(x0 + x, y0 + y);
            SetPixel(x0 - x, y0 - y);
            SetPixel(x0 - x, y0 + y);
            SetPixel(x0 + x, y0 - y);
            SetPixel(x0 + y, y0 + x);
            SetPixel(x0 - y, y0 - x);
            SetPixel(x0 - y, y0 + x);
            SetPixel(x0 + y, y0 - x);
            yy += parseInt(xx / 128);
            xx -= parseInt(yy / 128);
        }

    }
}


/***/ }),

/***/ "./src/js/pendefine/dot.js":
/*!*********************************!*\
  !*** ./src/js/pendefine/dot.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dot: () => (/* binding */ Dot)
/* harmony export */ });
/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./round.js */ "./src/js/pendefine/round.js");
// @description ペン定義：親クラス＞ドットペン



// ドット
class Dot extends _round_js__WEBPACK_IMPORTED_MODULE_0__.Round {
    img_draw;
    constructor(option) {
        super(option);
        // 値（Roundからの差分）
        this.name = this.axpObj._('@PENNAME.DOT');
        this.toneLevel = null;
        // 制御
        // 描画
        this.borderRadius = 0;
        this.borderStyle = 'normal';
        this.lineCap = 'square';
        this.lineJoin = 'bevel';

        this.init_save();
    }
    // ペンガイド表示座標
    getCursorPosition(e) {
        const pos = this.getCursorPositionDot(e);
        return { x: pos.x, y: pos.y };
    }
    // ドット用
    getCursorPositionDot(e) {
        // ヘッダを表示している場合、座標がズレるので補正する
        const rect = this.axpObj.ELEMENT.view.getBoundingClientRect();

        // ペンの太さ単位でドットを描画するため、太さに応じて座標ををずらす
        let crect = this.axpObj.CANVAS.main.getBoundingClientRect();
        // キャンバス座標を、ペンの太さで割り（剰余切り捨て）、ペンの太さを乗算する
        let t_canvas_x = Math.floor((e.clientX - crect.left) * 100 / this.axpObj.scale);
        let t_canvas_y = Math.floor((e.clientY - crect.top) * 100 / this.axpObj.scale);
        let t_width = this.size;
        let t_dot_x = Math.floor(t_canvas_x / t_width) * t_width;
        let t_dot_y = Math.floor(t_canvas_y / t_width) * t_width;
        let x = parseInt(t_dot_x * this.axpObj.scale / 100) + crect.left - rect.left;
        let y = parseInt(t_dot_y * this.axpObj.scale / 100) + crect.top - rect.top;

        return { x: x, y: y };
    }
    start_draw() {
        this.img_draw = new ImageData(this.axpObj.x_size, this.axpObj.y_size);
    }
    // 描画中
    move(x, y) {
        // 描画継続中
        if (this.axpObj.isDrawing && !this.axpObj.isDrawCancel) {
            // 描画確定済み
            this.axpObj.isDrawn = true;
            // 入力座標の記憶
            this.input_position.push({ x, y });
            // 描画領域の初期化
            this.clear_brush();
            // 描画
            this.draw();
        }
    }
    clear_brush() {
        let needClear = false;
        if (this.axpObj.isLine) {
            needClear = true;
        }
        switch (this.drawmode) {
            case this.axpObj.CONST.DRAW_RECT:
            case this.axpObj.CONST.DRAW_CIRCLE:
                needClear = true;
                break;
        }
        if (needClear) {
            this.img_draw = new ImageData(this.axpObj.x_size, this.axpObj.y_size);
        }
    }
    // ドット座標に変換
    trans_dot(point) {
        return Math.floor(point / this.size) * this.size + this.size / 2;
    }
    draw() {
        let start_x;
        let start_y;
        let end_x;
        let end_y;
        let pencolor = this.getColorRGB();
        // 終了点（今回入力座標）
        end_x = this.trans_dot(this.input_position[this.input_position.length - 1].x);
        end_y = this.trans_dot(this.input_position[this.input_position.length - 1].y);
        switch (this.drawmode) {
            case this.axpObj.CONST.DRAW_FREEHAND:
                // 開始点（前回座標）
                if (this.axpObj.isLine) {
                    // 直線モードの場合、始点を最初の入力座標にする
                    start_x = this.trans_dot(this.input_position[0].x);
                    start_y = this.trans_dot(this.input_position[0].y);
                } else {
                    start_x = this.trans_dot(this.input_position[this.input_position.length - 2].x);
                    start_y = this.trans_dot(this.input_position[this.input_position.length - 2].y);
                }
                // 直線
                this.drawLine(
                    this.img_draw,
                    start_x,
                    start_y,
                    end_x,
                    end_y,
                    this.size,
                    pencolor
                );
                break;
            case this.axpObj.CONST.DRAW_RECT:
                // 開始点
                start_x = this.trans_dot(this.input_position[0].x);
                start_y = this.trans_dot(this.input_position[0].y);
                this.drawLine(this.img_draw, start_x, start_y, start_x, end_y, this.size, pencolor);
                this.drawLine(this.img_draw, start_x, end_y, end_x, end_y, this.size, pencolor);
                this.drawLine(this.img_draw, start_x, start_y, end_x, start_y, this.size, pencolor);
                this.drawLine(this.img_draw, end_x, start_y, end_x, end_y, this.size, pencolor);
                break;
            case this.axpObj.CONST.DRAW_CIRCLE:
                // 開始点
                start_x = this.trans_dot(this.input_position[0].x);
                start_y = this.trans_dot(this.input_position[0].y);
                this.drawCircle(this.img_draw, start_x, start_y, end_x, end_y, this.size, pencolor);
                break;
        }
        this.CANVAS.brush_ctx.putImageData(this.img_draw, 0, 0);
        this.write();
    }
    // 直線描画(Bresenham's line algorithm)
    drawLine(
        imageData,
        x0,
        y0,
        x1,
        y1,
        lineWidth,
        color,
    ) {
        const { width, data } = imageData;
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;

        let err = dx - dy;
        let vx = x0;
        let vy = y0;
        let old_divx0 = -1;
        let old_divy0 = -1;

        while (true) {
            // setpixel
            let divx0 = Math.floor(vx / lineWidth) * lineWidth;
            let divy0 = Math.floor(vy / lineWidth) * lineWidth;
            // 計算座標が前回描画位置から変化した場合、その座標に幅lineWidthの正方形を描画
            if (divx0 !== old_divx0 || divy0 !== old_divy0) {
                let divx1 = divx0 + lineWidth - 1;
                let divy1 = divy0 + lineWidth - 1;
                for (let x = divx0; x <= divx1; x++) {
                    for (let y = divy0; y <= divy1; y++) {
                        // 計算された座標がキャンバス内のみ描画する
                        if (x >= 0 && x < this.axpObj.x_size && y >= 0 && y < this.axpObj.y_size) {
                            const i = (x + y * width) * 4
                            data[i + 0] = color[0]
                            data[i + 1] = color[1]
                            data[i + 2] = color[2]
                            data[i + 3] = 255;
                        }
                    }
                }
                // 前回描画位置の更新
                old_divx0 = divx0;
                old_divy0 = divy0;
            }
            // 終点まで走査したら終了
            if (vx === x1 && vy === y1) break;

            // 次の座標を計算
            let e2 = 2 * err;
            if (e2 > -dy) {
                err = err - dy;
                vx = vx + sx;
            }
            if (e2 < dx) {
                err = err + dx;
                vy = vy + sy;
            }
        }
    }
    // 円描画
    drawCircle(
        imageData,
        x0,
        y0,
        x1,
        y1,
        lineWidth,
        color,
    ) {
        const { width, data } = imageData;
        const r = parseInt(Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)));

        if (r <= 0) { return };

        var xx = parseInt(128 * r);
        var yy = 0;
        var x = 0;
        var y = 0;

        const SetPixel = (x, y) => {
            let divx0 = Math.floor(x / lineWidth) * lineWidth;
            let divy0 = Math.floor(y / lineWidth) * lineWidth;
            let divx1 = divx0 + lineWidth - 1;
            let divy1 = divy0 + lineWidth - 1;
            for (let x = divx0; x <= divx1; x++) {
                for (let y = divy0; y <= divy1; y++) {
                    // 計算された座標がキャンバス内のみ描画する
                    if (x >= 0 && x < this.axpObj.x_size && y >= 0 && y < this.axpObj.y_size) {
                        const i = (x + y * width) * 4
                        data[i + 0] = color[0]
                        data[i + 1] = color[1]
                        data[i + 2] = color[2]
                        data[i + 3] = 255;
                    }
                }
            }
        }
        while (yy <= xx) {
            x = parseInt(xx / 128);
            y = parseInt(yy / 128);
            SetPixel(x0 + x, y0 + y);
            SetPixel(x0 - x, y0 - y);
            SetPixel(x0 - x, y0 + y);
            SetPixel(x0 + x, y0 - y);
            SetPixel(x0 + y, y0 + x);
            SetPixel(x0 - y, y0 - x);
            SetPixel(x0 - y, y0 + x);
            SetPixel(x0 + y, y0 - x);
            yy += parseInt(xx / 128);
            xx -= parseInt(yy / 128);
        }
    }
}


/***/ }),

/***/ "./src/js/pendefine/eraser.js":
/*!************************************!*\
  !*** ./src/js/pendefine/eraser.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Eraser: () => (/* binding */ Eraser)
/* harmony export */ });
/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./round.js */ "./src/js/pendefine/round.js");
// @description ペン定義：親クラス＞丸ペン＞消しゴム



// 消しゴム
class Eraser extends _round_js__WEBPACK_IMPORTED_MODULE_0__.Round {
    constructor(option) {
        super(option);
        // 値（Roundからの差分）
        this.name = this.axpObj._('@PENNAME.ERASER');
        this.type = 'eraser';
        this.size = 5;
        this.toneLevel = null;
        this.blurLevel = null;
        // 制御
        // 描画
        this.borderStyle = 'dashed';

        this.init_save();
    }
    init_brush() {
        // 合成モードと不透明度
        this.CANVAS.draw_ctx.globalCompositeOperation = 'destination-out';
        this.CANVAS.draw_ctx.globalAlpha = this.alpha / 100;
        // ブラシ
        this.CANVAS.brush_ctx.globalCompositeOperation = 'source-over';
        this.CANVAS.brush_ctx.globalAlpha = 1; // 先に不透明度100%の描画データを作成する
        this.CANVAS.brush_ctx.lineWidth = this.size;
        // トーンパターンをリセット
        this.CANVAS.brush_ctx.strokeStyle = 'black';
        this.CANVAS.brush_ctx.lineCap = this.lineCap;
        this.CANVAS.brush_ctx.lineJoin = this.lineJoin;
        //this.blur();
    }
}


/***/ }),

/***/ "./src/js/pendefine/eraser_dot.js":
/*!****************************************!*\
  !*** ./src/js/pendefine/eraser_dot.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EraserDot: () => (/* binding */ EraserDot)
/* harmony export */ });
/* harmony import */ var _dot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dot.js */ "./src/js/pendefine/dot.js");
// @description ペン定義：親クラス＞ドットペン＞角消しゴム



// 消しゴム
class EraserDot extends _dot_js__WEBPACK_IMPORTED_MODULE_0__.Dot {
    img_draw;
    constructor(option) {
        super(option);
        // 値（Dotからの差分）
        this.name = this.axpObj._('@PENNAME.SQUARE_ERASER');
        this.type = 'eraser';
        this.size = 5;
        this.blurLevel = null;
        // 制御
        // 描画
        this.borderStyle = 'dashed';

        this.init_save();
    }
    // ペンガイド表示座標
    getCursorPosition(e) {
        const pos = this.getCursorPositionNormal(e);
        return { x: pos.x, y: pos.y };
    }
    init_brush() {
        // 透明色
        this.CANVAS.draw_ctx.globalCompositeOperation = 'destination-out';
        this.CANVAS.draw_ctx.globalAlpha = this.alpha / 100;
        // ブラシ
        this.CANVAS.brush_ctx.globalCompositeOperation = 'source-over';
        this.CANVAS.brush_ctx.globalAlpha = 1; // 先に不透明度100%の描画データを作成する
        // 消しゴムは、ぼかし無し
    }
    // ドット座標に変換
    trans_dot(point) {
        // 角消しゴムは変換処理を行わない
        return point;
    }
    // 直線描画(Bresenham's line algorithm)
    drawLine(
        imageData,
        x0,
        y0,
        x1,
        y1,
        lineWidth,
        color,
    ) {
        const { width, data } = imageData;
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;

        let err = dx - dy;
        let vx = x0;
        let vy = y0;
        let old_divx0 = -1;
        let old_divy0 = -1;

        while (true) {
            // setpixel
            /*
            let divx0 = Math.trunc(vx / lineWidth) * lineWidth;
            let divy0 = Math.trunc(vy / lineWidth) * lineWidth;
            */
            let divx0 = Math.round(vx - lineWidth / 2);
            let divy0 = Math.round(vy - lineWidth / 2);
            // 計算座標が前回描画位置から変化した場合、その座標に幅lineWidthの正方形を描画
            if (divx0 !== old_divx0 || divy0 !== old_divy0) {
                let divx1 = divx0 + lineWidth - 1;
                let divy1 = divy0 + lineWidth - 1;
                for (let x = divx0; x <= divx1; x++) {
                    for (let y = divy0; y <= divy1; y++) {
                        // 計算された座標がキャンバス内のみ描画する
                        if (x >= 0 && x < this.axpObj.x_size && y >= 0 && y < this.axpObj.y_size) {
                            const i = (x + y * width) * 4
                            data[i + 0] = color[0]
                            data[i + 1] = color[1]
                            data[i + 2] = color[2]
                            data[i + 3] = 255;
                        }
                    }
                }
                // 前回描画位置の更新
                old_divx0 = divx0;
                old_divy0 = divy0;
            }
            // 終点まで走査したら終了
            if (vx === x1 && vy === y1) break;

            // 次の座標を計算
            let e2 = 2 * err;
            if (e2 > -dy) {
                err = err - dy;
                vx = vx + sx;
            }
            if (e2 < dx) {
                err = err + dx;
                vy = vy + sy;
            }
        }
    }
    // 円描画
    drawCircle(
        imageData,
        x0,
        y0,
        x1,
        y1,
        lineWidth,
        color,
    ) {
        const { width, data } = imageData;
        const r = parseInt(Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)));

        if (r <= 0) { return };

        var xx = parseInt(128 * r);
        var yy = 0;
        var x = 0;
        var y = 0;

        const SetPixel = (x, y) => {
            let divx0 = Math.floor(x / lineWidth) * lineWidth;
            let divy0 = Math.floor(y / lineWidth) * lineWidth;
            let divx1 = divx0 + lineWidth - 1;
            let divy1 = divy0 + lineWidth - 1;
            for (let x = divx0; x <= divx1; x++) {
                for (let y = divy0; y <= divy1; y++) {
                    // 計算された座標がキャンバス内のみ描画する
                    if (x >= 0 && x < this.axpObj.x_size && y >= 0 && y < this.axpObj.y_size) {
                        const i = (x + y * width) * 4
                        data[i + 0] = color[0]
                        data[i + 1] = color[1]
                        data[i + 2] = color[2]
                        data[i + 3] = 255;
                    }
                }
            }
        }
        while (yy <= xx) {
            x = parseInt(xx / 128);
            y = parseInt(yy / 128);
            SetPixel(x0 + x, y0 + y);
            SetPixel(x0 - x, y0 - y);
            SetPixel(x0 - x, y0 + y);
            SetPixel(x0 + x, y0 - y);
            SetPixel(x0 + y, y0 + x);
            SetPixel(x0 - y, y0 - x);
            SetPixel(x0 - y, y0 + x);
            SetPixel(x0 + y, y0 - x);
            yy += parseInt(xx / 128);
            xx -= parseInt(yy / 128);
        }
    }
}


/***/ }),

/***/ "./src/js/pendefine/fill.js":
/*!**********************************!*\
  !*** ./src/js/pendefine/fill.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fill: () => (/* binding */ Fill)
/* harmony export */ });
/* harmony import */ var _penobj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_penobj.js */ "./src/js/pendefine/_penobj.js");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../etc.js */ "./src/js/etc.js");
// @description ペン定義：親クラス＞バケツ




// バケツ
class Fill extends _penobj_js__WEBPACK_IMPORTED_MODULE_0__.PenObj {
    constructor(option) {
        super();
        this.axpObj = option.axpObj;
        this.CANVAS = option.CANVAS;
        // 値（PenObjからの差分）
        this.name = this.axpObj._('@PENNAME.FILL');
        this.type = 'fill';
        this.alpha = 100;
        this.threshold = 2;
        this.toneLevel = 16;
        // 制御
        this.usePenPreview = true;
        this.usePenLock = true;
        this.canUndo = true;
        // 描画
        this.borderRadius = 0;
        this.borderStyle = 'normal';
        this.lineCap = 'square';
        this.lineJoin = 'bevel';

        this.init_save();
    }
    init_brush(option) {
        // 合成モードと不透明度
        this.init_globalCompositeOperation(option);
        this.CANVAS.draw_ctx.globalAlpha = this.alpha / 100;
        // ブラシ
        this.CANVAS.brush_ctx.globalCompositeOperation = 'source-over';
        this.CANVAS.brush_ctx.globalAlpha = 1; // 先に不透明度100%の描画データを作成する
        this.CANVAS.brush_ctx.lineWidth = this.size;
        this.CANVAS.brush_ctx.strokeStyle = '';
        this.CANVAS.brush_ctx.lineCap = "round";
        this.CANVAS.brush_ctx.lineJoin = "round";
        // ぼかし無し
        //        this.blur(0);
    }
    // 描画開始
    start(x, y, e, option) {
        // 書き込み禁止状態
        if (this.axpObj.layerSystem.isWriteProtection()) {
            return;
        }
        // モード設定
        this.set_modeflag();
        this.init_brush(option);
    }
    // 描画終了
    end(x, y) {
        if (this.axpObj.isDrawing && !this.axpObj.isDrawCancel) {
            // 描画開始時のイメージ記憶
            this.axpObj.layerSystem.save();
            // 範囲外の場合は処理しない
            if ((0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.inRange)(x, 0, this.axpObj.x_size) && (0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.inRange)(y, 0, this.axpObj.y_size)) {

                var pencolor = this.getColorRGB();
                var rgbCode = [pencolor[0], pencolor[1], pencolor[2]];
                console.log('rgb:', rgbCode);

                // ◆入力画像
                var img_input;
                if (document.getElementById('axp_pen_select_fillMode').value === 'option_layer') {
                    // 判定対象：現在レイヤー
                    img_input = this.axpObj.layerSystem.getImage();
                } else {
                    // 判定対象：全レイヤー
                    img_input = this.axpObj.layerSystem.getCanvasImage();
                }

                // ◆出力画像
                var img_output = new ImageData(this.axpObj.x_size, this.axpObj.y_size);

                // 一旦、不透明度100%の領域塗りつぶし画像を作成する
                this.regionFill(
                    img_input,
                    img_output,
                    x,
                    y,
                    rgbCode
                );

                // 作成したimagedataをキャンバスに描画
                this.CANVAS.brush_ctx.putImageData(img_output, 0, 0);

                // トーン濃度使用時
                if (this.axpObj.config('axp_config_form_ToneLevel') === 'on' &&
                    this.toneLevel !== null &&
                    this.toneLevel !== 16) {
                    // トーンパターンを生成して塗り潰し
                    this.CANVAS.brush_ctx.globalCompositeOperation = 'destination-in';
                    this.CANVAS.brush_ctx.fillStyle = (0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.createTonePattern)(this.toneLevel, '#000000');
                    this.CANVAS.brush_ctx.fillRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);
                }
                this.write();
            }
        }
        this.end_common();
    }
}

// 塗りつぶし用関数（縁取り機能つき）
// ImageData:canvasのgetImageDataで取得したデータ
// x,y：現在の座標位置
// fillColor:塗りつぶし用の色
Fill.prototype.regionFill = function (img_input, img_output, x, y, fillColor) {

    let oversize = Number(document.getElementById('axp_pen_range_fillThreshold').value);

    var fillColorRGB = fillColor;
    if (x < 0 || y < 0 || x >= img_input.width || y >= img_input.height) {
        return;
    }
    var selectColorRGB = new Array(3);
    selectColorRGB[0] = img_input.data[(y * img_input.width + x) * 4 + 0];
    selectColorRGB[1] = img_input.data[(y * img_input.width + x) * 4 + 1];
    selectColorRGB[2] = img_input.data[(y * img_input.width + x) * 4 + 2];

    var selectColorAlpha = img_input.data[(y * img_input.width + x) * 4 + 3];
    var isAlpha = !selectColorAlpha;

    var pxlArr = [{ x: x, y: y }];
    var idx, p;

    // 処理済み画素フラグ
    var Processed = [];

    // 色比較用関数
    const compareColor = (ImageData, x, y, selectColorRGB, isAlpha, Processed) => {

        if (Processed[(y * ImageData.width + x)]) {
            return false;
        }

        // xやyがcanvasの域内に収まっていなければfalseを返す
        if (x < 0 || y < 0 || x >= ImageData.width || y >= ImageData.height) {
            return false;
        }

        var currentColorRGB = new Array(3);
        currentColorRGB[0] = ImageData.data[(y * ImageData.width + x) * 4 + 0];
        currentColorRGB[1] = ImageData.data[(y * ImageData.width + x) * 4 + 1];
        currentColorRGB[2] = ImageData.data[(y * ImageData.width + x) * 4 + 2];
        var currentAlpha = ImageData.data[(y * ImageData.width + x) * 4 + 3];

        if (isAlpha) {
            if (currentAlpha === 0) {
                // 現在：透明
                return true;
            } else {
                return false;
            }
        } else {
            // 開始：有色
            if (currentAlpha === 0) {
                // 現在：透明
                return false;
            } else {
                // 現在：有色
                if (currentColorRGB[0] === selectColorRGB[0] &&
                    currentColorRGB[1] === selectColorRGB[1] &&
                    currentColorRGB[2] === selectColorRGB[2]) {
                    // 同色
                    return true;
                } else {
                    // 異色
                    return false;
                }
            }
        }
    }
    const setPixel = (imageData, x, y, fillColorRGB, Processed, oversize) => {

        if (Processed[y * imageData.width + x] === true) {
            return;
        }

        if (x < 0 || y < 0 || x >= imageData.width || y >= imageData.height) {
            return;
        }
        let idx = (y * img_input.width + x) * 4;
        let alpha = 255 - (oversize - 1) * 50;

        imageData.data[idx + 0] = fillColorRGB[0];
        imageData.data[idx + 1] = fillColorRGB[1];
        imageData.data[idx + 2] = fillColorRGB[2];

        if (imageData.data[idx + 3] < alpha) {
            imageData.data[idx + 3] = alpha;
        }
    }

    var loop_count = 0;
    const LOOP_LIMIT = this.axpObj.CONST.MAX_SYSTEM_WIDTH * this.axpObj.CONST.MAX_SYSTEM_HEIGHT * 4;

    // すべての塗り潰し処理が完了するまで繰り返す
    while (pxlArr.length) {
        p = pxlArr.pop();

        if (Processed[p.y * img_input.width + p.x] === true) {
            // 処理済みの場合、座標の塗り潰しが既に完了しているため、処理しない
        } else {

            // 現在のピクセルが塗りつぶし対象に含まれるか判定
            if (compareColor(img_input, p.x, p.y, selectColorRGB, isAlpha, Processed)) {
                // 座標の画素を処理済みにする
                Processed[p.y * img_input.width + p.x] = true;

                // 出力用イメージデータに書き込む
                idx = (p.y * img_input.width + p.x) * 4;
                img_output.data[idx + 0] = fillColorRGB[0];
                img_output.data[idx + 1] = fillColorRGB[1];
                img_output.data[idx + 2] = fillColorRGB[2];
                img_output.data[idx + 3] = 255;

                // 座標の上下左右を操作して繰り返す（再起処理）
                // 上
                if (compareColor(img_input, p.x, p.y - 1, selectColorRGB, isAlpha, Processed)) {
                    pxlArr.push({ x: p.x, y: p.y - 1 });
                } else {
                    for (let i = 1; i < oversize + 1; i++) {
                        setPixel(img_output, p.x, p.y - i, fillColorRGB, Processed, i);
                    }
                }

                // 右
                if (compareColor(img_input, p.x + 1, p.y, selectColorRGB, isAlpha, Processed)) {
                    pxlArr.push({ x: p.x + 1, y: p.y });
                } else {
                    for (let i = 1; i < oversize + 1; i++) {
                        setPixel(img_output, p.x + i, p.y, fillColorRGB, Processed, i);
                    }
                }

                // 下
                if (compareColor(img_input, p.x, p.y + 1, selectColorRGB, isAlpha, Processed)) {
                    pxlArr.push({ x: p.x, y: p.y + 1 });
                } else {
                    for (let i = 1; i < oversize + 1; i++) {
                        setPixel(img_output, p.x, p.y + i, fillColorRGB, Processed, i);
                    }
                }

                // 左
                if (compareColor(img_input, p.x - 1, p.y, selectColorRGB, isAlpha, Processed)) {
                    pxlArr.push({ x: p.x - 1, y: p.y });
                } else {
                    for (let i = 1; i < oversize + 1; i++) {
                        setPixel(img_output, p.x - i, p.y, fillColorRGB, Processed, i);
                    }
                }
            }
        }

        loop_count++;

        if (loop_count > LOOP_LIMIT) {
            // 無現ループ回避（バグ検知用）
            alert('ERROR:塗り潰し中に異常が発生したため、処理を中断しました。');
            break;
        }
    }
    //console.log('塗り潰し完了 loop_count:', loop_count, 'LOOP_LIMIT:', LOOP_LIMIT);
}



/***/ }),

/***/ "./src/js/pendefine/fillgradation.js":
/*!*******************************************!*\
  !*** ./src/js/pendefine/fillgradation.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fillgradation: () => (/* binding */ Fillgradation)
/* harmony export */ });
/* harmony import */ var _fill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fill.js */ "./src/js/pendefine/fill.js");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../etc.js */ "./src/js/etc.js");
// @description ペン定義：親クラス＞バケツ＞階調バケツ




// 階調バケツ
class Fillgradation extends _fill_js__WEBPACK_IMPORTED_MODULE_0__.Fill {
    constructor(option) {
        super(option);
        // 値（Fillからの差分）
        this.name = this.axpObj._('@PENNAME.GRADATION_FILL');
        this.toneLevel = null;
        this.gradation = 0;
        // 制御
        // 描画

        this.init_save();
    }
    // ペンの太さプレビュー表示（バケツ専用）
    previewPenSize() {
        // 更新キャンバス
        let canvas = this.axpObj.penSystem.CANVAS.pensize;
        let ctx = this.axpObj.penSystem.CANVAS.pensize_ctx;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = this.alpha / 100;
        // グラデーションの表示
        let size = 80;
        let radius = 40;
        // 元の角度から270度減算し、cssのlinear-gradient()の仕様と合わせる
        let angle = this.gradation - 270;
        let x0 = size / 2;
        let y0 = size / 2;
        let dx = Math.round(radius * Math.cos(angle * (Math.PI / 180)));
        let dy = Math.round(radius * Math.sin(angle * (Math.PI / 180)));
        let x1 = x0 + dx;
        let y1 = y0 + dy;
        let x2 = x0 - dx;
        let y2 = y0 - dy;
        let lineargradient = ctx.createLinearGradient(x1, y1, x2, y2);
        //console.log('perv', x1, y1, x2, y2);
        let color1 = this.axpObj.colorMakerSystem.getMainColor();
        let color2 = this.axpObj.colorMakerSystem.getSubColor();
        //console.log(color1, color2);
        lineargradient.addColorStop(0, color1);
        lineargradient.addColorStop(1, color2);
        ctx.fillStyle = lineargradient;
        ctx.beginPath();
        ctx.fillRect(50 - size / 2, 50 - size / 2, size, size);
    }
    // 描画終了
    end(x, y) {
        if (this.axpObj.isDrawing && !this.axpObj.isDrawCancel) {
            // 描画開始時のイメージ記憶
            this.axpObj.layerSystem.save();
            // 範囲外の場合は処理しない
            if ((0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.inRange)(x, 0, this.axpObj.x_size) && (0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.inRange)(y, 0, this.axpObj.y_size)) {
                // 透明色の場合は処理しない
                if (document.getElementById('axp_makecolor_div_transparent').dataset.selected === 'true') {
                    // %1は透明色を使用できません。
                    this.axpObj.msg('@CAU0500', this.name);
                } else {
                    var rgbCode = [255, 255, 255];
                    //console.log('rgb:', rgbCode);

                    // ◆入力画像
                    var img_input;
                    if (document.getElementById('axp_pen_select_fillMode').value === 'option_layer') {
                        // 判定対象：現在レイヤー
                        img_input = this.axpObj.layerSystem.getImage();
                    } else {
                        // 判定対象：全レイヤー
                        img_input = this.axpObj.layerSystem.getCanvasImage();
                    }

                    // ◆出力画像
                    var img_output = new ImageData(this.axpObj.x_size, this.axpObj.y_size);

                    // 一旦、不透明度100%の領域塗りつぶし画像を作成する
                    this.regionFill(
                        img_input,
                        img_output,
                        x,
                        y,
                        rgbCode
                    );
                    this.CANVAS.brush_ctx.putImageData(img_output, 0, 0);

                    let rect = (0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.getRectSize)(img_output);

                    // 一時キャンバスにグラデーション作成
                    let canvas = document.createElement('canvas');
                    canvas.width = this.axpObj.x_size;
                    canvas.height = this.axpObj.y_size;
                    let ctx = canvas.getContext('2d');
                    // グラデーションの表示
                    let radius = Math.max(rect.x1 - rect.x0, rect.y1 - rect.y0) / 2;
                    // 元の角度から270度減算し、cssのlinear-gradient()の仕様と合わせる
                    let angle = this.gradation - 270;
                    let x0 = rect.x0 + (rect.x1 - rect.x0) / 2;
                    let y0 = rect.y0 + (rect.y1 - rect.y0) / 2;
                    console.log('x,y,r:', x0, y0, radius);
                    let dx = Math.round(radius * Math.cos(angle * (Math.PI / 180)));
                    let dy = Math.round(radius * Math.sin(angle * (Math.PI / 180)));
                    // グラデーション座標が描画範囲に収まるように変形
                    let x1 = x0 + dx;
                    if (x1 < rect.x0) x1 = rect.x0;
                    if (x1 > rect.x1) x1 = rect.x1;
                    let y1 = y0 + dy;
                    if (y1 < rect.y0) y1 = rect.y0;
                    if (y1 > rect.y1) y1 = rect.y1;
                    let x2 = x0 - dx;
                    if (x2 < rect.x0) x2 = rect.x0;
                    if (x2 > rect.x1) x2 = rect.x1;
                    let y2 = y0 - dy;
                    if (y2 < rect.y0) y2 = rect.y0;
                    if (y2 > rect.y1) y2 = rect.y1;
                    console.log('draw', x1, y1, x2, y2);
                    let lineargradient = ctx.createLinearGradient(x1, y1, x2, y2);

                    lineargradient.addColorStop(0, this.axpObj.colorMakerSystem.getMainColor());
                    lineargradient.addColorStop(1, this.axpObj.colorMakerSystem.getSubColor());
                    ctx.fillStyle = lineargradient;
                    ctx.beginPath();
                    ctx.fillRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);

                    // バケツ領域で型抜き
                    this.CANVAS.brush_ctx.globalCompositeOperation = 'source-in';
                    this.CANVAS.brush_ctx.drawImage(canvas, 0, 0);

                    // 透明度を適用して、元画像と合成する
                    this.CANVAS.draw_ctx.putImageData(this.axpObj.layerSystem.load(), 0, 0);
                    this.CANVAS.draw_ctx.drawImage(this.CANVAS.brush, 0, 0);

                    // レイヤー更新
                    this.axpObj.layerSystem.write(
                        this.CANVAS.draw_ctx.getImageData(0, 0, this.axpObj.x_size, this.axpObj.y_size)
                    );
                    this.axpObj.layerSystem.updateCanvas();
                }
            }
        }
        this.end_common();
    }
}


/***/ }),

/***/ "./src/js/pendefine/fude.js":
/*!**********************************!*\
  !*** ./src/js/pendefine/fude.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fude: () => (/* binding */ Fude)
/* harmony export */ });
/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./round.js */ "./src/js/pendefine/round.js");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../etc.js */ "./src/js/etc.js");
// @description ペン定義：親クラス＞丸ペン＞筆ペン




// 筆ペン
class Fude extends _round_js__WEBPACK_IMPORTED_MODULE_0__.Round {
    constructor(option) {
        super(option);
        // 値（PenObjからの差分）
        this.name = this.axpObj._('@PENNAME.CALLIGRAPHY');
        this.size = 5;
        this.toneLevel = null;
        // 制御
        this.usePenStyle = false;
        // 描画

        this.init_save();
    }
    start_draw() {
        // 筆用サイズ調整
        this.CANVAS.brush_ctx.lineWidth = this.size / 2;
    }
    // 描画中
    move(x, y) {
        // 描画継続中
        if (this.axpObj.isDrawing && !this.axpObj.isDrawCancel) {
            // 描画確定済み
            this.axpObj.isDrawn = true;
            // 入力座標の記憶
            this.input_position.push({ x, y });
            // 描画
            this.draw();
        }
    }
    draw() {
        // 筆の場合ブラシエリアを初期化しない
        let old_x = this.input_position[this.input_position.length - 2].x;
        let old_y = this.input_position[this.input_position.length - 2].y;
        let x = this.input_position[this.input_position.length - 1].x;
        let y = this.input_position[this.input_position.length - 1].y;
        // 前回の位置からの距離を、太さ変動の判定に使用する
        const distance = (0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.calcDistance)(
            old_x,
            old_y,
            x,
            y
        )
        let width = this.CANVAS.brush_ctx.lineWidth;
        //console.log(distance, width);
        if (distance * 1.4 > this.size) {
            // 描画距離が大きい場合、ペンの太さを減衰させながら線を引く

            // 線分の分割数
            let division = parseInt(distance * 1.4 / this.size) * 2;
            // 増分
            let ax = (x - old_x) / division;
            let ay = (y - old_y) / division;

            for (let i = 0; i < division; i++) {
                width = width * 0.9;
                width = Math.max(Math.min(this.size, width), 1); // ペンの太さの範囲内に補正
                this.CANVAS.brush_ctx.lineWidth = width;
                this.CANVAS.brush_ctx.beginPath();
                this.CANVAS.brush_ctx.moveTo(old_x + ax * i, old_y + ay * i);
                this.CANVAS.brush_ctx.lineTo(old_x + ax * (i + 1), old_y + ay * (i + 1));
                this.CANVAS.brush_ctx.stroke();
                this.CANVAS.brush_ctx.closePath();
            }

        } else {
            // 描画距離が小さい場合、ペンの太さを増加させて線を引く
            width = this.CANVAS.brush_ctx.lineWidth + this.size * 0.03;
            width = Math.max(Math.min(this.size, width), 1); // ペンの太さの範囲内に補正
            this.CANVAS.brush_ctx.lineWidth = width;
            this.CANVAS.brush_ctx.beginPath();
            this.CANVAS.brush_ctx.moveTo(old_x, old_y);
            this.CANVAS.brush_ctx.lineTo(x, y);
            this.CANVAS.brush_ctx.stroke();
            this.CANVAS.brush_ctx.closePath();
        }
        this.write();
    }
}

/***/ }),

/***/ "./src/js/pendefine/hand.js":
/*!**********************************!*\
  !*** ./src/js/pendefine/hand.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hand: () => (/* binding */ Hand)
/* harmony export */ });
/* harmony import */ var _penobj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_penobj.js */ "./src/js/pendefine/_penobj.js");
// @description ペン定義：親クラス＞ハンドツール



// ハンド
class Hand extends _penobj_js__WEBPACK_IMPORTED_MODULE_0__.PenObj {
    constructor(option) {
        super();
        this.axpObj = option.axpObj;
        this.CANVAS = option.CANVAS;
        // 値（PenObjからの差分）
        this.name = this.axpObj._('@PENNAME.HAND');
        this.type = 'hand';
        this.cursor = 'grab';
        // 制御

        this.init_save();
    }
    // 描画開始
    start(x, y, e) {
        //console.log('hand');
        this.axpObj.isDrawing = true;
        this.axpObj.isDrawCancel = false;
        // 初期カメラ位置記憶
        this.baseCameraX = this.axpObj.cameraX;
        this.baseCameraY = this.axpObj.cameraY;
        // 初期入力座標
        this.baseInputX = e.clientX;
        this.baseInputY = e.clientY;
    }
    // 描画開始
    move(x, y, e) {
        if (this.axpObj.isDrawing && !this.axpObj.isDrawCancel) {
            // カメラ位置移動
            const diffX = this.baseInputX - e.clientX;
            const diffY = this.baseInputY - e.clientY;
            this.axpObj.cameraX = Math.round(this.baseCameraX + (diffX * 100 / this.axpObj.scale));
            this.axpObj.cameraY = Math.round(this.baseCameraY + (diffY * 100 / this.axpObj.scale));
            this.axpObj.refreshCanvas();
        }
    }
    // 描画終了
    end() {
        if (this.axpObj.isDrawing) {
            this.axpObj.isDrawing = false;
            this.axpObj.isDrawCancel = false;
        }
    }
}

/***/ }),

/***/ "./src/js/pendefine/move.js":
/*!**********************************!*\
  !*** ./src/js/pendefine/move.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Move: () => (/* binding */ Move)
/* harmony export */ });
/* harmony import */ var _penobj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_penobj.js */ "./src/js/pendefine/_penobj.js");
// @description ペン定義：親クラス＞移動ツール



// 移動ツール
class Move extends _penobj_js__WEBPACK_IMPORTED_MODULE_0__.PenObj {
    constructor(option) {
        super();
        this.axpObj = option.axpObj;
        this.CANVAS = option.CANVAS;
        // 値（PenObjからの差分）
        this.name = this.axpObj._('@PENNAME.MOVE_TOOL');
        this.type = 'move';
        this.cursor = 'move';
        // 制御
        this.usePenLock = true;
        this.canUndo = true;

        this.init_save();
    }
    // 描画開始
    start(x, y) {
        // 書き込み禁止状態
        if (this.axpObj.layerSystem.isWriteProtection()) {
            return;
        }
        // モード設定
        this.set_modeflag();

        // 入力座標の記憶
        this.input_position = [];
        this.input_position.push({ x, y });

        // 描画開始時のイメージ記憶
        this.axpObj.layerSystem.save();
    }
    // 描画中
    move(x, y) {
        // 描画継続中
        if (this.axpObj.isDrawing && !this.axpObj.isDrawCancel) {
            // 描画確定済み
            this.axpObj.isDrawn = true;
            // 入力座標の記憶
            this.input_position.push({ x, y });
            // 描画
            this.draw();
        }
    }
    // 描画
    draw() {
        let firstPoint = this.input_position[0];
        let currentPoint = this.input_position[this.input_position.length - 1];

        // 表示領域をクリア
        this.CANVAS.draw_ctx.clearRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);
        // 移動した座標にイメージコピー
        this.CANVAS.draw_ctx.putImageData(
            this.axpObj.layerSystem.load(),
            currentPoint.x - firstPoint.x,
            currentPoint.y - firstPoint.y,
        );
        // レイヤー更新
        this.axpObj.layerSystem.write(
            this.CANVAS.draw_ctx.getImageData(0, 0, this.axpObj.x_size, this.axpObj.y_size)
        );
        this.axpObj.layerSystem.updateCanvas();
    }
    // 描画終了
    end(x, y) {
        if (this.axpObj.isDrawing && !this.axpObj.isDrawCancel) {
            // 入力座標の記憶
            this.input_position.push({ x, y });
            // 描画
            this.draw();
        }
        this.end_common();
    }
}

/***/ }),

/***/ "./src/js/pendefine/rangeindex.js":
/*!****************************************!*\
  !*** ./src/js/pendefine/rangeindex.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   range_index: () => (/* binding */ range_index),
/* harmony export */   range_value: () => (/* binding */ range_value)
/* harmony export */ });
// @description ペンの太さスライダー用変換テーブル

const range_value = [
    0, 1, 1, 1, 1, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 6, 6, 6, 6, 7, 7, 7,
    7, 8, 8, 8, 8, 9, 9, 9, 9, 10,
    10, 10, 10, 11, 11, 12, 12, 13, 13, 14,
    14, 15, 15, 16, 16, 17, 17, 18, 18, 19,
    19, 20, 20, 21, 22, 23, 24, 25, 26, 27,
    28, 29, 30, 31, 32, 33, 34, 35, 40, 45,
    50, 55, 60, 65, 70, 75, 80, 85, 90, 95,
    100, 110, 120, 130, 140, 150, 160, 170, 180, 190,
    200
];
// ペンの太さに対応するインデックスを返却する
const range_index = function (value) {
    var result = 0;
    for (var idx = 0; idx < range_value.length; idx++) {
        if (range_value[idx] === value) {
            result = idx;
            break;
        }
        if (range_value[idx] > value) {
            break;
        }
        result = idx;
    }
    return result;
};

/***/ }),

/***/ "./src/js/pendefine/round.js":
/*!***********************************!*\
  !*** ./src/js/pendefine/round.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Round: () => (/* binding */ Round)
/* harmony export */ });
/* harmony import */ var _penobj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_penobj.js */ "./src/js/pendefine/_penobj.js");
/* harmony import */ var _rangeindex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rangeindex.js */ "./src/js/pendefine/rangeindex.js");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../etc.js */ "./src/js/etc.js");
// @description ペン定義：親クラス＞丸ペン





// 丸ペン
class Round extends _penobj_js__WEBPACK_IMPORTED_MODULE_0__.PenObj {
    constructor(option) {
        super();
        this.axpObj = option.axpObj;
        this.CANVAS = option.CANVAS;
        // 値（PenObjからの差分）
        this.name = this.axpObj._('@PENNAME.ROUND');
        this.type = 'draw';
        this.size = 1;
        this.index = (0,_rangeindex_js__WEBPACK_IMPORTED_MODULE_1__.range_index)(this.size);
        this.alpha = 100;
        this.toneLevel = 16;
        this.blurLevel = 0;
        // 制御
        this.usePenGuide = true;
        this.usePenPreview = true;
        this.usePenLock = true;
        this.usePenStyle = true;
        this.canUndo = true;
        // 描画
        this.borderRadius = 50;
        this.borderStyle = 'normal';
        this.lineCap = 'round';
        this.lineJoin = 'round';

        this.init_save();
    }

    init_brush(option) {
        // 合成モードと不透明度
        this.init_globalCompositeOperation(option);
        this.CANVAS.draw_ctx.globalAlpha = this.alpha / 100;
        // ブラシ
        this.CANVAS.brush_ctx.globalCompositeOperation = 'source-over';
        this.CANVAS.brush_ctx.globalAlpha = 1; // 先に不透明度100%の描画データを作成する
        this.CANVAS.brush_ctx.lineWidth = this.size - 0.25;
        if (this.axpObj.config('axp_config_form_ToneLevel') === 'on' &&
            this.toneLevel !== null &&
            this.toneLevel !== 16) {
            // トーン濃度使用時トーンパターン生成して色指定
            this.CANVAS.brush_ctx.strokeStyle = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.createTonePattern)(this.toneLevel, this.getColor());
        } else {
            // 通常時の色指定
            this.CANVAS.brush_ctx.strokeStyle = this.getColor();
        }
        this.CANVAS.brush_ctx.lineCap = this.lineCap;
        this.CANVAS.brush_ctx.lineJoin = this.lineJoin;
        this.CANVAS.brush_ctx.clearRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);
        this.blur();
    }
    // 描画開始
    start(x, y, e, option) {
        // 書き込み禁止状態
        if (this.axpObj.layerSystem.isWriteProtection()) {
            return;
        }
        // モード設定
        this.set_modeflag();

        // 入力座標の記憶
        this.input_position = [];
        this.input_position.push({ x, y });

        //console.log(this.input_position[0]);

        // 描画開始時のイメージ記憶
        this.axpObj.layerSystem.save();

        this.init_brush(option);
        this.start_draw(x, y);
    }
    start_draw(x, y) {
        this.CANVAS.brush_ctx.beginPath();
        this.CANVAS.brush_ctx.moveTo(x, y);
    }
    // 描画中
    move(x, y) {
        // 描画継続中
        if (this.axpObj.isDrawing && !this.axpObj.isDrawCancel) {
            // 描画確定済み
            this.axpObj.isDrawn = true;
            // 入力座標の記憶
            this.input_position.push({ x, y });
            // 線の描画
            this.draw();
        }
    }
    // 線の描画
    draw() {
        // 描画領域の初期化
        this.CANVAS.brush_ctx.globalCompositeOperation = 'source-over';
        this.CANVAS.brush_ctx.clearRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);

        let firstPoint = this.input_position[0];
        let lastPoint = this.input_position[this.input_position.length - 2];
        let currentPoint = this.input_position[this.input_position.length - 1];
        let midPoint = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.calcMidPointBetween)(lastPoint, currentPoint);

        switch (this.drawmode) {
            case this.axpObj.CONST.DRAW_FREEHAND: {
                let isStabilizer = false;
                const stabilizer_value = Number(document.getElementById('axp_config_form_stabilizerValue').volume.value);
                if (stabilizer_value !== 0) {
                    if (this.axpObj.isLine || this.isLastDrawing) {
                        // 終点の描画、または直線モードの時は手ぶれ補正しない
                    } else {
                        // 手ぶれ補正あり
                        isStabilizer = true;
                    }
                }
                // 直線モードの場合、始点を最初の入力座標にする
                if (this.axpObj.isLine) {
                    this.CANVAS.brush_ctx.beginPath();
                    this.CANVAS.brush_ctx.moveTo(
                        firstPoint.x,
                        firstPoint.y
                    );
                }
                if (isStabilizer) {
                    // 手ぶれ補正
                    // 2次ベジェ曲線（前回の入力座標を制御点とし、入力から計算した終点までの曲線を描く）
                    this.CANVAS.brush_ctx.quadraticCurveTo(
                        lastPoint.x,
                        lastPoint.y,
                        midPoint.x,
                        midPoint.y,
                    );
                } else {
                    // 補正なし
                    this.CANVAS.brush_ctx.lineTo(
                        currentPoint.x,
                        currentPoint.y
                    );
                }
                break;
            }
            case this.axpObj.CONST.DRAW_RECT:
                this.CANVAS.brush_ctx.strokeRect(
                    firstPoint.x,
                    firstPoint.y,
                    currentPoint.x - firstPoint.x,
                    currentPoint.y - firstPoint.y
                );
                break;
            case this.axpObj.CONST.DRAW_CIRCLE: {
                const r = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.calcDistance)(
                    firstPoint.x,
                    firstPoint.y,
                    currentPoint.x,
                    currentPoint.y
                );
                this.CANVAS.brush_ctx.beginPath();
                this.CANVAS.brush_ctx.arc(
                    firstPoint.x,
                    firstPoint.y,
                    r,
                    0,
                    Math.PI * 2,
                    true
                );
                break;
            }
        }
        this.CANVAS.brush_ctx.stroke();
        this.write();
    }
    // 描画終了
    end(x, y) {
        if (this.axpObj.isDrawing && !this.axpObj.isDrawCancel) {
            this.isLastDrawing = true;
            // 入力座標の記憶
            this.input_position.push({ x, y });
            // 線の描画
            this.draw();
        }
        this.end_common();
    }
}


/***/ }),

/***/ "./src/js/pendefine/spuit.js":
/*!***********************************!*\
  !*** ./src/js/pendefine/spuit.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Spuit: () => (/* binding */ Spuit)
/* harmony export */ });
/* harmony import */ var _penobj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_penobj.js */ "./src/js/pendefine/_penobj.js");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../etc.js */ "./src/js/etc.js");
// @description ペン定義：親クラス＞スポイト




// スポイト
class Spuit extends _penobj_js__WEBPACK_IMPORTED_MODULE_0__.PenObj {
    constructor(option) {
        super();
        this.axpObj = option.axpObj;
        this.CANVAS = option.CANVAS;
        // 値（PenObjからの差分）
        this.name = this.axpObj._('@PENNAME.EYEDROPPER');
        this.type = 'spuit';
        this.cursor = 'crosshair';
        // 制御
        this.usePenPreview = true;

        this.init_save();
    }
    // ペンの太さプレビュー表示（スポイト専用）
    previewPenSize() {
        // ここでは赤枠だけ表示する
        // 更新キャンバス
        let canvas = this.axpObj.penSystem.CANVAS.pensize;
        let ctx = this.axpObj.penSystem.CANVAS.pensize_ctx;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
        // 赤枠の表示
        ctx.beginPath();
        ctx.strokeStyle = '#FF0000';
        ctx.lineWidth = 3;
        ctx.strokeRect(40, 40, 20, 20);
    }
    // 描画開始
    start(x, y, e) {
        // キャンバス内
        if (e.target.id === this.axpObj.CANVAS.main.id) {
            this.axpObj.isDrawing = true;
            this.axpObj.isDrawCancel = false;
            this.axpObj.penSystem.spuit(e);
        }
    }
    // 描画中
    move(x, y, e) {
        // スポイト使用中
        if (this.axpObj.isDrawing && !this.axpObj.isDrawCancel) {
            // スポイト処理
            this.axpObj.penSystem.spuit(e);
        }

        const canvas = this.CANVAS.spuit;
        const ctx = this.CANVAS.spuit_ctx;
        // スポイトプレビュー用キャンバスのクリア
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ポインタ座標がプレビュー表示範囲内なら、ポインタ周囲の画像を拡大表示する
        if ((0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.inRange)(x, -2, this.axpObj.x_size - 1 + 2) && (0,_etc_js__WEBPACK_IMPORTED_MODULE_1__.inRange)(y, -2, this.axpObj.y_size - 1 + 2)) {
            // sx0,sy0:取り出す矩形の左上座標
            const sx0 = Math.max(x - 2, 0);
            const sy0 = Math.max(y - 2, 0);
            // sx1,sy1:取り出す矩形の右下座標
            const sx1 = Math.min(x + 2, this.axpObj.x_size - 1);
            const sy1 = Math.min(y + 2, this.axpObj.y_size - 1);
            // sw,sh:取り出す矩形の幅と高さ
            const sw = sx1 - sx0 + 1;
            const sh = sy1 - sy0 + 1;

            // 座標の周囲を読み取る（ポインタ座標がキャンバスをはみ出さない場合、通常は５ドット）
            const imagedata = this.axpObj.CANVAS.main_ctx.getImageData(sx0, sy0, sw, sh);

            // dx,dy:描画先キャンバスに画像データを配置する座標
            const dx = sx0 - (x - 2);
            const dy = sy0 - (y - 2);
            // 拡大イメージをプレビュー表示
            ctx.putImageData(imagedata, dx, dy);

            /*
            console.log('x,y:', x, y);
            console.log('sx0,sy0:', sx0, sy0);
            console.log('sx1,sy1:', sx1, sy1);
            console.log('sw,sh:', sw, sh);
            console.log('dx,dy:', dx, dy);
            */
        }

        let r = '-';
        let g = '-';
        let b = '-';
        let a = '-';
        // キャンバス内なら色情報取得
        if (e.target.id === this.axpObj.CANVAS.main.id) {
            // 座標のドットを読み取る
            const imagedataSpuitPonit = this.axpObj.CANVAS.main_ctx.getImageData(x, y, 1, 1);
            // RGBAの取得
            r = imagedataSpuitPonit.data[0];
            g = imagedataSpuitPonit.data[1];
            b = imagedataSpuitPonit.data[2];
            // 背景透過時はアルファチャンネルも表示する
            if (this.axpObj.assistToolSystem.getIsTransparent()) {
                a = imagedataSpuitPonit.data[3];
            }
        }
        // 色情報表示
        document.getElementById('axp_pen_span_spuitColorRed').textContent = r;
        document.getElementById('axp_pen_span_spuitColorGreen').textContent = g;
        document.getElementById('axp_pen_span_spuitColorBlue').textContent = b;
        document.getElementById('axp_pen_span_spuitColorAlpha').textContent = a;
    }
    // 描画終了
    end() {
        if (this.axpObj.isDrawing) {
            this.axpObj.isDrawing = false;
            this.axpObj.isDrawCancel = false;
            this.axpObj.penSystem.autoChangePen();
        }
    }
}


/***/ }),

/***/ "./src/js/pendefine/square.js":
/*!************************************!*\
  !*** ./src/js/pendefine/square.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Square: () => (/* binding */ Square)
/* harmony export */ });
/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./round.js */ "./src/js/pendefine/round.js");
// @description ペン定義：親クラス＞丸ペン＞角ペン



// 角ペン
class Square extends _round_js__WEBPACK_IMPORTED_MODULE_0__.Round {
    constructor(option) {
        super(option);
        // 値（Roundからの差分）
        this.name = this.axpObj._('@PENNAME.SQUARE');
        this.size = 8;
        // 制御
        // 描画
        this.borderRadius = 0;
        this.borderStyle = 'normal';
        this.lineCap = 'square';
        this.lineJoin = 'bevel';

        this.init_save();
    }
}

/***/ }),

/***/ "./src/js/post.js":
/*!************************!*\
  !*** ./src/js/post.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PostSystem: () => (/* binding */ PostSystem)
/* harmony export */ });
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./etc.js */ "./src/js/etc.js");
/* harmony import */ var _html_post_txt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../html/post.txt */ "./src/html/post.txt");
// @description 投稿処理



// css適用
__webpack_require__(/*! ../css/post.css */ "./src/css/post.css");

// 設定機能制御オブジェクト
class PostSystem {
    axpObj;
    // 投稿メニューのサムネイル表示のサイズ
    CONST = {
        X_POST_MAX: 120,
        Y_POST_MAX: 120,
    }
    CANVAS = {
        post: null,
        post_ctx: null,
        thumbnail: null,
        thumbnail_ctx: null,
    }
    constructor(axpObj) {
        this.axpObj = axpObj;
    }
    // 初期化
    init() {
        // HTML
        let targetElement = document.getElementById('axp_post');
        targetElement.insertAdjacentHTML('afterbegin', this.axpObj.translateHTML(_html_post_txt__WEBPACK_IMPORTED_MODULE_1__));
        // CANVAS
        this.CANVAS.post = document.getElementById('axp_post_canvas_postingImage');
        this.CANVAS.post_ctx = this.CANVAS.post.getContext('2d');
        this.CANVAS.thumbnail = document.getElementById('axp_post_canvas_thumbnail');
        this.CANVAS.thumbnail_ctx = this.CANVAS.thumbnail.getContext('2d');
    }
    resetCanvas() {
        // キャンバスサイズの表示
        let x = this.axpObj.x_size;
        let y = this.axpObj.y_size;

        // 投稿キャンバス
        this.CANVAS.post.width = x;
        this.CANVAS.post.height = y;
        this.CANVAS.post_ctx.clearRect(0, 0, x, y);

        let thumbnail_x;
        let thumbnail_y;
        // 投稿キャンバス サムネイル
        if (x > 120 || y > 120) {
            // 縮小率を計算してキャンバスサイズに反映
            const sc = this.CONST.X_POST_MAX / Math.max(x, y);
            thumbnail_x = Math.round(x * sc);
            thumbnail_y = Math.round(y * sc);
        } else {
            thumbnail_x = x;
            thumbnail_y = y;
        }
        this.CANVAS.thumbnail.width = thumbnail_x;
        this.CANVAS.thumbnail.height = thumbnail_y;
        this.CANVAS.thumbnail_ctx.clearRect(0, 0, thumbnail_x, thumbnail_y);

        // キャンバスサイズの表示
        document.getElementById('axp_post_span_imageSize').textContent = `${this.axpObj._('@COMMON.WIDTH')}:${x} ${this.axpObj._('@COMMON.HEIGHT')}:${y}`;
    }
    startEvent() {
        // 投稿フォームのカスタマイズ
        // 投稿フォーム
        if (!this.axpObj.postForm.input.isDisplay) {
            _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide('axp_post_div_input');
            // 入力必須の無効化
            this.axpObj.postForm.input.strName.isInputRequired = false;
            this.axpObj.postForm.input.strTitle.isInputRequired = false;
            this.axpObj.postForm.input.strMessage.isInputRequired = false;
        } else {
            // 投稿者名
            if (!this.axpObj.postForm.input.strName.isDisplay) {
                _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide(document.querySelector('.axpc_post_name_property'));
                _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide('axp_post_text_name');
                this.axpObj.postForm.input.strName.isInputRequired = false;
            } else {
                // 最大文字数設定
                document.getElementById('axp_post_text_name').maxLength = this.axpObj.postForm.input.strName.maxLength;
                // プレースホルダー設定
                document.getElementById('axp_post_text_name').placeholder = this.axpObj.postForm.input.strName.placeholder;
                // 必須の文字表示
                if (this.axpObj.postForm.input.strName.isInputRequired) {
                    _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.show(document.querySelector('.axpc_post_name_required'));
                }
            }
            // タイトル
            if (!this.axpObj.postForm.input.strTitle.isDisplay) {
                _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide(document.querySelector('.axpc_post_title_property'));
                _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide('axp_post_text_title');
                this.axpObj.postForm.input.strTitle.isInputRequired = false;
            } else {
                // 最大文字数設定
                document.getElementById('axp_post_text_title').maxLength = this.axpObj.postForm.input.strTitle.maxLength;
                // プレースホルダー設定
                document.getElementById('axp_post_text_title').placeholder = this.axpObj.postForm.input.strTitle.placeholder;
                // 必須の文字表示
                if (this.axpObj.postForm.input.strTitle.isInputRequired) {
                    _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.show(document.querySelector('.axpc_post_title_required'));
                }
            }
            // 本文
            if (!this.axpObj.postForm.input.strMessage.isDisplay) {
                _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide(document.querySelector('.axpc_post_message_property'));
                _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide('axp_post_textarea_message');
                this.axpObj.postForm.input.strMessage.isInputRequired = false;
            } else {
                // 最大文字数設定
                document.getElementById('axp_post_textarea_message').maxLength = this.axpObj.postForm.input.strMessage.maxLength;
                // プレースホルダー設定
                document.getElementById('axp_post_textarea_message').placeholder = this.axpObj.postForm.input.strMessage.placeholder;
                // 必須の文字表示
                if (this.axpObj.postForm.input.strMessage.isInputRequired) {
                    _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.show(document.querySelector('.axpc_post_message_required'));
                }
            }
            // ウォッチリスト登録
            if (!this.axpObj.postForm.input.strWatchList.isDisplay) {
                _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide(document.querySelector('.axpc_post_watchList'));
            }
        }
        // 注意事項
        if (!this.axpObj.postForm.notice.isDisplay) {
            _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide('axp_post_div_notice');
        }

        // 透過
        let input_transparent = document.querySelectorAll("input[name=axp_post_radio_bg]");
        for (let element of input_transparent) {
            element.onchange = () => {
                this.axpObj.assistToolSystem.transparent();
                this.axpObj.drawPostCanvas();
            }
        }
        document.getElementById('axp_post_text_title').oninput = (e) => {
            let text = e.target.value;
            document.getElementById('axp_post_div_thumbnailTitle').textContent = text;
        }

        document.getElementById('axp_post_text_title').oninput = (e) => {
            let text = e.target.value;
            document.getElementById('axp_post_div_thumbnailTitle').textContent = text;
        }
        // ボタン：お絵カキコする！
        document.getElementById("axp_post_button_upload").onclick = () => {

            // 入力必須項目のチェック（起動オプションで必須項目に指定されている場合、一文字以上入力されていなければ処理を中断してメッセージを表示する）
            // 投稿者名
            if (this.axpObj.postForm.input.strName.isInputRequired) {
                if (document.getElementById('axp_post_text_name').value.trim().length < 1) {
                    document.getElementById('axp_post_span_message').textContent = `${this.axpObj._('@POST.INFO_REQUIRED')} ( ${this.axpObj._('@POST.NAME')} )`;
                    return;
                }
            }
            // タイトル
            if (this.axpObj.postForm.input.strTitle.isInputRequired) {
                if (document.getElementById('axp_post_text_title').value.trim().length < 1) {
                    document.getElementById('axp_post_span_message').textContent = `${this.axpObj._('@POST.INFO_REQUIRED')} ( ${this.axpObj._('@POST.TITLE')} )`;
                    return;
                }
            }
            // 本文
            if (this.axpObj.postForm.input.strMessage.isInputRequired) {
                if (document.getElementById('axp_post_textarea_message').value.trim().length < 1) {
                    document.getElementById('axp_post_span_message').textContent = `${this.axpObj._('@POST.INFO_REQUIRED')} ( ${this.axpObj._('@POST.MESSAGE')} )`;
                    return;
                }
            }

            // ボタン表示変更（投稿中）
            _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide('axp_post_button_upload_label');
            _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.show('axp_post_button_upload_loading');
            document.getElementById("axp_post_button_upload").disabled = true;

            // 長さのチェックはユーザー側が任意で行う仕様とする（AXNOS Paint側では行わない）
            // 画像のURLエンコーディング
            let strEncodeImg = this.CANVAS.post.toDataURL('image/png');

            // 送信用にヘッダ部分を削除
            strEncodeImg = strEncodeImg.replace('data:image/png;base64,', '');

            // 送信データオブジェクト
            let objPostData = {
                strName: document.getElementById('axp_post_text_name').value.trim(),
                strTitle: document.getElementById('axp_post_text_title').value.trim(),
                strMessage: document.getElementById('axp_post_textarea_message').value.trim(),
                strWatchList: (document.getElementById('axp_post_checkbox_watchList').checked) ? 't' : '',
                oekaki_id: this.axpObj.oekaki_id,
                draftImageFile: this.axpObj.draftImageFile,
                strEncodeImg: strEncodeImg,
            };

            (async () => {
                let result;
                try {
                    // 外部で定義された投稿用スクリプトを呼び出す
                    result = await this.axpObj.FUNCTION.post(objPostData);
                    if (result) {
                        console.log('お絵カキコ投稿情報送信');
                    }
                } catch (error) {
                    console.log('error:', error);
                } finally {
                    // ボタン表示変更（初期化）
                    _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.show('axp_post_button_upload_label');
                    _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide('axp_post_button_upload_loading');
                    document.getElementById("axp_post_button_upload").disabled = false;
                }
            })();
        }

        // ボタンラベル初期設定
        document.getElementById('axp_post_button_upload_label').textContent = this.axpObj._('@POST.BUTTON_SUBMIT');
    }
}

/***/ }),

/***/ "./src/js/reinvented-color-wheel.js":
/*!******************************************!*\
  !*** ./src/js/reinvented-color-wheel.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReinventedColorWheel)
/* harmony export */ });
// @description カラーピッカー（改変あり）
// reinvented-color-wheel (WTFPL license) (https://github.com/luncheon/reinvented-color-wheel)

var ReinventedColorWheel = (function () {
    'use strict';

    function hsl2hsv(hsl) {
        var h = hsl[0],
            s = hsl[1] / 100,
            l = hsl[2] / 100,
            sv, v;

        if (l === 0) {
            // no need to do calc on black
            // also avoids divide by 0 error
            return [0, 0, 0];
        }

        l *= 2;
        s *= (l <= 1) ? l : 2 - l;
        v = (l + s) / 2;
        sv = (2 * s) / (l + s);
        return [h, sv * 100, v * 100];
    }

    var hsl2hsv_1 = hsl2hsv;

    function hsv2hsl(hsv) {
        var h = hsv[0],
            s = hsv[1] / 100,
            v = hsv[2] / 100,
            sl, l;

        l = (2 - s) * v;
        sl = s * v;
        sl /= (l <= 1) ? l : 2 - l;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
    }

    var hsv2hsl_1 = hsv2hsl;

    // http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
    function rgb2hsv(rgb) {
        var r = rgb[0];
        var g = rgb[1];
        var b = rgb[2];
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var delta = max - min;
        var h = delta && 60 * (max === r ? (g - b) / delta % 6 :
            max === g ? (b - r) / delta + 2 :
                (r - g) / delta + 4);
        return [
            h < 0 ? h + 360 : h,
            max && delta * 100 / max,
            max * 100 / 255,
        ];
    }

    // http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
    function hsv2rgb(hsv) {
        var h = hsv[0] / 60;
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var c = v * s;
        var x = c * (1 - Math.abs(h % 2 - 1));
        var m = v - c;
        var _x = (x + m) * 255 + .5 | 0;
        var _c = (c + m) * 255 + .5 | 0;
        var _0 = m * 255 + .5 | 0;
        var _h = h | 0;
        return (_h === 1 ? [_x, _c, _0] :
            _h === 2 ? [_0, _c, _x] :
                _h === 3 ? [_0, _x, _c] :
                    _h === 4 ? [_x, _0, _c] :
                        _h === 5 ? [_c, _0, _x] :
                            [_c, _x, _0]);
    }

    function clamp$1(val, min, max) {
        return Math.min(Math.max(val, min), max);
    }

    var clamp_1 = clamp$1;

    var clamp = clamp_1;

    function componentToHex(c) {
        var value = Math.round(clamp(c, 0, 255));
        var hex = value.toString(16);

        return hex.length == 1 ? "0" + hex : hex;
    }

    function rgb2hex(rgb) {
        var alpha = rgb.length === 4 ? componentToHex(rgb[3] * 255) : "";

        return "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]) + alpha;
    }

    var rgb2hex_1 = rgb2hex;

    function expand(hex) {
        var result = "#";

        for (var i = 1; i < hex.length; i++) {
            var val = hex.charAt(i);
            result += val + val;
        }

        return result;
    }

    function hex(hex) {
        // #RGB or #RGBA
        if (hex.length === 4 || hex.length === 5) {
            hex = expand(hex);
        }

        var rgb = [
            parseInt(hex.substring(1, 3), 16),
            parseInt(hex.substring(3, 5), 16),
            parseInt(hex.substring(5, 7), 16)
        ];

        // #RRGGBBAA
        if (hex.length === 9) {
            var alpha = parseFloat((parseInt(hex.substring(7, 9), 16) / 255).toFixed(2));
            rgb.push(alpha);
        }

        return rgb;
    }

    var hex_1 = hex;

    function normalizeHsvOrDefault(hsv, defaultHsvOrHsl) {
        if (hsv) {
            return [
                isFiniteNumber(hsv[0]) ? normalizeHue(hsv[0]) : defaultHsvOrHsl[0],
                isFiniteNumber(hsv[1]) ? normalizePercentage(hsv[1]) : defaultHsvOrHsl[1],
                isFiniteNumber(hsv[2]) ? normalizePercentage(hsv[2]) : defaultHsvOrHsl[2],
            ];
        }
        else {
            return defaultHsvOrHsl;
        }
    }
    function normalizeHsl(hsl) {
        return [
            normalizeHue(hsl[0]),
            normalizePercentage(hsl[1]),
            normalizePercentage(hsl[2]),
        ];
    }
    function normalizeHue(value) {
        var modulo = Math.round(value % 360 * 10) / 10;
        return modulo < 0 ? modulo + 360 : modulo;
    }
    function normalizePercentage(value) {
        return value < 0 ? 0 : value > 100 ? 100 : (value * 10 + .5 | 0) / 10;
    }
    function isFiniteNumber(n) {
        return typeof n === 'number' && isFinite(n);
    }

    var window = (typeof globalThis !== 'undefined' ? globalThis : self);

    var onDrag =
        // for IE, Edge, Firefox, Chrome
        'PointerEvent' in window ?
            function (element, onDragStart, onDragMove) {
                element.addEventListener('pointerdown', function (event) {
                    if (event.button === 0 && onDragStart(event) !== false) {
                        this.setPointerCapture(event.pointerId);
                    }
                });
                element.addEventListener('pointermove', function (event) {
                    if (this.hasPointerCapture(event.pointerId)) {
                        onDragMove(event);
                    }
                });
            }
            // for Mobile Safari
            : 'ontouchend' in window ?
                function (element, onDragStart, onDragMove) {
                    var dragging = false;
                    element.addEventListener('touchstart', function (event) {
                        if (event.touches.length === 1 && onDragStart(event.touches[0]) !== false) {
                            dragging = true;
                            event.preventDefault();
                        }
                    });
                    element.addEventListener('touchmove', function (event) {
                        if (dragging && event.touches.length === 1) {
                            event.preventDefault();
                            onDragMove(event.touches[0]);
                        }
                    });
                }
                // for Safari
                :
                function (element, onDragStart, onDragMove) {
                    var onMouseMove = function (event) {
                        onDragMove(event);
                    };
                    var onMouseUp = function () {
                        removeEventListener('mouseup', onMouseUp);
                        removeEventListener('mousemove', onMouseMove);
                    };
                    element.addEventListener('mousedown', function (event) {
                        if (event.button === 0 && onDragStart(event) !== false) {
                            addEventListener('mousemove', onMouseMove);
                            addEventListener('mouseup', onMouseUp);
                        }
                    });
                };

    var defaultOptions = {
        hsv: [0, 100, 100],
        hsl: [0, 100, 50],
        wheelDiameter: 200,
        wheelThickness: 20,
        handleDiameter: 16,
        wheelReflectsSaturation: true,
        onChange: function () { },
    };
    var Matrix = window.DOMMatrix || window.WebKitCSSMatrix || window.MSCSSMatrix;
    var inverseTransform = function (element) {
        var ancestors = [element];
        while ((element = element.parentElement) !== null) {
            ancestors.push(element);
        }
        var matrix = new Matrix();
        for (var i = ancestors.length - 1; i >= 0; i--) {
            var style = getComputedStyle(ancestors[i]);
            var transform = style.transform;
            if (transform && transform !== 'none') {
                var transformOrigin = style.transformOrigin.split(' ').map(parseFloat);
                matrix = matrix
                    .translate(transformOrigin[0], transformOrigin[1])
                    .multiply(new Matrix(transform))
                    .translate(-transformOrigin[0], -transformOrigin[1]);
            }
        }
        return matrix.inverse();
    };
    var tripletsAreEqual = function (a, b) {
        return a === b || (a[0] === b[0] && a[1] === b[1] && a[2] === b[2]);
    };
    var ReinventedColorWheel = /** @class */ (function () {
        function ReinventedColorWheel(options) {
            var _this = this;
            this.options = options;
            this.wheelDiameter = this.options.wheelDiameter || defaultOptions.wheelDiameter;
            this.wheelThickness = this.options.wheelThickness || defaultOptions.wheelThickness;
            this.handleDiameter = this.options.handleDiameter || defaultOptions.handleDiameter;
            this.onChange = this.options.onChange || defaultOptions.onChange;
            this.wheelReflectsSaturation = this.options.wheelReflectsSaturation !== undefined ? this.options.wheelReflectsSaturation : defaultOptions.wheelReflectsSaturation;
            this.rootElement = this.options.appendTo.appendChild(createElementWithClass('div', 'reinvented-color-wheel'));
            this.hueWheelElement = this.rootElement.appendChild(createElementWithClass('canvas', 'reinvented-color-wheel--hue-wheel'));
            this.hueWheelContext = this.hueWheelElement.getContext('2d');
            this.hueHandleElement = this.rootElement.appendChild(createElementWithClass('div', 'reinvented-color-wheel--hue-handle'));
            this.svSpaceElement = this.rootElement.appendChild(createElementWithClass('canvas', 'reinvented-color-wheel--sv-space'));
            this.svSpaceContext = this.svSpaceElement.getContext('2d');
            this.svHandleElement = this.rootElement.appendChild(createElementWithClass('div', 'reinvented-color-wheel--sv-handle'));
            this._redrawHueWheel = function () {
                _this._redrawHueWheelRequested = false;
                var wheelDiameter = _this.wheelDiameter;
                var center = wheelDiameter / 2;
                var radius = center - _this.wheelThickness / 2;
                var TO_RAD = Math.PI / 180;
                var hslPostfix = _this.wheelReflectsSaturation ? ",".concat(_this._hsl[1], "%,").concat(_this._hsl[2], "%)") : ',100%,50%)';
                var ctx = _this.hueWheelContext;
                ctx.clearRect(0, 0, wheelDiameter, wheelDiameter);
                ctx.lineWidth = _this.wheelThickness;
                for (var i = 0; i < 360; i++) {
                    ctx.beginPath();
                    ctx.arc(center, center, radius, (i - 90.7) * TO_RAD, (i - 89.3) * TO_RAD);
                    ctx.strokeStyle = 'hsl(' + i + hslPostfix;
                    ctx.stroke();
                }
            };
            this.hueWheelContext.imageSmoothingEnabled = false;
            this.svSpaceContext.imageSmoothingEnabled = false;
            this._hsv = normalizeHsvOrDefault(options.hsv ? options.hsv :
                options.hsl ? ReinventedColorWheel.hsl2hsv(options.hsl) :
                    options.rgb ? ReinventedColorWheel.rgb2hsv(options.rgb) :
                        options.hex ? ReinventedColorWheel.rgb2hsv(ReinventedColorWheel.hex2rgb(options.hex)) :
                            undefined, defaultOptions.hsv);
            this._hsl = normalizeHsl(ReinventedColorWheel.hsv2hsl(this._hsv));
            this._rgb = ReinventedColorWheel.hsv2rgb(this._hsv);
            this._hex = ReinventedColorWheel.rgb2hex(this._rgb);
            var invertTransform = function (x, y) {
                var m = _this._inverseTransform.multiply(new Matrix("matrix(1,0,0,1,".concat(x, ",").concat(y, ")")));
                return { x: m.e, y: m.f };
            };
            var onDragStart = function (element) {
                _this._inverseTransform = inverseTransform(element);
                var rect = element.getBoundingClientRect();
                _this._center = invertTransform(rect.left + rect.width / 2, rect.top + rect.height / 2);
            };
            var onDragStartHue = function (event) {
                onDragStart(_this.hueWheelElement);
                var point = invertTransform(event.clientX, event.clientY);
                var x = point.x - _this._center.x;
                var y = point.y - _this._center.y;
                var wheelInnerRadius = _this.wheelDiameter / 2 - _this.wheelThickness;
                if (x * x + y * y < wheelInnerRadius * wheelInnerRadius) {
                    return false;
                }
                onDragMoveHue(event);
            };
            var onDragMoveHue = function (event) {
                var point = invertTransform(event.clientX, event.clientY);
                var x = point.x - _this._center.x;
                var y = point.y - _this._center.y;
                var angle = Math.atan2(y, x);
                _this.hsv = [angle * 180 / Math.PI + 90, _this.hsv[1], _this.hsv[2]];
            };
            var onDragMoveSv = function (event) {
                var point = invertTransform(event.clientX, event.clientY);
                var a = 100 / _this.svSpaceElement.width;
                var s = (point.x - _this._center.x) * a + 50;
                var v = (_this._center.y - point.y) * a + 50;
                _this.hsv = [_this._hsv[0], s, v];
            };
            var onDragStartSv = function (event) {
                onDragStart(_this.svSpaceElement);
                onDragMoveSv(event);
            };
            onDrag(this.hueWheelElement, onDragStartHue, onDragMoveHue);
            onDrag(this.svSpaceElement, onDragStartSv, onDragMoveSv);
            onDrag(this.svHandleElement, onDragStartSv, onDragMoveSv);
            this.redraw();
        }
        Object.defineProperty(ReinventedColorWheel.prototype, "hsv", {
            get: function () { return this._hsv; },
            set: function (value) {
                tripletsAreEqual(this._hsv, value) || this._setHSV(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReinventedColorWheel.prototype, "hsl", {
            get: function () { return this._hsl; },
            set: function (value) {
                tripletsAreEqual(this._hsl, value) || this._setHSV(ReinventedColorWheel.hsl2hsv(value));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReinventedColorWheel.prototype, "rgb", {
            get: function () { return this._rgb; },
            set: function (value) {
                tripletsAreEqual(this._rgb, value) || this._setHSV(ReinventedColorWheel.rgb2hsv(value));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReinventedColorWheel.prototype, "hex", {
            get: function () { return this._hex; },
            set: function (value) {
                this._hex !== value && (this.rgb = ReinventedColorWheel.hex2rgb(value));
            },
            enumerable: false,
            configurable: true
        });
      /** @deprecated */ ReinventedColorWheel.prototype.setHSV = function () { this.hsv = arguments; };
      /** @deprecated */ ReinventedColorWheel.prototype.setHSL = function () { this.hsl = arguments; };
        ReinventedColorWheel.prototype.redraw = function () {
            this.hueWheelElement.width = this.hueWheelElement.height = this.wheelDiameter;
            // 誤操作防止6pxだけ縮める
            this.svSpaceElement.width = this.svSpaceElement.height = (this.wheelDiameter - this.wheelThickness * 2) * Math.SQRT1_2 - 6;
            var hueHandleStyle = this.hueHandleElement.style;
            var svHandleStyle = this.svHandleElement.style;
            hueHandleStyle.width = hueHandleStyle.height = svHandleStyle.width = svHandleStyle.height = "".concat(this.handleDiameter, "px");
            hueHandleStyle.marginLeft = hueHandleStyle.marginTop = svHandleStyle.marginLeft = svHandleStyle.marginTop = "".concat(-this.handleDiameter / 2, "px");
            this._redrawHueWheel();
            this._redrawHueHandle();
            this._redrawSvSpace();
            this._redrawSvHandle();
        };
        ReinventedColorWheel.prototype._setHSV = function (hsv) {
            var oldHsv = this._hsv;
            var newHsv = this._hsv = normalizeHsvOrDefault(hsv, oldHsv);
            var hueChanged = oldHsv[0] - newHsv[0];
            var svChanged = oldHsv[1] - newHsv[1] || oldHsv[2] - newHsv[2];
            if (hueChanged) {
                this._hsl = [newHsv[0], this._hsl[1], this._hsl[2]];
                this._redrawHueHandle();
                this._updateSvBackground();
            }
            if (svChanged) {
                this._hsl = normalizeHsl(ReinventedColorWheel.hsv2hsl(newHsv));
                this._redrawSvHandle();
                if (this.wheelReflectsSaturation && !this._redrawHueWheelRequested) {
                    requestAnimationFrame(this._redrawHueWheel);
                    this._redrawHueWheelRequested = true;
                }
            }
            if (hueChanged || svChanged) {
                this._rgb = ReinventedColorWheel.hsv2rgb(newHsv);
                this._hex = ReinventedColorWheel.rgb2hex(this._rgb);
                this.onChange(this);
            }
        };
        ReinventedColorWheel.prototype._redrawSvSpace = function () {
            this._updateSvBackground();
            var sideLength = this.svSpaceElement.width;
            var ctx = this.svSpaceContext;
            var saturationGradient = ctx.createLinearGradient(0, 0, sideLength, 0);
            var valueGradient = ctx.createLinearGradient(0, 0, 0, sideLength);
            saturationGradient.addColorStop(0, 'rgba(255,255,255,1)');
            saturationGradient.addColorStop(1, 'rgba(255,255,255,0)');
            valueGradient.addColorStop(0, 'rgba(0,0,0,0)');
            valueGradient.addColorStop(1, 'rgba(0,0,0,1)');
            ctx.fillStyle = saturationGradient;
            ctx.fillRect(0, 0, sideLength, sideLength);
            ctx.fillStyle = valueGradient;
            ctx.fillRect(0, 0, sideLength, sideLength);
        };
        ReinventedColorWheel.prototype._updateSvBackground = function () {
            this.svSpaceElement.style.backgroundColor = "hsl(".concat(this._hsv[0], ",100%,50%)");
        };
        ReinventedColorWheel.prototype._redrawHueHandle = function () {
            var center = this.wheelDiameter / 2;
            var wheelRadius = center - this.wheelThickness / 2;
            var angle = (this._hsv[0] - 90) * Math.PI / 180;
            var hueHandleStyle = this.hueHandleElement.style;
            hueHandleStyle.left = "".concat(wheelRadius * Math.cos(angle) + center, "px");
            hueHandleStyle.top = "".concat(wheelRadius * Math.sin(angle) + center, "px");
        };
        ReinventedColorWheel.prototype._redrawSvHandle = function () {
            var svSpaceElementWidth = this.svSpaceElement.width;
            var svHandleStyle = this.svHandleElement.style;
            var offset = (this.wheelDiameter - svSpaceElementWidth) / 2;
            var hsv = this._hsv;
            svHandleStyle.left = "".concat(offset + svSpaceElementWidth * hsv[1] / 100, "px");
            svHandleStyle.top = "".concat(offset + svSpaceElementWidth * (1 - hsv[2] / 100), "px");
        };
        ReinventedColorWheel.default = ReinventedColorWheel;
        ReinventedColorWheel.defaultOptions = defaultOptions;
        ReinventedColorWheel.hsv2hsl = hsv2hsl_1;
        ReinventedColorWheel.hsl2hsv = hsl2hsv_1;
        ReinventedColorWheel.hsv2rgb = hsv2rgb;
        ReinventedColorWheel.rgb2hsv = rgb2hsv;
        ReinventedColorWheel.rgb2hex = rgb2hex_1;
        ReinventedColorWheel.hex2rgb = hex_1;
        return ReinventedColorWheel;
    }());
    function createElementWithClass(tagName, className) {
        var element = document.createElement(tagName);
        element.className = className;
        return element;
    }

    return ReinventedColorWheel;

})();




/***/ }),

/***/ "./src/js/saveload.js":
/*!****************************!*\
  !*** ./src/js/saveload.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SaveSystem: () => (/* binding */ SaveSystem)
/* harmony export */ });
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./etc.js */ "./src/js/etc.js");
// @description セーブ／ロード／自動保存から復元処理 indexedDB処理系



// 自動保存の間隔
const AUTOSAVE_INTERVAL = 10;
// indexedDB定義
const DB_NAME = 'axnospaint_db1';
const DB_VERSION = 2;
const STORE_NAME_SAVE_MANUAL = 'save_manual';
const STORE_NAME_SAVE_AUTO = 'save_auto';
const STORE_NAME_CONFIG = 'save_config';
const STORE_NAME_PALETTE = 'save_palette';

// 自動保存の最大スロット数
const AUTOSAVE_MAX = 20;
// マニュアル保存の最大スロット数
const MANUALSAVE_MAX = 5;

class SaveSystem {
    axpObj;
    dbSystem;
    // indexedDB利用可能判定
    isDBAvailable;
    // 自動保存カウンタ
    autosave_counter;
    CONST = {
        // AXNOS Paintセーブデータ書式のバージョン（他システムから参照される）※indexedDBのバージョンとは別物
        DATA_VERSION: 3,
        // ver.3 draftImageFile追加
    }
    constructor(axpObj) {
        this.axpObj = axpObj;
        this.dbSystem = new DbSystem();
        this.autosave_counter = 0;
    }
    // 初期処理
    init() {
    }
    // DB初期化
    async initDB() {
        let result;
        try {
            result = await this.dbSystem.initIndexedDB();
            if (result) {
                this.isDBAvailable = true;
            } else {
                alert('ブラウザのIndexedDBが無効になっています。\nセーブ/ロード機能などは利用できません。');
                this.isDBAvailable = false;
            }
        } catch (error) {
            console.log(error);
            alert(`エラー:IndexedDBの初期化に失敗しました。\nセーブ/ロード機能などは利用できません。\n${error}`);
            this.isDBAvailable = false;
        }
        return this.isDBAvailable;
    }
    // オートセーブ（カウントとセーブ実行）
    async autoSave() {
        // DB使用不可の場合処理しない
        if (!this.isDBAvailable) return;

        this.autosave_counter++;
        // 規定回数の描画操作を行ったらオートセーブ
        if (this.autosave_counter >= AUTOSAVE_INTERVAL) {
            this.autosave_counter = 0;
            const data = {
                created: new Date(),
                version: this.CONST.DATA_VERSION,
                src: this.axpObj.assistToolSystem.CANVAS.thumbnail.toDataURL(),
                x_max: this.axpObj.x_size,
                y_max: this.axpObj.y_size,
                counter: this.axpObj.layerSystem.layer_counter,
                // 配列を反転して保存（ver1.13以前との互換用）
                //layer: this.axpObj.layerSystem.layerObj.reverse(),
                layer: this.axpObj.layerSystem.layerObj,
                oekaki_id: this.axpObj.oekaki_id,
                draftImageFile: this.axpObj.draftImageFile,
                oekaki_bbs_pageno: this.axpObj.oekaki_bbs_pageno,
                oekaki_bbs_title: this.axpObj.oekaki_bbs_title,
                transparent: this.axpObj.assistToolSystem.getIsTransparent()
            };
            // 指定のデータをDBへ書き込む
            try {
                await this.dbSystem.autosaveToDB(data, STORE_NAME_SAVE_AUTO);
            } catch (error) {
                // オートセーブエラーは告知しない（連続で表示されると描画処理が困難になるため）
                console.log(error);
            }
        }
    }
    startEvent() {
        // セーブ／ロード画面の閉じるボタン
        // （仕様変更）ボタン以外 document.getElementById('axp_saveload').onclick でも閉じることができたのを廃止
        document.getElementById('axp_saveload_button_close').onclick = () => {
            this.closeWindow();
        }
    }
    closeWindow() {
        // 子要素を全消去
        const elementDiv = document.getElementById('axp_saveload_div_insertHTML');
        while (elementDiv.childElementCount) {
            elementDiv.removeChild(elementDiv.firstElementChild);
        }
        // モーダルウィンドウを閉じる
        this.axpObj.isModalOpen = false;
        _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.hide('axp_saveload');
    }
    // セーブ／ロード画面表示（セーブ／ロード／自動保存から復元共通）
    openWindow() {
        if (!this.isDBAvailable) {
            // 現在セーブ/ロード機能は使用できません。ヘルプをご確認下さい。
            this.axpObj.msg('@CAU0300');
            return false;
        }
        this.axpObj.isModalOpen = true;
        _etc_js__WEBPACK_IMPORTED_MODULE_0__.UTIL.show('axp_saveload');

        // 子要素を全消去（閉じる時に削除されなかった場合の保険初期化）
        const elementDiv = document.getElementById('axp_saveload_div_insertHTML');
        while (elementDiv.childElementCount) {
            elementDiv.removeChild(elementDiv.firstElementChild);
        }
        return true;
    }
    createSlotHTML(mode, cursor) {
        // スロット挿入用枠要素
        const obj = document.getElementById('axp_saveload_div_insertHTML');
        const value = cursor.value;

        // スロットの作成
        const newDiv = document.createElement('div');
        // 主キーを含んだ文字列をid名とする
        newDiv.setAttribute('id', `axp_saveload_div_${cursor.primaryKey}`);
        // 主キーを記憶しておく
        newDiv.setAttribute('data-key', cursor.primaryKey);
        // セーブ用とロード用で別のクラスを付与
        if (mode === 'save') {
            newDiv.setAttribute('class', 'axpc_saveload_saveSlot');
        } else {
            newDiv.setAttribute('class', 'axpc_saveload_loadSlot');
        }
        // サムネイル枠
        const newDivThumbnall = document.createElement('div');
        newDivThumbnall.setAttribute('class', 'axpc_saveload_thumbnall');
        newDiv.appendChild(newDivThumbnall);

        // セーブデータありのスロット
        if (value.created !== undefined) {
            // サムネイル画像
            const newImg = document.createElement('img');
            newImg.setAttribute('src', value.src);
            newDivThumbnall.appendChild(newImg);
            // 日付、時刻、基にしたoekaki_idの要素作成
            const newDivDate = document.createElement('div');
            const newDivTime = document.createElement('div');
            const newDivRefId = document.createElement('div');
            newDivRefId.setAttribute('class', 'axpc_saveload_refId');
            // 日付
            let stringDate = 'YYYY/MM/DD';
            stringDate = stringDate.replace(/YYYY/, value.created.getFullYear());
            stringDate = stringDate.replace(/MM/, ("0" + (value.created.getMonth() + 1)).slice(-2));
            stringDate = stringDate.replace(/DD/, ("0" + value.created.getDate()).slice(-2));
            newDivDate.textContent = stringDate;
            // 時刻
            let stringTime = 'hh:mm:ss';
            stringTime = stringTime.replace(/hh/, ("0" + value.created.getHours()).slice(-2));
            stringTime = stringTime.replace(/mm/, ("0" + value.created.getMinutes()).slice(-2));
            stringTime = stringTime.replace(/ss/, ("0" + value.created.getSeconds()).slice(-2));
            newDivTime.textContent = stringTime;
            // 基にしたoekaki_id(draftImageFile優先)
            let refIdText = '';
            if (value.oekaki_id !== undefined) {
                if (value.oekaki_id !== null) {
                    refIdText = '[基]' + value.oekaki_id;
                }
            }
            if (value.draftImageFile !== undefined) {
                if (value.draftImageFile !== null) {
                    refIdText = '[基]' + (0,_etc_js__WEBPACK_IMPORTED_MODULE_0__.getFileNameFromURL)(value.draftImageFile);
                }
            }
            newDivRefId.textContent = refIdText;
            newDiv.appendChild(newDivDate);
            newDiv.appendChild(newDivTime);
            newDiv.appendChild(newDivRefId);
        } else {
            // 空エントリ
            newDiv.appendChild(document.createTextNode('空き'));
        }
        // スロット挿入用枠要素に作成したスロットを追加
        obj.appendChild(newDiv);
    }
    // セーブ
    async save() {
        // サブ画面を表示
        if (!this.openWindow()) {
            return;
        }
        document.getElementById('axp_saveload_span_message').textContent = 'セーブするスロットを選択（※保存済みのスロットは上書きされます）';
        try {
            await this.dbSystem.loadEntry('save', STORE_NAME_SAVE_MANUAL, this.createSlotHTML);
            // スロット要素（直下の子要素div）を取得
            const elementsSlot = document.querySelectorAll('#axp_saveload_div_insertHTML > div');
            for (const item of elementsSlot) {
                // スロットがクリックされたらセーブ処理を行う
                item.onclick = (e) => {
                    // data-keyに記憶しておいた主キーを使用する
                    const save_id = e.currentTarget.dataset.key;
                    const data = {
                        id: save_id,
                        version: this.CONST.DATA_VERSION,
                        created: new Date(),
                        src: this.axpObj.assistToolSystem.CANVAS.thumbnail.toDataURL(),
                        x_max: this.axpObj.x_size,
                        y_max: this.axpObj.y_size,
                        counter: this.axpObj.layerSystem.layer_counter,
                        layer: this.axpObj.layerSystem.layerObj,
                        oekaki_id: this.axpObj.oekaki_id,
                        draftImageFile: this.axpObj.draftImageFile,
                        oekaki_bbs_pageno: this.axpObj.oekaki_bbs_pageno,
                        oekaki_bbs_title: this.axpObj.oekaki_bbs_title,
                        transparent: this.axpObj.assistToolSystem.getIsTransparent()
                    };

                    (async () => {
                        // 指定のデータをDBへ書き込む
                        try {
                            await this.dbSystem.saveToDB(data, STORE_NAME_SAVE_MANUAL);
                            // スロット%1にセーブしました。
                            this.axpObj.msg('@INF0300', save_id.substr(5));
                        } catch (error) {
                            console.log(error);
                            alert(`エラー：セーブデータの保存に失敗しました。\n${error}`);
                        } finally {
                            this.closeWindow();
                        }
                    })();
                }
            }
        } catch (error) {
            console.log(error);
            alert(`エラー：セーブデータの読込に失敗しました。\n${error}`);
        }
    }
    // ロード処理共通
    // mode: 'load' or 'auto'
    async loadCommon(mode, storeName) {
        try {
            await this.dbSystem.loadEntry(mode, storeName, this.createSlotHTML);
            // スロット要素（直下の子要素div）を取得
            const elementsSlot = document.querySelectorAll('#axp_saveload_div_insertHTML > div');
            for (const item of elementsSlot) {
                // スロットがクリックされたらロード処理を行う
                item.onclick = (e) => {
                    // data-keyに記憶しておいた主キーを使用する
                    let save_id;
                    if (mode === 'auto') {
                        // 自動保存用セーブデータのキーは数値型の自動付与）
                        save_id = Number(e.currentTarget.dataset.key);
                    } else {
                        // マニュアル用セーブデータのキーは文字列
                        save_id = e.currentTarget.dataset.key;
                    }
                    (async () => {
                        try {
                            // 指定IDのデータをDBから読み込む
                            const data = await this.dbSystem.loadFromDB(save_id, storeName);
                            //console.log(data);
                            if (data.created === undefined) {
                                // スロット%1にはデータがありません。
                                this.axpObj.msg('@CAU0301', save_id.substr(5));
                                return;
                            }
                            // 画像サイズが許容範囲かチェック
                            if (
                                !(0,_etc_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(data.x_max, this.axpObj.minWidth, this.axpObj.maxWidth)
                                ||
                                !(0,_etc_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(data.y_max, this.axpObj.minHeight, this.axpObj.maxHeight)
                            ) {
                                alert(`データの画像サイズ(横:${data.x_max} 縦:${data.y_max}) が許容値を超えています。\nこのデータをロードすることはできません。`);
                                return;
                            }

                            // 同一掲示板のみロード可能とする設定の場合、チェックを行う
                            if (this.restore_oekaki_id(data)) {
                                this.restoreData(data);
                                if (mode === 'auto') {
                                    // 自動保存されたデータをロードしました。
                                    this.axpObj.msg('@INF0302');
                                } else {
                                    // スロット%1をロードしました。
                                    this.axpObj.msg('@INF0301', save_id.substr(5));
                                }
                            } else {
                                // 掲示板不一致
                                alert(data.oekaki_bbs_title
                                    + '\nに投稿された画像を基にしているため、別の掲示板には投稿できません。\n同一の掲示板でロードしてください。');
                            }
                        } catch (error) {
                            console.log(error);
                            alert(`エラー：セーブデータの読込に失敗しました。\n${error}`);
                        } finally {
                            this.closeWindow();
                        }
                    })();
                }
            }
        } catch (error) {
            console.log(error);
            alert(`エラー：セーブデータの読込に失敗しました。\n${error}`);
        }
    }
    // ロード
    load() {
        // サブ画面を表示
        if (!this.openWindow()) {
            return;
        }
        document.getElementById('axp_saveload_span_message').textContent = 'ロードするスロットを選択（※現在の描画内容は破棄されます）';
        this.loadCommon('load', STORE_NAME_SAVE_MANUAL);
    }
    // 自動保存から復元
    restore() {
        // サブ画面を表示
        if (!this.openWindow()) {
            return;
        }
        document.getElementById('axp_saveload_span_message').textContent = '自動バックアップ（10ストローク毎に最大20件まで保存）を選択（※現在の描画内容は破棄されます）';
        this.loadCommon('auto', STORE_NAME_SAVE_AUTO);
    }
    // 「基にしてお絵カキコ」情報のチェックと復元
    restore_oekaki_id(readdata) {
        //console.log(readdata.oekaki_id);
        if (readdata.draftImageFile !== undefined && readdata.draftImageFile !== null) {
            // 「draftImageFile」画像の場合
            console.log('同一掲示板チェック:', readdata.oekaki_bbs_pageno, this.axpObj.post_bbs_pageno);
            // 同一掲示板チェックが有効
            if (this.axpObj.checkSameBBS) {
                if (readdata.oekaki_bbs_pageno !== this.axpObj.post_bbs_pageno) {
                    return false;
                }
            }
            // 下書き情報の復元
            this.axpObj.oekaki_id = null;
            this.axpObj.draftImageFile = readdata.draftImageFile;
            this.axpObj.oekaki_bbs_pageno = readdata.oekaki_bbs_pageno;
            this.axpObj.oekaki_bbs_title = readdata.oekaki_bbs_title;
        } else if (readdata.oekaki_id !== undefined && readdata.oekaki_id !== null) {
            // 「oekaki_id」画像の場合
            console.log('同一掲示板チェック:', readdata.oekaki_bbs_pageno, this.axpObj.post_bbs_pageno);
            // 同一掲示板チェックが有効
            if (this.axpObj.checkSameBBS) {
                if (readdata.oekaki_bbs_pageno !== this.axpObj.post_bbs_pageno) {
                    return false;
                }
            }
            // 下書き情報の復元
            this.axpObj.oekaki_id = readdata.oekaki_id
            this.axpObj.draftImageFile = null;
            this.axpObj.oekaki_bbs_pageno = readdata.oekaki_bbs_pageno;
            this.axpObj.oekaki_bbs_title = readdata.oekaki_bbs_title;
        } else {
            // 「基にしてお絵カキコ」情報のリセット
            this.axpObj.oekaki_id = null;
            this.axpObj.draftImageFile = null;
            this.axpObj.oekaki_bbs_pageno = null;
            this.axpObj.oekaki_bbs_title = null;
        }
        return true;
    }
    // レイヤーオブジェクトから画面を復元する
    restoreData(obj) {
        // キャンバスサイズ再設定
        this.axpObj.x_size = obj.x_max;
        this.axpObj.y_size = obj.y_max;
        // キャンバス初期化（キャンバスサイズ変更、レイヤー削除、拡大率リセットなど）
        this.axpObj.resetCanvas();
        // レイヤーカウンタ復元
        this.axpObj.layerSystem.setLayerCounter(obj.counter);

        // バージョンチェック
        let ver = (obj.version) ? obj.version : 0;
        console.log('data version:', ver);
        // ver1.13以前のデータならば、互換性のためにレイヤー配列の順序を反転する
        if (ver < 2) {
            Array.prototype.reverse.call(obj.layer);
            for (let i = 0; i < obj.layer.length; i++) {
                obj.layer[i].index = i;
            }
        }

        //console.log(obj);
        // レイヤー復元
        for (let idx = 0; idx < obj.layer.length; idx++) {
            // ロードしたデータを元に、layerObjを復元、生成する
            this.axpObj.layerSystem.restoreLayer({
                layerObj: obj.layer[idx],
            });
        }
        // 背景透過の有無の情報が含まれていれば復元
        if (typeof obj.transparent !== 'undefined') {
            this.axpObj.assistToolSystem.setIsTransparent(obj.transparent);
        } else {
            // 情報なしの場合、透過なし（ver1.99.80以前のデータ互換用）
            this.axpObj.assistToolSystem.setIsTransparent(false);
        }
        // 最上位のレイヤーを選択
        this.axpObj.layerSystem.selectCurrentLayerIndex(0);
        // 合成モード表示更新
        this.axpObj.layerSystem.updateBlendModeDisplayAll();
        // キャンバスを更新
        this.axpObj.layerSystem.updateCanvas();
    }
    // ユーザー設定の保存
    save_config(configObj) {
        // DB使用不可の場合処理しない
        if (!this.isDBAvailable) return;

        const data = {
            id: 'config_01',
            config: configObj,
        }
        try {
            this.dbSystem.saveToDB(data, STORE_NAME_CONFIG);
        } catch (error) {
            console.log(error);
        }
    }
    // ユーザー設定の読込
    async load_config() {
        // DB使用不可の場合処理しない（コール前に判定しているため、正常系では不通）
        if (!this.isDBAvailable) return;

        const save_id = 'config_01';
        // 指定IDのデータをDBから読み込む
        let result = await this.dbSystem.loadFromDB(save_id, STORE_NAME_CONFIG)
        if (result.config !== undefined) {
            // 復元データあり
            // console.log('ユーザー設定データあり');
            return result.config;
        } else {
            // 復元データなし
            // console.log('ユーザー設定データなし');
            return null;
        }
    }
    // カラーパレットの保存
    save_palette(paletteObj) {
        // DB使用不可の場合処理しない
        if (!this.isDBAvailable) return;

        const data = {
            id: 'palette_01',
            palette: paletteObj,
        }
        try {
            this.dbSystem.saveToDB(data, STORE_NAME_PALETTE);
        } catch (error) {
            console.log(error);
        }
    }
    // カラーパレットの読込
    async load_palette() {
        // DB使用不可の場合処理しない（コール前に判定しているため、正常系では不通）
        if (!this.isDBAvailable) return;

        const save_id = 'palette_01';
        // 指定IDのデータをDBから読み込む
        let result = await this.dbSystem.loadFromDB(save_id, STORE_NAME_PALETTE)
        if (result.palette !== undefined) {
            // 復元データあり
            //console.log("パレットデータあり");
            return result.palette;
        } else {
            //console.log("パレットデータなし");
            return;
        }
    }
}

// indexedDB処理系
// saveSystemからのみアクセス可能
class DbSystem {
    constructor() {
    }
    initIndexedDB() {
        return new Promise((resolve, reject) => {
            if (!window.indexedDB) {
                // indexedDBが使用不可な環境（正常終了）
                resolve(false);
            }
            const openReq = indexedDB.open(DB_NAME, DB_VERSION);
            openReq.onerror = () => {
                reject(new Error('initIndexedDB:openReq.onerror'));
            }
            openReq.onupgradeneeded = (event) => {
                const db = openReq.result;
                // 初回利用時（またはDBが古い状態の時）DBを新規作成／更新する
                if (event.oldVersion <= 1) {
                    const store_manual = db.createObjectStore(STORE_NAME_SAVE_MANUAL, { keyPath: 'id' });
                    store_manual.put({ id: 'save_01' });
                    store_manual.put({ id: 'save_02' });
                    store_manual.put({ id: 'save_03' });
                    store_manual.put({ id: 'save_04' });
                    store_manual.put({ id: 'save_05' });

                    const store_auto = db.createObjectStore(STORE_NAME_SAVE_AUTO, { autoIncrement: true });
                    store_auto.createIndex('created', 'created', { unique: false });

                    const store_config = db.createObjectStore(STORE_NAME_CONFIG, { keyPath: 'id' });
                    store_config.put({ id: 'config_01' });

                    const store_palette = db.createObjectStore(STORE_NAME_PALETTE, { keyPath: 'id' });
                    store_palette.put({ id: 'palette_01' });
                }
            }
            openReq.onsuccess = () => {
                resolve(true);
            }
        });
    }
    // エントリーロード（セーブロード自動保存共通）
    // mode : 'save'or 'load' of 'auto'
    // storeName : ストア名
    // dispFunction : 画面表示用コールバック関数
    loadEntry(mode, storeName, dispFunction) {
        return new Promise((resolve, reject) => {
            // データベースを開く
            let db;
            const openReq = indexedDB.open(DB_NAME, DB_VERSION);
            openReq.onerror = () => {
                reject(new Error('loadEntry:openReq.onerror'));
            }
            // DBからレイヤーオブジェクトを読み込み
            openReq.onsuccess = () => {
                db = openReq.result;
                // DBから読み込み
                const transaction = db.transaction(storeName);
                const store = transaction.objectStore(storeName);

                let direction;
                let slotMAX;
                if (mode === 'auto') {
                    // 自動保存は新着順
                    direction = 'prev';
                    slotMAX = AUTOSAVE_MAX;
                } else {
                    // セーブロードはID順
                    direction = 'next';
                    slotMAX = MANUALSAVE_MAX;
                }
                const readReq = store.openCursor(null, direction);

                let idx = 0;
                readReq.onerror = () => {
                    reject(new Error('loadEntry:readReq.onerror'));
                }
                readReq.onsuccess = () => {
                    let cursor = readReq.result;
                    if (cursor) {
                        // カーソル（１スロット分）のHTML生成表示
                        dispFunction(mode, cursor);
                        // カーソルを進める
                        idx++;
                        //console.log(idx);
                        if (idx < slotMAX) {
                            cursor.continue();
                        } else {
                            // 最大件数まで読み込んだら正常終了
                            resolve();
                        }
                    } else {
                        if (mode === 'auto') {
                            // 最大件数に満たない場合でも正常終了
                            resolve();
                        } else {
                            // 既定分のカーソルが取得できなかった場合
                            reject(new Error('loadEntry:readReq.onsuccess'));
                        }
                    }
                }
            }
        });
    }
    // DBへセーブ（共通）
    saveToDB(data, storeName) {
        return new Promise((resolve, reject) => {
            const openReq = indexedDB.open(DB_NAME, DB_VERSION);
            openReq.onerror = () => {
                reject(new Error('saveToDB:openReq.onerror'));
            }
            openReq.onsuccess = () => {
                const db = openReq.result;
                const transaction = db.transaction(storeName, "readwrite");
                // 操作するためにオブジェクトストアを取得
                const store = transaction.objectStore(storeName);
                // DBへレイヤーオブジェクトを書き込み
                const saveReq = store.put(data);
                saveReq.onerror = () => {
                    reject(new Error('saveToDB:saveReq.onerror'));
                }
                saveReq.onsuccess = () => {
                    resolve();
                }
            }
        });
    }
    // DBへセーブ（自動保存用）
    autosaveToDB(data, storeName) {
        return new Promise((resolve, reject) => {
            const openReq = indexedDB.open(DB_NAME, DB_VERSION);
            openReq.onerror = () => {
                reject(new Error('autosaveToDB:openReq.onerror'));
            }
            openReq.onsuccess = () => {
                const db = openReq.result;
                const transaction = db.transaction(storeName, "readwrite");
                // 操作するためにオブジェクトストアを取得
                const store = transaction.objectStore(storeName);

                // データが２０件を超える場合は一番古いものを削除
                const countReq = store.count();
                countReq.onerror = () => {
                    reject(new Error('autosaveToDB:countReq.onerror'));
                }
                countReq.onsuccess = () => {
                    //console.log(countReq.result);
                    //console.log(AUTOSAVE_MAX);
                    if (countReq.result >= AUTOSAVE_MAX) {
                        // DBから読み込み
                        const readReq = store.openCursor(null, "next");
                        readReq.onerror = () => {
                            reject(new Error('autosaveToDB:readReq.onerror'));
                        }
                        readReq.onsuccess = () => {
                            const cursor = readReq.result;
                            if (cursor) {
                                // １件削除
                                const deleteReq = cursor.delete();
                                deleteReq.onerror = () => {
                                    reject(new Error('autosaveToDB:deleteReq.onerror'));
                                }
                                deleteReq.onsuccess = () => {
                                    //console.log("olddata delete success");
                                }
                            } else {
                                //console.log("No more entry");
                            }
                        }
                    }
                }
                // DBへレイヤーオブジェクトを書き込み
                const saveReq = store.put(data);
                saveReq.onerror = () => {
                    reject(new Error('autosaveToDB:saveReq.onerror'));
                }
                saveReq.onsuccess = () => {
                    resolve();
                }
            }
        });
    }
    // DBからロード（マニュアル/自動保存兼用）
    loadFromDB(id, storeName) {
        return new Promise((resolve, reject) => {
            const openReq = indexedDB.open(DB_NAME, DB_VERSION);
            openReq.onerror = () => {
                reject(new Error('loadFromDB:openReq.onerror'));
            }
            openReq.onsuccess = () => {
                const db = openReq.result;
                // DBから読み込み
                const transaction = db.transaction(storeName);
                const store = transaction.objectStore(storeName);
                const readReq = store.get(id);
                readReq.onerror = () => {
                    reject(new Error('loadFromDB:readReq.onerror'));
                }
                readReq.onsuccess = () => {
                    if (readReq.result !== undefined) {
                        resolve(readReq.result);
                    } else {
                        reject(new Error('loadFromDB:readReq.onsuccess'));
                    }
                }
            }
        });
    }
}

/***/ }),

/***/ "./src/js/undo.js":
/*!************************!*\
  !*** ./src/js/undo.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UndoSystem: () => (/* binding */ UndoSystem)
/* harmony export */ });
/* harmony import */ var _window_layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./window_layer.js */ "./src/js/window_layer.js");
// @description アンドゥ／リドゥ処理



/*
◆処理概要
キャンバスに対して操作が行われた際に、どのような操作を行ったかを記録するログ情報として「actionObj」（※１）を作成し、setUndo()で受け取り、undoObj[]に登録する。
アンドゥ要求があった場合、undoObj[]から最新の「actionObj」を取りだし、記録されている情報を元に復元を行う。
この時、リドゥ処理に必要な情報を、redoObj[]へ登録する。

リドゥ要求があった場合、redoObj[]から最新の「actionObj」を取りだし、記録されている情報を元にアンドゥの取り消しを行う。
この時、アンドゥ処理に必要な情報（※１で作成したものと同様の内容）を、undoObj[]へ登録する。（元の状態に戻し、再度アンドゥできるようにする。）

undoObj[]は、一定数（アンドゥ可能最大数）の「actionObj」が登録されたら、１件登録するたび、最古の情報を１件消去する。
redoObj[]は、undoObj[]に新しい「actionObj」（リドゥ要求による戻しではない）が登録されるたび、全て消去する。
（その時点までに行ったアンドゥを確定事項として、リドゥ対象から外す）
*/

class UndoObj {
    constructor(obj) {
        this.type = obj.type;
        this.detail = obj.detail;
        // 処理対象のレイヤーID（layerObjの保存が必要ないアンドゥの場合、id情報を保存する）
        this.id = obj.id;
        // 処理対象のレイヤー情報
        this.layerObj = (obj.layerObj) ? new _window_layer_js__WEBPACK_IMPORTED_MODULE_0__.Layerdata(obj.layerObj) : null;
        // レイヤー統合時の統合先レイヤー
        this.layerObj_dest = (obj.layerObj_dest) ? new _window_layer_js__WEBPACK_IMPORTED_MODULE_0__.Layerdata(obj.layerObj_dest) : null;;
    }
}

class UndoSystem {
    axpObj;

    undoObj = [];
    redoObj = [];

    isUndoing = false;
    isRedoing = false;
    undoButtonElement = null;
    redoButtonElement = null;

    constructor(axpObj) {
        this.axpObj = axpObj;

    }
    // 初期化（＆キャンバスリセット時の再初期化）
    init() {
        //console.log('...UndoSystem:init');
        this.setUndoButtonElement(document.getElementById('axp_tool_button_undo'));
        this.setRedoButtonElement(document.getElementById('axp_tool_button_redo'));
    }
    resetCanvas() {
        this.undoObj.splice(0);
        this.redoObj.splice(0);
        this.dispCount();
    }
    // ボタン回数表示
    dispCount() {
        this.undoButtonElement.textContent = `${this.axpObj._('@MISC.BUTTON_UNDO')}(${this.undoObj.length})`;
        this.redoButtonElement.textContent = `${this.axpObj._('@MISC.BUTTON_REDO')}(${this.redoObj.length})`;
    }
    setUndoButtonElement(targetElement) {
        this.undoButtonElement = targetElement;
    }
    setRedoButtonElement(targetElement) {
        this.redoButtonElement = targetElement;
    }
    setUndo(actionObj) {
        //console.log('exec:', actionObj.type);
        //console.log('exec:', actionObj.layerObj.image);
        // リドゥ処理での呼び出しではない場合、リドゥ記憶を消す
        if (!this.isRedoing) {
            this.redoObj.splice(0);
        }
        // 記録数が１０を超える場合、最古の記録を消す
        if (this.undoObj.length >= this.axpObj.undo_max) {
            this.undoObj.shift();
        }

        let obj = new UndoObj(actionObj);
        this.undoObj.push(obj);
        //console.log("undo", this.undoObj, "redo", this.redoObj);
        this.dispCount();

    }
    // アンドゥ実行
    undo() {
        if (this.undoObj.length <= 0) {
            // これ以上アンドゥできません。
            this.axpObj.msg('@CAU0400');
            return;
        }
        const actionObj = this.undoObj.pop();
        // console.log('undo:', actionObj);
        // アンドゥ中であることを記憶しておく（※未使用。将来拡張用フラグ）
        this.isUndoing = true;
        let msgtext = '';
        switch (actionObj.type) {
            case 'draw':
                // 詳細情報に対応するテキスト取得
                msgtext = this.getDetailText(actionObj.detail);
                // リドゥ用記憶
                this.axpObj.undoSystem.setRedo({
                    type: actionObj.type,
                    detail: actionObj.detail,
                    layerObj: this.axpObj.layerSystem.layerObj[this.axpObj.layerSystem.getLayerIndex(actionObj.layerObj.id)],
                });
                // アンドゥ処理
                this.axpObj.layerSystem.setImageId(actionObj.layerObj.image, actionObj.layerObj.id);
                break;

            case 'layer-create':
                msgtext = '[レイヤー:新規]';
                // リドゥ用記憶
                this.setRedo(actionObj);
                // アンドゥ処理
                this.axpObj.layerSystem.deleteLayer(actionObj.layerObj.id);
                break;
            case 'layer-copy':
                msgtext = '[レイヤー:複製]';
                // リドゥ用記憶
                this.setRedo(actionObj);
                // アンドゥ処理
                this.axpObj.layerSystem.deleteLayer(actionObj.layerObj.id);
                break;

            case 'layer-delete':
                msgtext = '[レイヤー:削除]';
                // リドゥ用記憶
                this.setRedo(actionObj);
                // アンドゥ処理
                this.axpObj.layerSystem.restoreLayer(actionObj);
                break;

            case 'layer-clear':
                msgtext = '[レイヤー:クリア]';
                // リドゥ用記憶
                this.setRedo(actionObj);
                // アンドゥ処理
                this.axpObj.layerSystem.setImageId(actionObj.layerObj.image, actionObj.layerObj.id);
                break;

            case 'layer-integrate': {
                msgtext = '[レイヤー:統合]';
                // リドゥ用記憶
                this.axpObj.undoSystem.setRedo({
                    type: actionObj.type,
                    // リドゥで消去する統合元のレイヤー
                    layerObj: actionObj.layerObj,
                    // リドゥで再統合される復元される統合先のレイヤー
                    layerObj_dest: this.axpObj.layerSystem.layerObj[this.axpObj.layerSystem.getLayerIndex(actionObj.layerObj_dest.id)],
                });
                // アンドゥ処理
                //  統合元レイヤーを復元
                this.axpObj.layerSystem.restoreLayer(actionObj);
                //  統合先レイヤーを復元
                let data = actionObj.layerObj_dest;
                // 画像と不透明度を復元する
                const index = this.axpObj.layerSystem.getLayerIndex(data.id);
                this.axpObj.layerSystem.layerObj[index].image = data.image;
                this.axpObj.layerSystem.setAlpha(data.alpha, index);
                break;
            }
            case 'flip_h':
                // リドゥ用記憶
                this.setRedo(actionObj);
                // アンドゥ処理
                //  idには、単体ならレイヤーのID、全体なら'all'が格納されている
                this.axpObj.layerSystem.flip_h(actionObj.id);
                //console.log(actionObj.index);
                if (actionObj.id == 'all') {
                    msgtext = '[左右反転:全体]';
                } else {
                    msgtext = '[左右反転:単体]';
                }
                break;
            case 'flip_v':
                // リドゥ用記憶
                this.setRedo(actionObj);
                // アンドゥ処理
                this.axpObj.layerSystem.flip_v(actionObj.id);
                if (actionObj.id == 'all') {
                    msgtext = '[上下反転:全体]';
                } else {
                    msgtext = '[上下反転:単体]';
                }
                break;

            default:
                console.log('WARNING:未登録のactionObj.type:', actionObj.type);
        }
        this.isUndoing = false;
        // %1をアンドゥしました。（残り回数：%2）
        this.axpObj.msg('@INF0400', msgtext, this.undoObj.length);
        // キャンバス再描画
        this.axpObj.layerSystem.updateCanvas();
        // アンドゥ／リドゥボタンの回数表示更新
        this.dispCount();

        //console.log("undo", undoObj , "redo" , redoObj);
    }
    setRedo(actionObj) {
        // 記録数が可能回数を超える場合、最古の記録を消す（可能回数以上になることはないはず）
        if (this.redoObj.length >= this.axpObj.undo_max) {
            this.redoObj.shift();
            alert('REDO error');
        }
        let obj = new UndoObj(actionObj);
        this.redoObj.push(obj);
    }
    // リドゥ実行
    redo() {
        if (this.redoObj.length <= 0) {
            // これ以上リドゥできません。
            this.axpObj.msg('@CAU0401');
            return;
        }
        // リドゥ中であることを記憶しておく
        this.isRedoing = true;
        const actionObj = this.redoObj.pop();
        let msgtext = '';
        switch (actionObj.type) {
            case 'draw':
                // 詳細情報に対応するテキスト取得
                msgtext = this.getDetailText(actionObj.detail);
                // 再アンドゥ記憶
                this.axpObj.undoSystem.setUndo({
                    type: actionObj.type,
                    detail: actionObj.detail,
                    layerObj: this.axpObj.layerSystem.layerObj[this.axpObj.layerSystem.getLayerIndex(actionObj.layerObj.id)],
                });
                // リドゥ処理
                this.axpObj.layerSystem.setImageId(actionObj.layerObj.image, actionObj.layerObj.id);
                break;
            case 'layer-create':
                msgtext = '[レイヤー:新規]';
                // 再アンドゥ記憶
                this.setUndo(actionObj);
                // リドゥ処理
                this.axpObj.layerSystem.restoreLayer(actionObj);
                break;
            case 'layer-copy':
                msgtext = '[レイヤー:複製]';
                // 再アンドゥ記憶
                this.setUndo(actionObj);
                // リドゥ処理
                this.axpObj.layerSystem.restoreLayer(actionObj);
                break;
            case 'layer-delete':
                msgtext = '[レイヤー:削除]';
                // 再アンドゥ記憶
                this.setUndo(actionObj);
                // リドゥ処理
                this.axpObj.layerSystem.deleteLayer(actionObj.layerObj.id);
                break;
            case 'layer-clear':
                msgtext = '[レイヤー:クリア]';
                // 再アンドゥ記憶
                this.setUndo(actionObj);
                // リドゥ処理
                this.axpObj.layerSystem.clear(actionObj.layerObj.id);
                break;
            case 'layer-integrate': {
                msgtext = '[レイヤー:統合]';
                // 再アンドゥ記憶
                this.setUndo({
                    type: actionObj.type,
                    // 統合元のレイヤー
                    layerObj: actionObj.layerObj,
                    // 統合先のレイヤー
                    layerObj_dest: this.axpObj.layerSystem.layerObj[this.axpObj.layerSystem.getLayerIndex(actionObj.layerObj_dest.id)],
                });
                // リドゥ処理
                // 統合先レイヤーを復元
                let data = actionObj.layerObj_dest;
                const index = this.axpObj.layerSystem.getLayerIndex(data.id);
                this.axpObj.layerSystem.layerObj[index].image = data.image;
                this.axpObj.layerSystem.setAlpha(data.alpha, index);
                // 統合元レイヤーを削除
                this.axpObj.layerSystem.deleteLayer(actionObj.layerObj.id);
                break;
            }
            case 'flip_h':
                // 再アンドゥ記憶
                this.setUndo(actionObj);
                // リドゥ処理
                this.axpObj.layerSystem.flip_h(actionObj.id);
                if (actionObj.id == 'all') {
                    msgtext = '[左右反転:全体]';
                } else {
                    msgtext = '[左右反転:単体]';
                }
                break;
            case 'flip_v':
                // 再アンドゥ記憶
                this.setUndo(actionObj);
                // リドゥ処理
                this.axpObj.layerSystem.flip_v(actionObj.id);
                if (actionObj.id == 'all') {
                    msgtext = '[上下反転:全体]';
                } else {
                    msgtext = '[上下反転:単体]';
                }
                break;
            default:
                console.log('WARNING:未登録のactionObj.type:', actionObj.type);
        }
        this.isRedoing = false;
        // %1をリドゥしました。（残り回数：%2）
        this.axpObj.msg('@INF0401', msgtext, this.redoObj.length);
        // キャンバス再描画
        this.axpObj.layerSystem.updateCanvas();
        // アンドゥ／リドゥボタンの回数表示更新
        this.dispCount();
        //console.log("undo", undoObj , "redo" , redoObj);
    }
    getDetailText(detail) {
        let msgtext;
        switch (detail) {
            case 'eraser':
                msgtext = '[消しゴム]';
                break;
            case 'move':
                msgtext = '[移動ツール]';
                break;
            case 'fill':
                msgtext = '[バケツ]';
                break;
            case 'fillall':
                msgtext = '[全面塗り潰し]';
                break;
            case 'rotate90':
                msgtext = '[90°回転]';
                break;
            default:
                msgtext = '[線の描画]';
        }
        return msgtext;
    }
}


/***/ }),

/***/ "./src/js/window.js":
/*!**************************!*\
  !*** ./src/js/window.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ToolWindow: () => (/* binding */ ToolWindow)
/* harmony export */ });
// @description ツールウィンドウ：親クラス

// ツールウィンドウ共通
class ToolWindow {
    axpObj;
    // 自身が管理するツールウィンドウのdiv要素
    windowElement = null;
    // ランチャーボタン要素
    launcherButtonElement = null;
    // 最小化対象ウィンドウ
    isCanMinimize = false;
    // ツールウィンドウ名
    name;
    // ツールウィンドウのid
    id;
    // タイプ識別子
    type;
    // ウィンドウの座標
    window_width = 0;
    window_height = 0;
    window_left = 0;
    window_top = 0;
    constructor(axpObj) {
        this.axpObj = axpObj;
    }
    createHTML(id, type, name, icon, html, minimize = true) {
        this.id = id;
        this.type = type;
        this.isCanMinimize = minimize;
        //console.log('createHTML', name);
        // ツールウィンドウの枠div（共通部）を生成
        let divWindow = document.createElement('div');
        divWindow.setAttribute('id', id);
        divWindow.setAttribute('class', 'axpc_window');

        let divHeader = document.createElement('div');
        divHeader.setAttribute('class', 'axpc_window_header');

        // ウィンドウ名
        let divTitle = document.createElement('div');
        divTitle.textContent = name;
        // アイコン表示の生成
        if (icon) {
            let spanIcon = document.createElement('span');
            spanIcon.setAttribute('class', icon);
            divHeader.appendChild(spanIcon);
        } else {
            // アイコン無し（ランチャーウィンドウ、カスタムウィンドウ）
            divTitle.style.gridArea = '1/1/2/3';
            divTitle.style.marginLeft = '8px';
        }
        divHeader.appendChild(divTitle);
        // 最小化可能なウィンドウの場合、最小化ボタンを生成する
        if (minimize) {
            const buttonMinimize = document.createElement('button');
            buttonMinimize.setAttribute('class', 'axpc_MSG axpc_window_header_minimizeButton');
            buttonMinimize.dataset.msg = `${name}ウィンドウを閉じます。`;
            divHeader.appendChild(buttonMinimize);

            // ランチャーボタンの生成と追加
            const newButton = document.createElement('button');
            // class追加
            newButton.classList.add('axpc_MSG', 'axpc_launcher_personalButton');
            newButton.dataset.id = id;
            newButton.dataset.msg = `${name}ウィンドウを開閉します。`;

            // アイコン用div
            const newDiv = document.createElement('div');
            newDiv.classList.add(icon);
            newButton.appendChild(newDiv);

            document.getElementById('axp_launcher_div_personalButtonsEntry').appendChild(newButton);
            this.launcherButtonElement = newButton;
        }

        let divDragzone = document.createElement('div');
        divDragzone.setAttribute('class', 'axpc_MSG axpc_window_header_dragZone');
        divDragzone.dataset.msg = 'ドラッグでツールウィンドウの位置を移動します。';
        divHeader.appendChild(divDragzone);

        divWindow.appendChild(divHeader);

        this.axpObj.ELEMENT.base.appendChild(divWindow);

        // 枠内にHTMLデータを展開
        divWindow.insertAdjacentHTML('beforeend', this.axpObj.translateHTML(html));
        this.windowElement = document.getElementById(id);
        this.name = name;

        //console.log('>', this.windowElement, this.name);
    }
    /**
     * ツールウィンドウの座標を設定する
     * @param {*} x
     * @param {*} y
     */
    setPosition(x, y) {
        // 指定なしの場合は現在座標（設定：自動調整を切り替えた場合に同一値でstyleを更新するために使用）
        let left = (x === undefined) ? this.window_left : x;
        let top = (y === undefined) ? this.window_top : y;

        if (this.axpObj.config('axp_config_form_windowAutoAdjust') === 'on') {
            // 設定：自動調整あり
            // ブラウザのリサイズ時に画面に収まるように最小値を設定
            ///this.windowElement.style.left = `min(100% - ${this.window_width}px, ${left}px)`;
            this.windowElement.style.left = `max(0px, min(100% - ${this.window_width}px, ${left}px))`;
            this.windowElement.style.top = `min(100% - 30px, ${top}px)`;
        } else {
            // 設定：自動調整なし px指定
            this.windowElement.style.left = `${left}px`;
            this.windowElement.style.top = `${top}px`;
        }
        // 現在値更新
        this.window_left = left;
        this.window_top = top;
        //console.log(this.id, this.windowElement.style.left, this.windowElement.style.top);
    }
    resetPosition() {
        let pos = this.getDefaultPosition();
        this.setPosition(pos.left, pos.top);
    }
    minimize() {
        // ツールウィンドウ消去
        this.windowElement.classList.add('axpc_window_minimize');
    }
    unminimize() {
        // ツールウィンドウ表示
        this.windowElement.classList.remove('axpc_window_minimize');
    }
    hidden() {
        // ツールウィンドウ消去
        this.windowElement.classList.add('axpc_window_hidden');
    }
    visible() {
        // ツールウィンドウ表示
        this.windowElement.classList.remove('axpc_window_hidden');
    }
}

/***/ }),

/***/ "./src/js/window_custom.js":
/*!*********************************!*\
  !*** ./src/js/window_custom.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CustomButtonSystem: () => (/* binding */ CustomButtonSystem)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./window.js */ "./src/js/window.js");
/* harmony import */ var _html_window_custom_txt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../html/window_custom.txt */ "./src/html/window_custom.txt");
// @description ツールウィンドウ：親クラス＞カスタムボタン



// css適用
__webpack_require__(/*! ../css/window_custom.css */ "./src/css/window_custom.css");

// カスタムボタンクラス
class CustomButtonSystem extends _window_js__WEBPACK_IMPORTED_MODULE_0__.ToolWindow {
    constructor(axpObj) {
        super(axpObj);
    }
    // 初期ウィンドウ位置
    getDefaultPosition() {
        return {
            left: 200,
            top: 10,
        }
    }
    // 初期化（＆キャンバスリセット時の再初期化）
    init() {
        // HTML
        this.createHTML(
            'axp_custom',
            'CSM',
            this.axpObj._('@WINDOW.CUSTOM_BUTTONS'),
            null,
            _html_window_custom_txt__WEBPACK_IMPORTED_MODULE_1__,
            false
        );
        this.window_width = 40;
        // 初期座標設定
        const pos = this.getDefaultPosition();
        this.window_left = pos.left;
        this.window_top = pos.top;
    }
    // イベント受付開始
    startEvent() {
        const buttons = document.querySelectorAll('#axp_custom button');
        for (const item of buttons) {
            item.addEventListener('click', () => {
                this.axpObj.callTask(`axp_config_custom_button${item.dataset.index}`, null);
            });
        }
    }
}


/***/ }),

/***/ "./src/js/window_launcher.js":
/*!***********************************!*\
  !*** ./src/js/window_launcher.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Launcher: () => (/* binding */ Launcher)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./window.js */ "./src/js/window.js");
/* harmony import */ var _html_window_launcher_txt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../html/window_launcher.txt */ "./src/html/window_launcher.txt");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./etc.js */ "./src/js/etc.js");
// @description ツールウィンドウ：親クラス＞ランチャー




// css適用
__webpack_require__(/*! ../css/window_launcher.css */ "./src/css/window_launcher.css");

// ランチャークラス
class Launcher extends _window_js__WEBPACK_IMPORTED_MODULE_0__.ToolWindow {
    constructor(axpObj) {
        super(axpObj);
    }
    minimizeWindowStack = [];
    // 初期ウィンドウ位置
    getDefaultPosition() {
        return {
            left: 0,
            top: 0,
        }
    }
    // 初期化（＆キャンバスリセット時の再初期化）
    init() {
        // HTML
        this.createHTML(
            'axp_launcher',
            'LAU',
            this.axpObj._('@WINDOW.LAUNCHER'),
            null,
            _html_window_launcher_txt__WEBPACK_IMPORTED_MODULE_1__,
            false
        );
        this.window_width = 54;
        // 初期座標設定
        const pos = this.getDefaultPosition();
        this.window_left = pos.left;
        this.window_top = pos.top;
    }
    // イベント受付開始
    startEvent() {
        // 個別のウィンドウボタン
        const personalButtons = document.querySelectorAll('.axpc_launcher_personalButton');
        for (const item of personalButtons) {
            // クリック時、ウィンドウ開閉
            item.addEventListener('click', (e) => {
                if (e.target.classList.contains('axpc_launcher_minimize')) {
                    // オープン
                    e.target.classList.remove('axpc_launcher_minimize');
                    this.axpObj.dragWindow.unminimize(e.target.dataset.id);
                    // 状態リセット
                    this.axpObj.configSystem.deleteConfig('WDMIN_' + e.target.dataset.id);
                    // 単一ウィンドウモードなら、他のウィンドウを最小化
                    if (document.getElementById('axp_config_checkbox_singleWindowMode').checked) {
                        for (const buttons of personalButtons) {
                            if (buttons.dataset.id !== item.dataset.id) {
                                if (!buttons.classList.contains('axpc_launcher_minimize')) {
                                    buttons.classList.add('axpc_launcher_minimize');
                                    this.axpObj.dragWindow.minimize(buttons.dataset.id);
                                    this.axpObj.configSystem.saveConfig('WDMIN_' + buttons.dataset.id, true);
                                }
                            }
                        }
                    }
                } else {
                    // 最小化
                    e.target.classList.add('axpc_launcher_minimize');
                    this.axpObj.dragWindow.minimize(e.target.dataset.id);
                    this.axpObj.configSystem.saveConfig('WDMIN_' + e.target.dataset.id, true);
                }
            });
        }
        // 全体ウィンドウボタン
        const allButton = document.querySelector('.axpc_launcher_allButton');
        allButton.addEventListener('click', (e) => {
            if (e.target.classList.contains('axpc_launcher_minimize')) {
                // ボタン変化
                e.target.classList.remove('axpc_launcher_minimize');
                e.target.querySelector('div').classList.remove('axpc_icon_window_all_up');
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show('axp_launcher_div_personalButtons');
                // 全体表示化
                this.axpObj.dragWindow.allVisible();
                // 状態リセット
                this.axpObj.configSystem.deleteConfig('WDMIN_' + allButton.dataset.id);
            } else {
                // ボタン変化
                e.target.classList.add('axpc_launcher_minimize');
                e.target.querySelector('div').classList.add('axpc_icon_window_all_up');
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide('axp_launcher_div_personalButtons');
                // 全体非表示化
                this.axpObj.dragWindow.allHidden();
                // 状態保存
                this.axpObj.configSystem.saveConfig('WDMIN_' + allButton.dataset.id, true);
            }
        });
        // ボタンサイズ
        this.setButtonSize(this.axpObj.config('axp_config_form_minimizeButtonType'));
    }
    // ツールウィンドウのIDに対応するボタンを最小化状態にする
    minimizeButton(id) {
        const buttons = document.querySelectorAll('.axpc_launcher_personalButton,.axpc_launcher_allButton');
        for (const item of buttons) {
            if (item.dataset.id === id) {
                item.classList.add('axpc_launcher_minimize');
                // 一括ボタンの場合はアイコン変化
                if (id === 'axp_all') {
                    item.querySelector('div').classList.add('axpc_icon_window_all_up');
                    _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide('axp_launcher_div_personalButtons');
                }
            }
        }
    }
    // ツールウィンドウのIDに対応するボタンをオープン状態にする
    unminimizeButton(id) {
        const buttons = document.querySelectorAll('.axpc_launcher_personalButton');
        for (const item of buttons) {
            if (item.dataset.id === id) {
                item.classList.remove('axpc_launcher_minimize');
            }
        }
    }
    // ボタンサイズの変更
    setButtonSize(value) {
        const buttons = document.querySelectorAll('.axpc_launcher_personalButton,.axpc_launcher_allButton');
        for (const item of buttons) {
            item.classList.remove('axpc_launcher_sizeSmall');
            item.classList.remove('axpc_launcher_sizeBig');
            switch (value) {
                case 'small':
                    item.classList.add('axpc_launcher_sizeSmall');
                    break;
                case 'big':
                    item.classList.add('axpc_launcher_sizeBig');
                    break;
            }
        }
    }
    // 単一ウィンドウモード
    setSingleWindowMode(value, isRestore = false) {
        const button = document.querySelector('.axpc_launcher_allButton');
        // 全体非表示ボタンの強制リセット
        if (button.classList.contains('axpc_launcher_minimize')) {
            // ボタン変化
            button.classList.remove('axpc_launcher_minimize');
            button.querySelector('div').classList.remove('axpc_icon_window_all_up');
            _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show('axp_launcher_div_personalButtons');
            // 全体表示化
            this.axpObj.dragWindow.allVisible();
            // 状態リセット
            this.axpObj.configSystem.deleteConfig('WDMIN_' + button.dataset.id);
        }
        if (value) {
            _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide(button);
            _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide('axp_launcher_separator');
            if (isRestore) {
                // 復元時は最小化スキップ
            } else {
                // 個別ウィンドウをすべて最小化
                const personalButtons = document.querySelectorAll('.axpc_launcher_personalButton');
                for (const item of personalButtons) {
                    if (!item.classList.contains('axpc_launcher_minimize')) {
                        item.classList.add('axpc_launcher_minimize');
                        this.axpObj.dragWindow.minimize(item.dataset.id);
                        this.axpObj.configSystem.saveConfig('WDMIN_' + item.dataset.id, true);
                    }
                }
            }
        } else {
            _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show(button);
            _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show('axp_launcher_separator');
            // 個別ウィンドウをすべて最小化解除
            const personalButtons = document.querySelectorAll('.axpc_launcher_personalButton');
            for (const item of personalButtons) {
                if (item.classList.contains('axpc_launcher_minimize')) {
                    item.classList.remove('axpc_launcher_minimize');
                    this.axpObj.dragWindow.unminimize(item.dataset.id);
                    this.axpObj.configSystem.deleteConfig('WDMIN_' + item.dataset.id);
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/js/window_layer.js":
/*!********************************!*\
  !*** ./src/js/window_layer.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LayerSystem: () => (/* binding */ LayerSystem),
/* harmony export */   Layerdata: () => (/* binding */ Layerdata)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./window.js */ "./src/js/window.js");
/* harmony import */ var _html_window_layer_txt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../html/window_layer.txt */ "./src/html/window_layer.txt");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./etc.js */ "./src/js/etc.js");
// @description ツールウィンドウ：親クラス＞レイヤー




// css適用
__webpack_require__(/*! ../css/window_layer.css */ "./src/css/window_layer.css");

const colorTagListDefault = [
    { name: '下描き', color: '#f33' },
    { name: '線画', color: '#fa3' },
    { name: '下塗り', color: '#ff3' },
    { name: '彩色', color: '#5f5' },
    { name: '陰影', color: '#5ff' },
    { name: 'ハイライト', color: '#55f' },
    { name: '背景', color: '#faf' },
    { name: 'その他', color: '#fff' },
];

/*
const colorTagListDefault = [
    { name: '下描き', color: '#aaf' },
    { name: '線画', color: '#aff' },
    { name: '下塗り', color: '#5f5' },
    { name: '彩色', color: '#ff0' },
    { name: '陰影', color: '#f33' },
    { name: 'ハイライト', color: '#fda' },
    { name: '背景', color: '#f5f' },
    { name: 'その他', color: '#fff' },
];
*/

class Layerdata {
    constructor(layerData) {
        this.id = layerData.id; // レイヤーのID、レイヤー要素を操作するときの紐づけに使用。重複がないように生成時に連番が振られる
        this.index = layerData.index; // 配列格納時の自身の添字（＝レイヤー表示順）アンドゥ時の復元処理で参照
        this.mode = layerData.mode; // 合成モード
        this.alpha = layerData.alpha; // 不透明度
        this.checked = layerData.checked; // 表示／非表示のチェック状態
        this.locked = layerData.locked; // ロック状態
        this.masked = layerData.masked; // 透明部分の保護状態
        this.name = layerData.name; // レイヤー名
        this.tag = layerData.tag; // カラータグ
        this.image = layerData.image; // 画像データ（imageData）
    }
}

class LayerSystem extends _window_js__WEBPACK_IMPORTED_MODULE_0__.ToolWindow {
    // レイヤーの名前番号に使用するカウンタ
    layer_counter = 0;
    // 選択しているレイヤー要素
    currentLayer = null;
    // レイヤー情報管理用配列（内部的に添え字０を最上位レイヤーとし、添え字順により下位のレイヤーとする）
    layerObj = [];
    // 合成背景
    CANVAS = {
        // 透過背景用仮想キャンバス
        backscreen_trans: null,
        backscreen_trans_ctx: null,
        // 白地背景用仮想キャンバス
        backscreen_white: null,
        backscreen_white_ctx: null,
        // 一時作業用
        tmp: null,
        tmp_ctx: null,
        merge: null,
        merge_ctx: null,
        thumbnail_ctx: [],
        clip: null,
        clip_ctx: null,
        // safariの場合、描画時にレイヤーの枚数分のcanvasをワークエリアとして使用する
        layer_ctx: [],
    };
    CONST = {
        // 最大レイヤー数
        LAYER_MAX: 8,
        // レイヤーのサムネイル表示のサイズ
        X_LAYER_MAX: 40,
        Y_LAYER_MAX: 40,
    }
    // 描画処理用の一時保存イメージ
    imageForUndo;
    // カラータグリスト
    colorTagList = null;
    constructor(axpObj) {
        super(axpObj);
    }
    // 初期ウィンドウ位置
    getDefaultPosition() {
        return {
            left: 0,
            top: 400,
        }
    }
    init() {
        this.createHTML(
            'axp_layer',
            'LAY',
            this.axpObj._('@WINDOW.LAYER'),
            'axpc_icon_window_layer',
            _html_window_layer_txt__WEBPACK_IMPORTED_MODULE_1__
        );
        this.window_width = 180;
        // 初期座標設定
        const pos = this.getDefaultPosition();
        this.window_left = pos.left;
        this.window_top = pos.top;
        // 合成背景
        this.CANVAS.backscreen_white = document.createElement('canvas');
        //this.CANVAS.backscreen_white_ctx = this.CANVAS.backscreen_white.getContext('2d', { willReadFrequently: true });
        this.CANVAS.backscreen_white_ctx = this.CANVAS.backscreen_white.getContext('2d');
        this.CANVAS.backscreen_trans = document.createElement('canvas');
        //this.CANVAS.backscreen_trans_ctx = this.CANVAS.backscreen_trans.getContext('2d', { willReadFrequently: true });
        this.CANVAS.backscreen_trans_ctx = this.CANVAS.backscreen_trans.getContext('2d');
        // ワークエリア
        this.CANVAS.tmp = document.createElement('canvas');
        //this.CANVAS.tmp_ctx = this.CANVAS.tmp.getContext('2d', { willReadFrequently: true });
        this.CANVAS.tmp_ctx = this.CANVAS.tmp.getContext('2d');
        // マージ用
        this.CANVAS.merge = document.createElement('canvas');
        this.CANVAS.merge_ctx = this.CANVAS.merge.getContext('2d');
        // クリッピング用
        this.CANVAS.clip = document.createElement('canvas');
        this.CANVAS.clip_ctx = this.CANVAS.clip.getContext('2d');
    }
    resetCanvas() {
        this.x_size = this.axpObj.x_size;
        this.y_size = this.axpObj.y_size;

        this.CANVAS.backscreen_white.width = this.x_size;
        this.CANVAS.backscreen_white.height = this.y_size;
        this.CANVAS.backscreen_trans.width = this.x_size;
        this.CANVAS.backscreen_trans.height = this.y_size;
        this.CANVAS.tmp.width = this.x_size;
        this.CANVAS.tmp.height = this.y_size;
        this.CANVAS.merge.width = this.x_size;
        this.CANVAS.merge.height = this.y_size;
        this.CANVAS.clip.width = this.x_size;
        this.CANVAS.clip.height = this.y_size;

        this.layer_counter = 0;
        this.currentLayer = null;
        this.layerObj.splice(0);
        this.CANVAS.thumbnail_ctx.splice(0);
        // safari
        if (this.axpObj.ENV.multiCanvas) {
            this.CANVAS.layer_ctx.splice(0);
        }
        // レイヤー表示の削除
        const elem_layerbox = document.getElementById('axp_layer_ul_layerBox');
        while (elem_layerbox.firstChild) {
            elem_layerbox.removeChild(elem_layerbox.firstChild);
        }
    }
    // イベント受付開始
    startEvent() {
        // セレクトボックス：レイヤー合成モード
        document.getElementById('axp_layer_select_blendMode').addEventListener('change', (e) => {
            // レイヤー合成モード変更
            this.setBlendMode(e.target.value);
            this.updateCanvas();
            // ポインタが移動して他のenterイベントを発生させてしまうため、メッセージ表示なし
        });

        // レンジスライダー：レイヤー不透明度
        document.getElementById('axp_layer_range_alpha').addEventListener('input', (e) => {
            // 透明度を変更
            const alpha = Number(e.target.value);
            this.setAlpha(alpha);
            this.updateCanvas();
            // %1の不透明度：%2
            this.axpObj.msg('@AXP0003', this.getName(), alpha);
        });

        // カラータグリストのユーザー設定データがない場合デフォルト値を使用する
        if (this.colorTagList === null) {
            this.resetColorTagList();
        }

        // 画面のレイヤー名更新
        const updateLayerName = (nameText) => {
            this.currentLayer.querySelector('.axpc_layer_span_cellName').textContent = nameText;
        }
        // 画面のタグ色更新
        const updateTagColor = (color) => {
            this.currentLayer.querySelector('.axpc_layer_div_cellColorTag').style.backgroundColor = color;
        }
        const cancelRename = () => {
            // サブウィンドウクローズ
            this.axpObj.closeSubwindow('axp_renamelayer');
        }
        // サブウィンドウ
        document.getElementById('axp_renamelayer').addEventListener('click', () => {
            cancelRename();
        });
        document.querySelector('#axp_renamelayer>div').addEventListener('click', (e) => {
            // サブウィンドウ内クリックでウィンドウが閉じないように、親へのイベント伝播を中止
            e.stopPropagation();
        });
        // キャンセルボタン
        document.getElementById('axp_renamelayer_button_close').addEventListener('click', () => {
            cancelRename();
        });

        const confirmRename = () => {
            // 入力された新レイヤー名（内部的に20文字以内※入力は10文字までしかできない）
            let newName =
                this.normalizeLayerName(
                    document.getElementById('axp_renamelayer_text_newLayerName').value,
                    20
                );
            if (newName === '') {
                // レイヤー名を空白にすることはできません。
                this.axpObj.msg('@CAU4007');
            } else {
                // 画面上のレイヤー名の更新
                updateLayerName(newName);
                // レイヤーオブジェクトの更新
                this.setName(newName);
                // レイヤー名を%1に変更しました。
                this.axpObj.msg('@INF4005', newName);
                this.axpObj.closeSubwindow('axp_renamelayer');
            }
        }
        // 決定ボタン
        document.getElementById('axp_renamelayer_button_confirm').addEventListener('click', (e) => {
            // ボタン有効時のみ処理
            if (e.target.dataset.enabled === 'true') {
                confirmRename();
            }
        });
        document.getElementById('axp_renamelayer_button_confirm').addEventListener('pointerenter', (e) => {
            // 状態に応じてメッセージを変える
            if (e.target.dataset.enabled === 'true') {
                this.axpObj.msg('@AXP4010');
            } else {
                this.axpObj.msg('@AXP4013');
            }
        });
        // エンターキーで決定
        document.getElementById('axp_renamelayer_text_newLayerName').addEventListener('keydown', (e) => {
            // e.keyが有効の場合のみ処理する（オートコンプリートによるイベントを無視）
            if (!e.key) return;
            if (e.key === 'Enter') {
                // 状態（レイヤー名に変更があったか）に応じて決定とキャンセルを分岐
                if (document.getElementById('axp_renamelayer_button_confirm').dataset.enabled === 'true') {
                    confirmRename();
                } else {
                    cancelRename();
                }
            }
        });
        // テキスト入力時
        document.getElementById('axp_renamelayer_text_newLayerName').addEventListener('input', () => {
            // 決定ボタン有効化
            document.getElementById('axp_renamelayer_button_confirm').dataset.enabled = 'true';
        });
        // 色解除
        document.getElementById('axp_renamelayer_button_colorReset').addEventListener('click', () => {
            this.setTag(-1);
            updateTagColor(this.getTagBackground(-1));
            // レイヤーに付与した色を解除しました。
            this.axpObj.msg('@INF4009');
        });

        // カラータグ
        const elementColorTagButton = document.getElementById('axp_renamelayer_div_colorTag');
        const elementColorTagButtonConfig = document.getElementById('axp_config_div_colorTag');

        for (let idx = 0; idx < this.colorTagList.length; idx++) {
            const newButton = elementColorTagButton.appendChild(
                this.createTagHTML(this.colorTagList[idx])
            );
            newButton.addEventListener('click', () => {
                const name = this.colorTagList[idx].name;
                // 登録されている単語を新しい名前とする
                // 既に同じ名前が使用されている場合、(2)、(3)と番号をつける
                const newName = this.replaceDuplicateLayerName(name);
                const newColor = this.colorTagList[idx].color;
                // 画面上のレイヤー名、タグ色の更新
                updateLayerName(newName);
                updateTagColor(newColor);
                // レイヤーオブジェクトの更新
                this.setName(newName);
                this.setTag(idx);
                // レイヤー名を%1に変更しました。
                this.axpObj.msg('@INF4005', newName);
                this.axpObj.closeSubwindow('axp_renamelayer');
            });
            newButton.addEventListener('pointerenter', () => {
                // 登録された名前に変更し、色を付与します。
                this.axpObj.msg('@AXP4012');
            });

            // 設定タブ用UI
            const newConfig = elementColorTagButtonConfig.appendChild(
                this.createTagConfigHTML(this.colorTagList[idx], idx)
            );
            // タグ名変更時の処理
            newConfig.querySelector('input').addEventListener('change', (e) => {
                // ８文字以内
                let newName = this.normalizeLayerName(e.target.value, 8);
                if (newName === '') {
                    e.target.value = this.colorTagList[idx].name;
                    // カラータグ名を空白にすることはできません。
                    this.axpObj.msg('@CAU4008');
                } else {
                    // 正規化した名前を自身に反映
                    e.target.value = newName;
                    // カラータグリスト更新
                    this.colorTagList[idx].name = newName;
                    // レイヤー名変更サブウィンドウのボタン表示に反映
                    document.querySelectorAll('.axpc_renamelayer_button_colorTag')[idx].textContent = newName;
                    // コンフィグ保存
                    this.axpObj.configSystem.saveConfig('COTAG', this.colorTagList);
                    // カラータグ名を%1に変更しました。
                    this.axpObj.msg('@INF4008', newName);
                }
            });
        }

        document.getElementById('axp_renamelayer_button_flipH').addEventListener('click', () => {
            this.flip_h();
            // 選択中レイヤーの左右を反転しました。
            this.axpObj.msg('@INF1001');
            // アンドゥ用記録
            this.axpObj.undoSystem.setUndo({
                type: 'flip_h',
                id: this.axpObj.layerSystem.getId(),
            });
        });
        document.getElementById('axp_renamelayer_button_flipV').addEventListener('click', () => {
            this.flip_v();
            // 選択中レイヤーの上下を反転しました。
            this.axpObj.msg('@INF1003');
            // アンドゥ用記録
            this.axpObj.undoSystem.setUndo({
                type: 'flip_v',
                id: this.axpObj.layerSystem.getId(),
            });
        });
    }
    // 重複しない新規レイヤー名を取得
    getNewLayerName() {
        const checkDuplicateLayerName = (name, depth = 1) => {
            let testName = `${name}${depth}`;
            let resultName;
            let isDuplicate = false;
            for (let idx = 0; idx < this.layerObj.length; idx++) {
                if (testName == this.layerObj[idx].name) {
                    // 同じ名前が存在したら重複フラグを立てる
                    isDuplicate = true;
                    break;
                }
            }
            if (isDuplicate) {
                // 深度を+1して再帰、重複しない番号を特定する
                resultName = checkDuplicateLayerName(name, depth + 1);
            } else {
                resultName = testName;
            }
            return resultName;
        }
        return checkDuplicateLayerName(this.axpObj._('@LAYER.NEWLAYER_TEMPLATE'));
    }
    // 重複したレイヤー名を書き換え（カラータグ用） 引数depthは指定不要
    replaceDuplicateLayerName(name, depth = 1) {
        let testName;
        let resultName;
        let isDuplicate = false;
        if (depth === 1) {
            // 初回時
            testName = name;
        } else {
            // 再帰時
            testName = `${name}(${depth})`;
        }
        for (let idx = 0; idx < this.layerObj.length; idx++) {
            console.log(this.layerObj[idx].name);
            if (idx === this.getLayerIndex(this.currentLayer.dataset.id)) {
                // 自分自身（名前変更中のレイヤー）の重複チェックをスキップ
                console.log(this.layerObj[idx].name, 'は変更中のレイヤー自身');
            } else {
                if (testName == this.layerObj[idx].name) {
                    // 名前が一緒なら重複フラグを立てる
                    isDuplicate = true;
                    break;
                }
            }
        }
        console.log('重複', isDuplicate);
        if (isDuplicate) {
            // 深度を+1して再帰、重複しない番号を特定する
            resultName = this.replaceDuplicateLayerName(name, depth + 1);
        } else {
            resultName = testName;
        }
        return resultName;
    }
    // レイヤー名変更時のレイヤー名正規化
    normalizeLayerName(layerName, length) {
        let newName;
        // 前後の空白を除去
        newName = layerName.trim();
        // length文字以内にトリミング
        newName = newName.substring(0, length);
        //console.log('newName:', newName, newName.length);
        return newName;
    }
    // カラータグリスト配列をデフォルト値に初期化
    resetColorTagList(list = null) {
        // 引数にリスト指定あり（設定復元時）ならばリストを参照。無指定の場合デフォルトのリスト
        let referenceList = (list !== null) ? list : colorTagListDefault;
        this.colorTagList = [];
        for (let idx = 0; idx < referenceList.length; idx++) {
            this.colorTagList.push(
                {
                    name: referenceList[idx].name,
                    // ※現在のバージョンではcolorは復元せずデフォルト値を使用する
                    color: colorTagListDefault[idx].color
                }
            );
        }
    }
    // カラータグを最新の状態に更新
    updateAllColorTag() {
        for (let idx = 0; idx < this.colorTagList.length; idx++) {
            // レイヤー名変更サブウィンドウのボタン表示を更新
            document.querySelectorAll('.axpc_renamelayer_button_colorTag')[idx].textContent = this.colorTagList[idx].name;
            // 設定タブのテキスト表示を更新
            document.querySelectorAll('.axpc_config_text_colorTag')[idx].value = this.colorTagList[idx].name;
        }
    }
    createTagHTML(objTag) {
        const newButton = document.createElement('button');
        newButton.setAttribute('class', 'axpc_renamelayer_button_colorTag');
        newButton.textContent = objTag.name;
        newButton.style.background = `linear-gradient(90deg,#555, #555 89%, ${objTag.color} 90%)`;
        return newButton;
    }
    createTagConfigHTML(objTag, idx) {
        const newDiv = document.createElement('div');
        newDiv.setAttribute('class', 'axpc_config_div_colorTag');
        newDiv.style.background = `linear-gradient(90deg,#777, #777 89%, ${objTag.color} 90%)`;
        const newInput = document.createElement('input');
        newInput.setAttribute('type', 'text');
        newInput.setAttribute('id', `axp_config_text_colorTag${idx}`);
        newInput.setAttribute('class', 'axpc_config_text_colorTag');
        newInput.value = objTag.name;
        newDiv.appendChild(newInput);
        return newDiv;
    }
    deleteLayer(id) {
        //要素の取得
        var target;
        var elements = document.querySelectorAll('#axp_layer_ul_layerBox>li');


        // 対象レイヤーを検出（リドゥ処理の場合、選択しているレイヤーが対象とは限らない為、IDで特定が必要）
        var idx_delete;
        for (let i = 0; i < elements.length; i++) {
            if (elements[i].dataset.id == id) {
                target = elements[i];
                idx_delete = i;
                break;
            }
        }
        // 削除後に選択される要素のインデックス（最上位[0]を削除する場合はそのまま）
        if (idx_delete >= 1) {
            idx_delete--;
        }

        var idx = this.getLayerIndex(id);
        this.layerObj.splice(idx, 1);
        this.CANVAS.thumbnail_ctx.splice(idx, 1);
        // safari
        if (this.axpObj.ENV.multiCanvas) {
            this.CANVAS.layer_ctx.splice(idx, 1);
        }
        // 添字情報の更新
        this.updateLayerIndex();

        var div1 = document.getElementById('axp_layer_ul_layerBox');
        div1.removeChild(target);

        elements = document.querySelectorAll('#axp_layer_ul_layerBox>li');
        // 選択中のレイヤーを検出
        var found = false;
        for (let i = 0; i < elements.length; i++) {
            if (elements[i].dataset.selected == 'true') {
                found = true;
                break;
            }
        }
        if (!found) {
            // 選択中のレイヤーを削除した場合、削除レイヤーの１つ上を自動選択する
            this.setCurrentLayer(elements[idx_delete]);
        }
    }
    clear(id) {
        // 引数で指定されたIDのimageDataを初期化
        // アンドゥ時に元のimagedataが必要となるため、更新ではなく新規のimagedataを作成する
        this.layerObj[this.getLayerIndex(id)].image =
            this.CANVAS.tmp_ctx.createImageData(this.axpObj.x_size, this.axpObj.y_size);
    }
    getLocked(index = null) {
        if (index) {
            return this.layerObj[index].locked;
        } else {
            return this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].locked;
        }
    }
    getChecked(index = null) {
        if (index) {
            return this.layerObj[index].checked;
        } else {
            return this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].checked;
        }
    }
    getMasked(index = null) {
        if (index) {
            return this.layerObj[index].masked;
        } else {
            return this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].masked;
        }
    }
    getTag(index = null) {
        if (index) {
            return this.layerObj[index].tag;
        } else {
            return this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].tag;
        }
    }
    getTagBackground(index) {
        if (index === -1) {
            return '#00000000';
        } else {
            return this.colorTagList[index].color;
        }
    }
    getAlpha(index = null) {
        if (index) {
            return this.layerObj[index].alpha;
        } else {
            return this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].alpha;
        }
    }
    // 指定されたindexに対応するレイヤーセル要素<li>を取得
    getLayerElement(index) {
        const elementLi = document.querySelector(`#axp_layer_ul_layerBox>li:nth-of-type(${index + 1})`);
        //console.log(this.layerObj[index].name, elementLi.dataset.id);
        return elementLi;
    }
    // クリッピング状態
    getClupMode() {
        return this.currentLayer.querySelector('.axpc_layer_div_cellCliping').dataset.mode;
    }
    // クリッピングレイヤーの親のレイヤー名
    getClupParentName() {
        let idx = this.getLayerIndex(this.currentLayer.dataset.id) + 1;
        let result = '';
        while (idx < this.layerObj.length) {
            if (this.layerObj[idx].mode !== 'source-atop') break;
            idx++;
        }
        if (idx < this.layerObj.length) {
            result = this.layerObj[idx].name;
        } else {
            // 親が存在しないケース
            console.log('エラー：getClupParentName呼び出し異常');
        }
        return result;
    }
    setAlpha(alpha, index = null) {
        if (index) {
            // 指定indexのレイヤー
            this.layerObj[index].alpha = alpha;
            // 不透明度に応じて目のアイコンの背景を変化させる
            const elementEye = this.getLayerElement(index).querySelector('.axpc_layer_div_cellButtonEye');
            elementEye.style.background = this.getEyeBackground(alpha);
        } else {
            // 現在選択中のレイヤー
            this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].alpha = alpha;
            // 不透明度に応じて目のアイコンの背景を変化させる
            const elementEye = this.currentLayer.querySelector('.axpc_layer_div_cellButtonEye');
            elementEye.style.background = this.getEyeBackground(alpha);
        }
    }
    getName(index = null) {
        if (index) {
            return this.layerObj[index].name;
        } else {
            return this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].name;
        }
    }
    getMode() {
        return this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].mode;
    }
    getId() {
        return this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].id;
    }
    getIndex() {
        let index;
        if (this.currentLayer === null) {
            // カレントレイヤーが選択されていない（起動時、初期化時）場合は0
            index = 0;
        } else {
            index = this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].index;
        }
        return index;
    }
    getImage() {
        return this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].image;
    }
    // 全レイヤー合成済みのimagedata
    getCanvasImage() {
        if (this.axpObj.assistToolSystem.getIsTransparent()) {
            return this.CANVAS.backscreen_trans_ctx.getImageData(0, 0, this.axpObj.x_size, this.axpObj.y_size);
        } else {
            return this.CANVAS.backscreen_white_ctx.getImageData(0, 0, this.axpObj.x_size, this.axpObj.y_size);
        }
    }
    // 全レイヤー合成済みのcanvas
    getCanvas() {
        if (this.axpObj.assistToolSystem.getIsTransparent()) {
            return this.CANVAS.backscreen_trans;
        } else {
            return this.CANVAS.backscreen_white;
        }
    }
    getCurrentLayerImage() {
        return this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].image;
    }
    write(imageData) {
        // imagedataの更新
        this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].image = imageData;
    }
    setImageId(imageData, id) {
        this.layerObj[this.getLayerIndex(id)].image = imageData;
    }
    setName(name) {
        this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].name = name;
    }
    setBlendMode(blendMode) {
        this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].mode = blendMode;
        // レイヤーセルに合成モードを表示
        this.displayBlendMode(this.currentLayer);
    }
    setTag(tagNumber) {
        this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].tag = tagNumber;
    }
    displayBlendMode(elementLayer) {
        const elementStatus = elementLayer.querySelector('.axpc_layer_span_cellStatus');
        const blendMode = this.layerObj[this.getLayerIndex(elementLayer.dataset.id)].mode;
        if (this.axpObj.config('axp_config_form_blendModeDisplayType') === 'none') {
            // 設定が表示なしの時
            elementStatus.textContent = '';
        } else {
            if (this.axpObj.config('axp_config_form_blendModeDisplayType') === 'unusual' && blendMode === 'source-over') {
                // 設定が通常以外表示で合成モードが通常の時
                elementStatus.textContent = '';
            } else {
                // セレクトボックスから、レイヤーに設定されている合成モード値に一致するoptionを取得
                const option = document.querySelector(`#axp_layer_select_blendMode>option[value='${blendMode}']`);
                // optionの表示名を取得
                const name = option.textContent;
                elementStatus.textContent = name;
            }
        }
        // クリッピング時用のdataset設定
        const elementCliping = elementLayer.querySelector('.axpc_layer_div_cellCliping');
        elementCliping.dataset.mode = blendMode;
        const elementRightSide = elementLayer.querySelector('.axpc_layer_div_cellRightSide');
        elementRightSide.dataset.mode = blendMode;

    }
    // 全レイヤーの合成モード表示更新
    updateBlendModeDisplayAll() {
        const elementsLayer = document.querySelectorAll('#axp_layer_ul_layerBox>li');
        for (const item of elementsLayer) {
            this.displayBlendMode(item);
        }
    }
    setLayerCounter(count) {
        this.layer_counter = count;
    }
    // 書き込み禁止状態であるか
    isWriteProtection(index = null) {
        if (this.getLocked(index) || !this.getChecked(index) || this.getAlpha(index) == 0) {
            return true;
        } else {
            return false;
        }
    }
    // 書き込み禁止の理由テキスト
    getReasonTextForWriteProtection(index = null) {
        let reasonText = null;
        // レイヤーの不透明度が0%
        if (this.getAlpha(index) == 0) {
            reasonText = '不透明度0%';
        }
        // レイヤーが非表示
        if (!this.getChecked(index)) {
            reasonText = '非表示';
        }
        // レイヤーがロック状態
        if (this.getLocked(index)) {
            reasonText = 'ロック状態';
        }
        return reasonText;
    }
    save() {
        // 描画開始時の状態を一時保存
        this.imageForUndo = this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].image;
        //console.log(this.imageForUndo);
    }
    load() {
        // 描画開始時の状態を一時保存
        return this.imageForUndo;
        //console.log(this.imageForUndo);
    }
    flip_h(target) {
        if (target == 'all') {
            // 全体
            console.log('全体');
            for (const item of this.layerObj) {
                (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.flip_horizontal)(item.image);
            }
        } else if (!isNaN(target)) {
            // ID指定
            console.log('ID指定', target);
            (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.flip_horizontal)(this.layerObj[this.getLayerIndex(target)].image);
        } else {
            // 現在選択中のレイヤー（引数指定なし）
            console.log('単体');
            (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.flip_horizontal)(this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].image);
        }
        this.draw();
        this.drawThumbnail();
    }
    flip_v(target) {
        if (target == 'all') {
            // 全体
            console.log('全体');
            for (const item of this.layerObj) {
                (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.flip_vertical)(item.image);
            }
        } else if (!isNaN(target)) {
            // 添え字指定
            console.log('ID指定', target);
            (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.flip_vertical)(this.layerObj[this.getLayerIndex(target)].image);
        } else {
            // 現在選択中のレイヤー（引数指定なし）
            console.log('単体');
            (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.flip_vertical)(this.layerObj[this.getLayerIndex(this.currentLayer.dataset.id)].image);
        }
        this.draw();
        this.drawThumbnail();
    }
    // 共通処理：対象のレイヤー情報が格納されている配列の添字をIDを使って検索
    getLayerIndex(id) {
        var idx = -1;
        for (var i = 0; i < this.layerObj.length; i++) {
            if (this.layerObj[i].id == id) {
                idx = i;
                break;
            }
        }
        return idx;
    }
    // レイヤー新規
    newLayer() {
        // カウントアップ
        this.layer_counter++;
        // レイヤー生成情報
        let layerData = {
            x_size: this.axpObj.x_size,
            y_size: this.axpObj.y_size,
            id: this.layer_counter,
            name: this.getNewLayerName(),
            alpha: 100,
            mode: 'source-over',
            checked: true,
            locked: false,
            masked: false,
            tag: -1,
            // 空のイメージを生成
            image: this.CANVAS.tmp_ctx.createImageData(this.axpObj.x_size, this.axpObj.y_size),
            // 挿入位置：カレントレイヤーの一つ上に追加
            insert_idx: this.getIndex(),
        }
        this.createLayer(layerData);
        return layerData.id;
    }
    // レイヤー複製
    copyLayer(sourceObj) {
        // カウントアップ
        this.layer_counter++;
        // レイヤー生成情報
        let layerData = {
            x_size: this.axpObj.x_size,
            y_size: this.axpObj.y_size,
            id: this.layer_counter,
            name: this.getNewLayerName(),
            alpha: sourceObj.alpha,
            mode: sourceObj.mode,
            checked: sourceObj.checked,
            locked: sourceObj.locked,
            masked: sourceObj.masked,
            tag: sourceObj.tag,
            // 空のイメージを生成
            image: this.CANVAS.tmp_ctx.createImageData(this.axpObj.x_size, this.axpObj.y_size),
            // 挿入位置：カレントレイヤーの一つ上に追加
            insert_idx: this.getIndex(),
        }
        // imageDataオブジェクトのコピー
        layerData.image.data.set(sourceObj.image.data);

        this.createLayer(layerData);
        return layerData.id;
    }
    // レイヤー復元（ロード／自動保存から復元／削除したレイヤーのアンドゥ）
    restoreLayer(actionObj) {
        let layerData = {
            x_size: this.axpObj.x_size,
            y_size: this.axpObj.y_size,
            id: actionObj.layerObj.id,
            name: actionObj.layerObj.name,
            alpha: actionObj.layerObj.alpha,
            mode: actionObj.layerObj.mode,
            checked: actionObj.layerObj.checked,
            locked: actionObj.layerObj.locked,
            masked: actionObj.layerObj.masked,
            // セーブデータにtagが含まれていない場合、初期値-1を設定（version 1.99.55カラータグ実装以前のセーブデータの互換性維持）
            tag: actionObj.layerObj.tag === undefined ? -1 : actionObj.layerObj.tag,
            // 元のイメージを復元
            image: actionObj.layerObj.image,
            // 挿入位置：レイヤーが存在した元の位置に挿入
            insert_idx: actionObj.layerObj.index,
        }
        this.createLayer(layerData);
        return layerData.id;
    }
    // レイヤー作成
    createLayer(layerData) {
        // 要素を作成する
        const newLayer = this.createLayerHTML(layerData);
        const insert_idx = layerData.insert_idx;

        // レイヤーボックスに要素を挿入
        const divElement = document.getElementById('axp_layer_ul_layerBox');
        divElement.insertBefore(
            newLayer,
            divElement.children[insert_idx]
        );

        // safari
        if (this.axpObj.ENV.multiCanvas) {
            // レイヤー毎のキャンバスctx
            const layercanvas = document.createElement('canvas');
            layercanvas.width = this.x_size;
            layercanvas.height = this.y_size;
            const layercanvas_ctx = layercanvas.getContext('2d');
            this.CANVAS.layer_ctx.splice(insert_idx, 0, layercanvas_ctx);
        }

        // サムネctx
        let canvas = newLayer.querySelector('canvas');
        let canvas_ctx = canvas.getContext('2d');
        // 実際のキャンバスサイズと、サムネ表示エリアのサイズより倍率を算出（縦横大きい方を基準値とする）
        canvas_ctx.setTransform(1, 0, 0, 1, 0, 0);
        canvas_ctx.scale(
            this.CONST.X_LAYER_MAX / Math.max(this.x_size, this.y_size),
            this.CONST.X_LAYER_MAX / Math.max(this.x_size, this.y_size)
        );
        this.CANVAS.thumbnail_ctx.splice(insert_idx, 0, canvas_ctx);

        // レイヤーを管理用の配列に登録
        this.layerObj.splice(insert_idx, 0, new Layerdata(layerData));
        // 添字情報の更新
        this.updateLayerIndex();

        // カレントレイヤー更新
        this.setCurrentLayer(newLayer);

        // 合成モード表示更新
        this.displayBlendMode(newLayer);

        return layerData.id;
    }
    // レイヤーの不透明度に応じた表示切替用のボタンの背景を取得
    getEyeBackground(alpha) {
        return `linear-gradient(0deg, #ddd, #ddd ${alpha - 1}%, #999 ${alpha}%)`;
    }
    createLayerHTML(layerData) {

        // 表示切替用の目のアイコン
        const newDivEyeIcon = document.createElement('div');
        newDivEyeIcon.setAttribute('data-id', layerData.id);
        newDivEyeIcon.setAttribute('class', 'axpc_layer_div_cellButtonEyeIcon');
        if (layerData.checked) {
            newDivEyeIcon.classList.add('axpc_icon_eyeON');
        } else {
            newDivEyeIcon.classList.add('axpc_icon_eyeOFF');
        }

        // レイヤー表示状態の切り替え
        newDivEyeIcon.addEventListener('pointerenter', (e) => {
            // ポインターが進入した時
            let msgtext = e.target.classList.contains('axpc_icon_eyeON') ? '表示' : '非表示';
            // レイヤーの表示状態を切り替えます。(現在の状態:%1)
            this.axpObj.msg('@AXP4000', '表示状態', msgtext);

            // マウスイベントの場合、ドラッグでオン／オフできるようにする
            // （タッチパッドの場合、enterとdownが同時に発生して競合するため対象外）
            if (e.pointerType === 'mouse') {
                if (e.buttons === 1) {
                    if (!this.axpObj.isDrawing) {
                        if (e.target.classList.contains('axpc_icon_eyeON')) {
                            console.log('off');
                            e.target.classList.remove('axpc_icon_eyeON');
                            e.target.classList.add('axpc_icon_eyeOFF');
                            this.layerObj[this.getLayerIndex(e.target.dataset.id)].checked = false;
                        } else {
                            console.log('on');
                            e.target.classList.remove('axpc_icon_eyeOFF');
                            e.target.classList.add('axpc_icon_eyeON');
                            this.layerObj[this.getLayerIndex(e.target.dataset.id)].checked = true;
                        }
                        msgtext = e.target.classList.contains('axpc_icon_eyeON') ? '表示' : '非表示';
                        // レイヤーの%1を切り替えました。(現在の状態:%2)
                        this.axpObj.msg('@INF4006', '表示状態', msgtext);
                        this.updateCanvas();
                    }
                }
            }
        }, false);
        // レイヤーの表示状態の切り替え
        newDivEyeIcon.addEventListener('pointerdown', (e) => {
            e.stopPropagation();
            if (e.target.classList.contains('axpc_icon_eyeON')) {
                console.log('off');
                e.target.classList.remove('axpc_icon_eyeON');
                e.target.classList.add('axpc_icon_eyeOFF');
                this.layerObj[this.getLayerIndex(e.target.dataset.id)].checked = false;
            } else {
                console.log('on');
                e.target.classList.remove('axpc_icon_eyeOFF');
                e.target.classList.add('axpc_icon_eyeON');
                this.layerObj[this.getLayerIndex(e.target.dataset.id)].checked = true;
            }
            var msgtext = e.target.classList.contains('axpc_icon_eyeON') ? '表示' : '非表示';
            // レイヤーの%1を切り替えました。(現在の状態:%2)
            this.axpObj.msg('@INF4006', '表示状態', msgtext);
            this.updateCanvas();
        }, false);

        // 表示切替用のボタン（目のアイコンの枠）
        const newDivEye = document.createElement('div');
        newDivEye.setAttribute('class', 'axpc_layer_div_cellButtonEye');
        newDivEye.setAttribute('data-id', layerData.id);
        // 不透明度に応じた背景の生成
        newDivEye.style.background = this.getEyeBackground(layerData.alpha);
        newDivEye.appendChild(newDivEyeIcon);

        // チェックボックス（ロック）
        var newCheckbox_lock = document.createElement('div');
        if (layerData.locked) {
            newCheckbox_lock.setAttribute('class', 'axpc_layer_div_cellButton axpc_icon_lockON');
        } else {
            newCheckbox_lock.setAttribute('class', 'axpc_layer_div_cellButton axpc_icon_lockOFF');
        }
        newCheckbox_lock.setAttribute('data-id', layerData.id);

        newCheckbox_lock.addEventListener('pointerenter', (e) => {
            // ポインターが進入した時
            var msgtext = e.target.classList.contains('axpc_icon_lockON') ? 'ロック' : 'なし';
            // レイヤーの%1を切り替えます。(現在の状態:%2)
            this.axpObj.msg('@AXP4000', 'ロック状態', msgtext);
        }, false);
        // レイヤーのロック状態の切り替え
        newCheckbox_lock.addEventListener('pointerdown', (e) => {
            e.stopPropagation();
            if (e.target.classList.contains('axpc_icon_lockON')) {
                e.target.classList.remove('axpc_icon_lockON');
                e.target.classList.add('axpc_icon_lockOFF');
                this.layerObj[this.getLayerIndex(e.target.dataset.id)].locked = false;
            } else {
                e.target.classList.remove('axpc_icon_lockOFF');
                e.target.classList.add('axpc_icon_lockON');
                this.layerObj[this.getLayerIndex(e.target.dataset.id)].locked = true;
            }
            var msgtext = e.target.classList.contains('axpc_icon_lockON') ? 'ロック' : 'なし';
            // レイヤーの%1を切り替えました。(現在の状態:%2)
            this.axpObj.msg('@INF4006', 'ロック状態', msgtext);
        }, false);

        // チェックボックス（透明部分のロック）
        let newCheckbox_mask = document.createElement('div');
        if (layerData.masked) {
            // クラス名axpc_layer_div_cellButtonはロックと共用
            newCheckbox_mask.setAttribute('class', 'axpc_layer_div_cellButton axpc_icon_maskON');
        } else {
            newCheckbox_mask.setAttribute('class', 'axpc_layer_div_cellButton axpc_icon_maskOFF');
        }
        newCheckbox_mask.setAttribute('data-id', layerData.id);
        newCheckbox_mask.addEventListener('pointerenter', (e) => {
            // ポインターが進入した時
            var msgtext = e.target.classList.contains('axpc_icon_maskON') ? 'ロック' : 'なし';
            // レイヤーの%1を切り替えます。(現在の状態:%2)
            this.axpObj.msg('@AXP4000', '透明部分のロック状態', msgtext);
        }, false);
        // レイヤーのマスク状態の切り替え
        newCheckbox_mask.addEventListener('pointerdown', (e) => {
            e.stopPropagation();
            if (e.target.classList.contains('axpc_icon_maskON')) {
                e.target.classList.remove('axpc_icon_maskON');
                e.target.classList.add('axpc_icon_maskOFF');
                this.layerObj[this.getLayerIndex(e.target.dataset.id)].masked = false;
            } else {
                e.target.classList.remove('axpc_icon_maskOFF');
                e.target.classList.add('axpc_icon_maskON');
                this.layerObj[this.getLayerIndex(e.target.dataset.id)].masked = true;
            }
            var msgtext = e.target.classList.contains('axpc_icon_maskON') ? 'ロック' : 'なし';
            // レイヤーの%1を切り替えました。(現在の状態:%2)
            this.axpObj.msg('@INF4006', '透明部分のロック状態', msgtext);
        }, false);

        // チェックボックスを縦配置する用のdiv要素
        let newDivCheckboxes = document.createElement('div');
        newDivCheckboxes.setAttribute('class', 'axpc_layer_div_cellButtonContainer');
        newDivCheckboxes.appendChild(newCheckbox_lock);
        newDivCheckboxes.appendChild(newCheckbox_mask);

        // キャンバス（レイヤーサムネイル）
        let newCanvas = document.createElement('canvas');
        newCanvas.setAttribute('class', 'axpc_layer_canvas_cellThumbnail axpc_layer_CANDRAG');
        newCanvas.width = this.CONST.X_LAYER_MAX;
        newCanvas.height = this.CONST.Y_LAYER_MAX;

        // レイヤー名
        let newSpan1 = document.createElement('span');
        newSpan1.setAttribute('class', 'axpc_layer_span_cellName axpc_layer_CANDRAG');
        newSpan1.textContent = layerData.name;

        // レイヤーの状態
        let newSpan2 = document.createElement('span');
        newSpan2.setAttribute('class', 'axpc_layer_span_cellStatus axpc_layer_CANDRAG');

        // (1)左側の箱div要素に、チェックボックスを追加
        let newDivLeft = document.createElement('div');
        newDivLeft.setAttribute('class', 'axpc_layer_div_cellLeftSide');
        newDivLeft.appendChild(newDivEye);
        newDivLeft.appendChild(newDivCheckboxes);

        // (2)右側の箱div要素に、ラベルを追加
        let newDivRight = document.createElement('div');
        newDivRight.setAttribute('class', 'axpc_layer_div_cellRightSide axpc_layer_CANDRAG');
        newDivRight.appendChild(newSpan1);
        newDivRight.appendChild(newSpan2);

        // (3)クリッピング時のマーク
        let newDivCliping = document.createElement('div');
        newDivCliping.setAttribute('class', 'axpc_layer_div_cellCliping axpc_layer_CANDRAG');

        // 外枠div要素
        let newDivAll = document.createElement('div');
        newDivAll.setAttribute('class', 'axpc_layer_div_cell');
        // 外枠div要素に作成した子要素(1)＋(3)＋サムネイル＋(2)を追加
        newDivAll.appendChild(newDivLeft);
        newDivAll.appendChild(newDivCliping);
        newDivAll.appendChild(newCanvas);
        newDivAll.appendChild(newDivRight);

        // カラータグ
        const newDivtTagColor = document.createElement('div');
        newDivtTagColor.setAttribute('class', 'axpc_layer_div_cellColorTag axpc_layer_CANDRAG');
        newDivtTagColor.style.background = this.getTagBackground(layerData.tag);
        //console.log('生成', layerData.tag, this.getTagBackground(layerData.tag));
        newDivAll.appendChild(newDivtTagColor);

        // リスト項目要素の作成
        let newLayer = document.createElement('li');
        newLayer.setAttribute('data-selected', '');       // レイヤーが選択状態か
        newLayer.setAttribute('data-name', 'Layer' + layerData.id);
        newLayer.setAttribute('data-id', layerData.id);              // レイヤーの固有ID
        newLayer.setAttribute('id', 'layer' + layerData.id);
        newLayer.appendChild(newDivAll);

        // レイヤー操作（選択、ドラッグによる順序入れ替え、ドロップによる削除）
        newLayer.addEventListener('pointerdown', (e) => {
            //console.log('click:', event.target.dataset.type);
            //console.log('click:', e.target, e.currentTarget);
            if (e.target.classList.contains('axpc_layer_CANDRAG')) {
                this.drag_down(e);
                // ドラッグで表示順序を入れ替え。ダブルクリックでレイヤー名変更。
                this.axpObj.msg('@AXP4001');
                // カレントレイヤー更新
                this.setCurrentLayer(e.currentTarget);
            }
        });
        // リネーム
        newDivRight.addEventListener('dblclick', (e) => {
            this.openRenameLayerWindow(e);
        });
        return newLayer;
    }
    openRenameLayerWindow() {
        // サブウィンドウオープン
        this.axpObj.openSubwindow('axp_renamelayer', this.currentLayer);

        // 現在のレイヤー名を取得
        const elementLayerLabel = this.currentLayer.querySelector('.axpc_layer_span_cellName');
        const layerName = elementLayerLabel.textContent;
        const textbox = document.getElementById('axp_renamelayer_text_newLayerName');
        textbox.value = layerName;
        // 決定ボタン無効化
        document.getElementById('axp_renamelayer_button_confirm').dataset.enabled = 'false';
        // テキストエリアにフォーカス
        textbox.focus();
        textbox.select();
    }
    // レイヤーのドラッグ＆ドロップ
    drag_down(e) {
        //console.log(e);
        const target = e.currentTarget;
        const pageX = e.pageX;
        const pageY = e.pageY;
        const targetW = target.offsetWidth;
        data.idx_source = util.index(target); // 移動するレイヤーの添字
        data.target = target;
        data.diffX = pageX;
        data.diffY = pageY;
        data.ofx = target.offsetLeft;
        data.ofy = target.offsetTop;
        data.cloneName = util.insertClone(target, util.index(target));
        target.style.width = `${targetW}px`;
        target.classList.add('axpc_onGRAB');
        // ドラッグ中
        const onPointerMove = (e) => {
            //console.log('move');
            const target = data.target;
            const pageX = e.pageX;
            const pageY = e.pageY;
            const targetPosL = data.ofx + pageX - data.diffX;
            const targetPosT = data.ofy + pageY - data.diffY;
            target.style.left = `${targetPosL}px`;
            target.style.top = `${targetPosT}px`;
            util.swap(target);
        }
        // ドロップ
        const onPointerUp = () => {
            //console.log('up');
            //console.log('e:', e.currentTarget);
            const target = data.target;
            const cloneSelector = `.${data.cloneName}`;
            const clone = document.querySelector(cloneSelector);
            data.cloneName = '';
            clone.remove();
            target.removeAttribute('style');
            target.classList.remove('axpc_onGRAB');
            // イベントリスナー解除
            window.removeEventListener('pointermove', onPointerMove);
            window.removeEventListener('pointerup', onPointerUp);

            // 操作終了後、実際に入替処理が行われたどうか判定する
            var elem = document.querySelectorAll('#axp_layer_ul_layerBox>li');
            for (var idx = 0; idx < elem.length; idx++) {
                if (elem[idx].dataset.id === target.dataset.id) break;
            }
            if (idx !== data.idx_source) {
                // レイヤー配列に反映
                //console.log("画面表示：移動元", data.idx_source, "=>移動先", idx);
                //console.log("配列：移動元", elem.length - 1 - data.idx_source, "=>移動先", elem.length - 1 - idx);
                /*
                // 配列の並び順と画面表示の並び順が逆順の仕様の時の置換ロジック（没）
                var moveObj = this.layerObj.splice(elem.length - 1 - data.idx_source, 1);
                this.layerObj.splice(elem.length - 1 - idx, 0, moveObj[0]);
                */
                // 配列の並び順と画面表示の並び順が同じ仕様の時の置換ロジック
                let moveObj = this.layerObj.splice(data.idx_source, 1);
                this.layerObj.splice(idx, 0, moveObj[0]);

                let moveCtx = this.CANVAS.thumbnail_ctx.splice(data.idx_source, 1);
                this.CANVAS.thumbnail_ctx.splice(idx, 0, moveCtx[0]);

                // safari
                if (this.axpObj.ENV.multiCanvas) {
                    let movelayerCtx = this.CANVAS.layer_ctx.splice(data.idx_source, 1);
                    this.CANVAS.layer_ctx.splice(idx, 0, movelayerCtx[0]);
                }
                //console.log(this.layerObj);

                // 添字情報の更新
                this.updateLayerIndex();
                this.updateCanvas();
            }
        }
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
    }
    // カレントレイヤー更新
    setCurrentLayer(targetElement) {
        // 引数の要素をカレントレイヤーとし、変更に伴う連動処理を行う
        const layerBoxElements = document.querySelectorAll('#axp_layer_ul_layerBox>li');
        // 一旦、全レイヤーを非選択に
        for (const item of layerBoxElements) {
            item.dataset.selected = '';
        }
        // カレントレイヤー（現在選択中のレイヤー）を更新
        this.currentLayer = targetElement;
        this.currentLayer.dataset.selected = 'true';

        // 透明度スライドバーの復元処理
        const alpha = this.getAlpha();
        document.getElementById('axp_layer_range_alpha').value = alpha;
        document.getElementById('axp_layer_form_alpha').result.value = alpha;

        // 合成モードの復元処理
        document.getElementById('axp_layer_select_blendMode').value = this.getMode();
        // セレクトボックスからフォーカスを外す(※safariでjsからの値変更が反映されない不具合の対策)
        document.getElementById('axp_layer_select_blendMode').blur();
    }
    // カレントレイヤー選択（index指定）
    selectCurrentLayerIndex(targetIndex) {
        const layerBoxElements = document.querySelectorAll('#axp_layer_ul_layerBox>li');
        let index = 0;
        for (const item of layerBoxElements) {
            if (index === targetIndex) {
                this.setCurrentLayer(item);
                break;
            }
        }
    }
    updateLayerIndex() {
        // レイヤー順序の入れ替え操作を行った際に、自身の添字情報を再更新する（アンドゥ時に参照）
        for (let i = 0; i < this.layerObj.length; i++) {
            this.layerObj[i].index = i;
        }
    }
    draw() {
        let ctx = this.axpObj.CANVAS.main_ctx;
        //console.log('ここで描画', this.x_size, this.y_size);
        // 表示領域をクリア
        this.CANVAS.backscreen_trans_ctx.beginPath();
        this.CANVAS.backscreen_trans_ctx.clearRect(0, 0, this.x_size, this.y_size);
        // 全レイヤー走査（※下層レイヤーから描画するため逆順）
        // 処理済みindex（クリッピング処理で子を先行して合成する場合がある時、スキップ判定に使用する）
        let skipIdx = this.layerObj.length - 1;
        for (let idx = this.layerObj.length - 1; idx >= 0; idx--) {
            let item = this.layerObj[idx];

            // imagedataを仮想キャンバスに描画
            let tmp_ctx;
            // safari
            if (this.axpObj.ENV.multiCanvas) {
                tmp_ctx = this.CANVAS.layer_ctx[idx];
            } else {
                tmp_ctx = this.CANVAS.tmp_ctx;
            }
            tmp_ctx.putImageData(item.image, 0, 0);

            // レイヤー毎のサムネイル描画
            const clearRect = Math.max(this.axpObj.x_size, this.axpObj.y_size);
            this.CANVAS.thumbnail_ctx[idx].clearRect(0, 0, clearRect, clearRect);
            this.CANVAS.thumbnail_ctx[idx].drawImage(
                tmp_ctx.canvas,
                this.axpObj.ctx_map_shift_x,
                this.axpObj.ctx_map_shift_y
            );

            // クリッピング合成により描画済みの子レイヤーの場合、処理をスキップする
            if (skipIdx < idx) {
                //console.log('skip', skipIdx, '<', idx);
                continue;
            }

            // 自身がクリッピングの時、親がいない不正なレイヤーのため、表示を行わない
            if (item.mode === 'source-atop') {
                //console.log('idx=', idx, this.layerObj[idx].name, '親がいない');
                // 無効なクリッピングであることを表示
                const elementCliping = this.getLayerElement(idx).querySelector('.axpc_layer_div_cellCliping');
                elementCliping.dataset.mode = 'invalid';

            } else {
                // 合成結果の保存先キャンバス
                let outputCanvas = tmp_ctx.canvas;

                // 最上層レイヤー以外のとき、クリッピングの親（直上のレイヤーがクリッピング）であるならば、すべての子との合成処理を行い、mergeキャンバスに結果を保存
                if (idx !== 0) {
                    if (this.layerObj[idx - 1].mode === 'source-atop') {
                        //console.log('idx=', idx, this.layerObj[idx].name, '親');
                        // 子のindex
                        skipIdx = idx - 1;

                        // クリップ領域の初期化
                        this.CANVAS.clip_ctx.globalCompositeOperation = 'source-over';
                        this.CANVAS.clip_ctx.globalAlpha = 1;
                        this.CANVAS.clip_ctx.clearRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);

                        // すべての子レイヤーを走査して親と合成する
                        // ※親が非表示の場合でも、有効なクリッピングであることの表示更新が必要なので、前段の子の走査は必須
                        while (skipIdx >= 0) {
                            if (this.layerObj[skipIdx].mode === 'source-atop') {
                                //console.log('skipIdx=', skipIdx, this.layerObj[skipIdx].name);
                                // 有効なクリッピングであることを表示
                                const elementCliping = this.getLayerElement(skipIdx).querySelector('.axpc_layer_div_cellCliping');
                                elementCliping.dataset.mode = this.layerObj[skipIdx].mode;

                                // 子レイヤーが「表示」の場合、そのレイヤーを親と合成する
                                if (this.layerObj[skipIdx].checked) {
                                    // safari
                                    if (this.axpObj.ENV.multiCanvas) {
                                        this.CANVAS.layer_ctx[skipIdx].putImageData(this.layerObj[skipIdx].image, 0, 0);
                                        this.CANVAS.clip_ctx.globalAlpha = this.layerObj[skipIdx].alpha / 100;
                                        this.CANVAS.clip_ctx.drawImage(this.CANVAS.layer_ctx[skipIdx].canvas, 0, 0);
                                    } else {
                                        tmp_ctx.putImageData(this.layerObj[skipIdx].image, 0, 0);
                                        this.CANVAS.clip_ctx.globalAlpha = this.layerObj[skipIdx].alpha / 100;
                                        this.CANVAS.clip_ctx.drawImage(tmp_ctx.canvas, 0, 0);
                                    }
                                }
                                skipIdx--;
                            } else {
                                break;
                            }
                        }
                        // 描画領域の初期化
                        this.CANVAS.merge_ctx.clearRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);
                        // 親レイヤーの画像をベースにする
                        this.CANVAS.merge_ctx.putImageData(item.image, 0, 0);
                        // 子と合成
                        this.CANVAS.merge_ctx.globalCompositeOperation = 'source-atop';
                        this.CANVAS.merge_ctx.globalAlpha = 1;
                        this.CANVAS.merge_ctx.drawImage(this.CANVAS.clip_ctx.canvas, 0, 0);

                        // 合成結果の保存先キャンバスを変更（クリッピング合成用）
                        outputCanvas = this.CANVAS.merge;
                    }

                }
                // レイヤーが「表示」の場合、そのレイヤーをキャンバスに描画する
                if (item.checked) {
                    //console.log('idx=', idx, this.layerObj[idx].name);
                    this.CANVAS.backscreen_trans_ctx.globalCompositeOperation = item.mode;
                    this.CANVAS.backscreen_trans_ctx.globalAlpha = item.alpha / 100;
                    this.CANVAS.backscreen_trans_ctx.drawImage(outputCanvas, 0, 0);
                }
            }
        }

        // 白塗りつぶし背景
        this.CANVAS.backscreen_white_ctx.beginPath();
        this.CANVAS.backscreen_white_ctx.clearRect(0, 0, this.x_size, this.y_size);
        this.CANVAS.backscreen_white_ctx.globalAlpha = 1;
        this.CANVAS.backscreen_white_ctx.fillStyle = '#F0E0D6';
        this.CANVAS.backscreen_white_ctx.fillRect(0, 0, this.x_size, this.y_size);
        this.CANVAS.backscreen_white_ctx.drawImage(this.CANVAS.backscreen_trans, 0, 0);

        // 画面に出力
        if (this.axpObj.assistToolSystem.getIsTransparent()) {
            // 透過背景
            ctx.clearRect(0, 0, this.x_size, this.y_size);
            ctx.drawImage(this.CANVAS.backscreen_trans, 0, 0);
        } else {
            // 白背景
            ctx.drawImage(this.CANVAS.backscreen_white, 0, 0);
        }

        // 背景タイルプレビュー表示
        if (this.axpObj.isBackgroundimage && !this.axpObj.isDrawing) {
            this.axpObj.drawBackground();
        }

    }
    // 補助ツールのサムネイル描画
    drawThumbnail() {
        let ctx = this.axpObj.assistToolSystem.CANVAS.thumbnail_ctx;
        // クリア
        ctx.clearRect(
            0,
            0,
            this.axpObj.assistToolSystem.CANVAS.thumbnail.width,
            this.axpObj.assistToolSystem.CANVAS.thumbnail.height);

        // 描画
        if (this.axpObj.assistToolSystem.getIsTransparent()) {
            // 透過背景
            ctx.drawImage(
                this.CANVAS.backscreen_trans,
                0,
                0,
                this.axpObj.assistToolSystem.CANVAS.thumbnail.width,
                this.axpObj.assistToolSystem.CANVAS.thumbnail.height);
        } else {
            // 白地背景
            ctx.drawImage(
                this.CANVAS.backscreen_white,
                0,
                0,
                this.axpObj.assistToolSystem.CANVAS.thumbnail.width,
                this.axpObj.assistToolSystem.CANVAS.thumbnail.height);
        }

    }
    updateCanvas() {
        // キャンバス更新が影響する表示を一括処理
        this.draw();
        this.drawThumbnail();
    }
    // 画像をダウンロード
    downloadImage() {
        let link = document.createElement("a");
        if (this.axpObj.assistToolSystem.getIsTransparent()) {
            // 透過
            link.href = this.CANVAS.backscreen_trans.toDataURL('image/png');
        } else {
            // 白地
            link.href = this.CANVAS.backscreen_white.toDataURL('image/png');
        }
        let filename = 'ap' + (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.dispDate)(new Date(), 'YYYYMMDD_hhmmss') + '.png';
        link.download = filename;
        link.click();
    }
    // レイヤーの新規作成
    buttonCreateLayer() {
        // レイヤー最大数を超える場合は生成不可
        if (this.layerObj.length >= this.CONST.LAYER_MAX) {
            // レイヤーは%1枚までです。
            this.axpObj.msg('@CAU4002', this.CONST.LAYER_MAX);
            return;
        }

        // レイヤー生成
        var targetId = this.newLayer();
        // %1を作成しました。
        this.axpObj.msg('@INF4001', this.getName());

        console.log(this.layerObj, targetId);

        // アンドゥ用記録
        this.axpObj.undoSystem.setUndo({
            type: 'layer-create',
            layerObj: this.layerObj[this.getLayerIndex(targetId)],
        });
    }
    // レイヤーの統合
    buttonIntegrateLayer() {
        var idx_source = this.getLayerIndex(this.currentLayer.dataset.id); // 統合元idx

        // 最下位チェック
        if (idx_source >= this.layerObj.length - 1) {
            // 最下層のレイヤーは統合できません。
            this.axpObj.msg('@CAU4005');
            return;
        }
        var idx_dest = idx_source + 1;  // 統合先idx
        var id_dest = this.layerObj[idx_dest].id; //統合先id（処理の最後でレイヤーを選択状態するために保持）

        // レイヤー名の記憶（統合処理後に参照できなくなるため）
        const source_name = this.getName();
        const dest_name = this.getName(idx_dest);

        // 書き込み禁止チェック（統合元）
        if (this.isWriteProtection()) {
            // %1が%2のため、統合できません。
            this.axpObj.msg('@CAU4006', source_name, this.getReasonTextForWriteProtection());
            return;
        }
        // 書き込み禁止チェック（統合先）
        if (this.isWriteProtection(idx_dest)) {
            // %1が%2のため、統合できません。
            this.axpObj.msg('@CAU4006', dest_name, this.getReasonTextForWriteProtection(idx_dest));
            return;
        }

        //console.log(this.layerObj[idx_source].index, idx_source);
        //console.log(this.layerObj[idx_dest].index, idx_dest);

        // アンドゥ用記録
        this.axpObj.undoSystem.setUndo({
            type: 'layer-integrate',
            layerObj: this.layerObj[idx_source],
            layerObj_dest: this.layerObj[idx_dest],
        });

        // 統合処理
        let draw = this.axpObj.penSystem.CANVAS.draw;
        let draw_ctx = this.axpObj.penSystem.CANVAS.draw_ctx;

        draw_ctx.clearRect(0, 0, draw.width, draw.height);
        draw_ctx.shadowBlur = 0; // 統合時はぼかしを無効にする

        let source_ctx, dest_ctx;
        // safari
        if (this.axpObj.ENV.multiCanvas) {
            source_ctx = this.CANVAS.layer_ctx[idx_dest];
            dest_ctx = this.CANVAS.layer_ctx[idx_source];
        } else {
            source_ctx = this.CANVAS.tmp_ctx;
            dest_ctx = this.CANVAS.tmp_ctx;
        }

        // 初期化
        this.CANVAS.merge_ctx.clearRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);
        draw_ctx.clearRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);

        // 下層
        dest_ctx.putImageData(this.layerObj[idx_dest].image, 0, 0);
        draw_ctx.globalAlpha = Number(this.layerObj[idx_dest].alpha / 100);
        draw_ctx.globalCompositeOperation = 'source-over';
        draw_ctx.drawImage(dest_ctx.canvas, 0, 0);

        if (this.layerObj[idx_dest].masked) {
            // マスクデータの作成
            this.CANVAS.clip_ctx.putImageData(this.layerObj[idx_dest].image, 0, 0);
            const imageData = this.CANVAS.clip_ctx.getImageData(0, 0, this.axpObj.x_size, this.axpObj.y_size);
            // 1ピクセルずつ走査してαを255にする
            for (let i = 0, len = imageData.data.length; i < len; i += 4) {
                const alpha = imageData.data[i + 3];
                if (alpha > 0) {
                    imageData.data[i + 3] = 255;
                }
            }
            // マスクデータ描画
            this.CANVAS.clip_ctx.putImageData(imageData, 0, 0);
            this.CANVAS.merge_ctx.globalAlpha = 1;
            this.CANVAS.merge_ctx.globalCompositeOperation = 'source-over';
            this.CANVAS.merge_ctx.drawImage(this.CANVAS.clip_ctx.canvas, 0, 0);
            // 上層の画像をマスクデータで切り抜いて合成
            source_ctx.putImageData(this.layerObj[idx_source].image, 0, 0);
            this.CANVAS.merge_ctx.globalAlpha = Number(this.layerObj[idx_source].alpha / 100);
            this.CANVAS.merge_ctx.globalCompositeOperation = 'source-in';
            this.CANVAS.merge_ctx.drawImage(source_ctx.canvas, 0, 0);

            // 合成
            draw_ctx.globalAlpha = 1;
            draw_ctx.globalCompositeOperation = this.layerObj[idx_source].mode;
            draw_ctx.drawImage(this.CANVAS.merge_ctx.canvas, 0, 0);

        } else {
            // 上層
            source_ctx.putImageData(this.layerObj[idx_source].image, 0, 0);
            this.CANVAS.merge_ctx.globalAlpha = Number(this.layerObj[idx_source].alpha / 100);
            this.CANVAS.merge_ctx.globalCompositeOperation = 'source-over';
            this.CANVAS.merge_ctx.drawImage(source_ctx.canvas, 0, 0);

            // 合成
            draw_ctx.globalAlpha = 1;
            if (this.layerObj[idx_source].mode === 'source-atop' && this.layerObj[idx_dest].mode === 'source-atop') {
                draw_ctx.globalCompositeOperation = 'source-over';
            } else {
                draw_ctx.globalCompositeOperation = this.layerObj[idx_source].mode;
            }
            draw_ctx.drawImage(this.CANVAS.merge_ctx.canvas, 0, 0);
        }

        this.layerObj[idx_dest].image = draw_ctx.getImageData(0, 0, draw.width, draw.height);

        // 統合後の不透明度は強制的に100%にする
        this.setAlpha(100, idx_dest);

        // 統合元レイヤー削除
        this.deleteLayer(this.getId());
        // 表示更新
        this.updateCanvas();
        // 処理完了後、統合先のレイヤーを選択状態にする
        var elements = document.querySelectorAll('#axp_layer_ul_layerBox>li');
        for (var i = 0; i < elements.length; i++) {
            //console.log(elements[i].dataset.id, id_dest);
            if (Number(elements[i].dataset.id) === Number(id_dest)) {
                // レイヤー選択
                this.setCurrentLayer(elements[i]);
                break;
            }
        }
        // %1と%2を統合しました。
        this.axpObj.msg('@INF4004', source_name, dest_name);
        console.log(this.layerObj);
    }
    // レイヤーのコピー
    buttonCopyLayer() {
        // レイヤー最大数を超える場合は生成不可
        if (this.layerObj.length >= this.CONST.LAYER_MAX) {
            // レイヤーは%1枚までです。
            this.axpObj.msg('@CAU4002', this.CONST.LAYER_MAX);
            return;
        }

        // 複製元IDとレイヤー名（メッセージ表示用）を記憶
        const id_source = this.getId();
        const name_source = this.getName();

        // 複製元のレイヤー情報を渡してレイヤー生成
        var id_dest = this.copyLayer(this.layerObj[this.getLayerIndex(id_source)]);
        var name_dest = this.getName()
        // imageDataオブジェクトのコピー
        // this.getImage().data.set(this.layerObj[this.getLayerIndex(id_source)].image.data);

        // 表示更新
        this.updateCanvas();

        // %1を複製して、%2を作成しました。
        this.axpObj.msg('@INF4002', name_source, name_dest);

        // アンドゥ用記録
        this.axpObj.undoSystem.setUndo({
            type: 'layer-copy',
            layerObj: this.layerObj[this.getLayerIndex(id_dest)],
        });
        console.log(this.layerObj);
    }
    // レイヤーの削除
    buttonDeleteLayer() {
        // レイヤーがロック状態の場合は削除不可
        if (this.getLocked()) {
            // %1がロック状態のため、削除できません。
            this.axpObj.msg('@CAU4003', this.getName());
            return;
        }
        // レイヤー最大数を超える場合は生成不可
        if (this.layerObj.length <= 1) {
            // レイヤーをすべて削除することはできません。
            this.axpObj.msg('@CAU4004');
            return;
        }
        // アンドゥ用記録
        const targetId = this.getId();
        const targetName = this.getName();
        this.axpObj.undoSystem.setUndo({
            type: 'layer-delete',
            //id: targetId,
            layerObj: this.layerObj[this.getLayerIndex(targetId)],
        });
        // レイヤー削除
        this.deleteLayer(targetId);

        // 表示更新
        this.updateCanvas();
        // %1をを削除しました。
        this.axpObj.msg('@INF4003', targetName);
        console.log(this.layerObj);
    }
    // レイヤーのクリア
    buttonClearLayer() {
        // レイヤーがロック状態の場合は削除不可
        if (this.getLocked()) {
            // %1がロック状態のため、クリアできません。
            this.axpObj.msg('@CAU4000', this.getName());
            return;
        }

        // 空白のレイヤーの場合は処理を行わない（アンドゥ用履歴を作成しない）
        if ((0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.isBlankImage)(this.getImage())) {
            // %1は空白のレイヤーです。
            this.axpObj.msg('@CAU4001', this.getName());
            return;
        }

        // アンドゥ用記録
        this.axpObj.undoSystem.setUndo({
            type: 'layer-clear',
            layerObj: this.axpObj.layerSystem.layerObj[this.axpObj.layerSystem.getLayerIndex(this.getId())],
        });

        // クリア
        this.clear(this.getId());
        this.updateCanvas();
        // %1をクリアしました。
        this.axpObj.msg('@INF4000', this.getName());
    }
}
// レイヤードラッグ用関数定義
let data = {
    target: null,
    diffX: 0,
    diffY: 0,
    ofx: 0,
    ofy: 0,
    idx_source: null,
};
const util = {
    index(el) {
        const parent = el.parentElement;
        const siblings = parent.children;
        const siblingsArr = [].slice.call(siblings);
        const idx = siblingsArr.indexOf(el);

        return idx;
    },
    insertClone(target, insertIdx) {
        const cloneName = `ddItemClone_${Math.trunc(Math.random() * 10000)}`;
        const clone = target.cloneNode(true);
        const parent = target.parentElement;
        const siblings = parent.children;

        clone.classList.add('axpc_HIDDEN');
        clone.classList.add(cloneName);
        siblings[insertIdx].insertAdjacentElement('afterend', clone);

        return cloneName;
    },
    swap(target) {
        const selfIdx = util.index(target);
        const cloneIdx = selfIdx + 1;
        const parent = target.parentElement;
        const siblings = parent.querySelectorAll(`:scope > *:not(.axpc_onGRAB):not(.${data.cloneName})`);

        for (let thatIdx = 0, len = siblings.length; thatIdx < len; thatIdx++) {
            const targetW = target.offsetWidth;
            const targetH = target.offsetHeight;
            const targetRect = target.getBoundingClientRect();
            const targetRectX = targetRect.left;
            const targetRectY = targetRect.top;
            const that = siblings[thatIdx];
            const thatW = that.offsetWidth;
            const thatH = that.offsetHeight;
            const thatRect = that.getBoundingClientRect();
            const thatRectX = thatRect.left;
            const thatRectY = thatRect.top;
            const thatRectYHalf = thatRectY + (thatH / 2);
            const hitX = thatRectX <= (targetRectX + targetW) && thatRectX + thatW >= targetRectX;
            const hitY = targetRectY <= thatRectYHalf && (targetRectY + targetH) >= thatRectYHalf;
            const isHit = hitX && hitY;

            if (isHit) {
                const siblingsAll = parent.children;
                const clone = siblingsAll[cloneIdx];

                parent.insertBefore(clone, selfIdx > thatIdx ? that : that.nextSibling);
                parent.insertBefore(target, clone);

                break;
            }
        }
    }
};


/***/ }),

/***/ "./src/js/window_makecolor.js":
/*!************************************!*\
  !*** ./src/js/window_makecolor.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorMakerSystem: () => (/* binding */ ColorMakerSystem)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./window.js */ "./src/js/window.js");
/* harmony import */ var _html_window_makecolor_txt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../html/window_makecolor.txt */ "./src/html/window_makecolor.txt");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./etc.js */ "./src/js/etc.js");
/* harmony import */ var _reinvented_color_wheel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reinvented-color-wheel.js */ "./src/js/reinvented-color-wheel.js");
// @description ツールウィンドウ：親クラス＞色作成



// css適用
__webpack_require__(/*! ../css/window_makecolor.css */ "./src/css/window_makecolor.css");



// カラーピッカーライブラリ

__webpack_require__(/*! ../css/reinvented-color-wheel.css */ "./src/css/reinvented-color-wheel.css");

// カラー作成制御オブジェクト
class ColorMakerSystem extends _window_js__WEBPACK_IMPORTED_MODULE_0__.ToolWindow {
    // メインカラー、サブカラー（#付きで管理）
    maincolor;
    subcolor;
    colorWheel;
    colorWheel_subwindow;
    CONST = {
    }
    constructor(axpObj) {
        super(axpObj);
    }
    // 初期ウィンドウ位置
    getDefaultPosition() {
        return {
            //left: this.axpObj.paintBodyElement.clientWidth - this.window_width - 10,
            left: this.axpObj.paintBodyElement.clientWidth - this.window_width - 120 - 10,
            top: 250,
        }
    }
    // 初期化
    init() {
        // HTML
        this.createHTML(
            'axp_makecolor',
            'MKC',
            this.axpObj._('@WINDOW.COLOR'),
            'axpc_icon_window_colormaker',
            _html_window_makecolor_txt__WEBPACK_IMPORTED_MODULE_1__
        );
        this.window_width = 180;
        // 初期座標設定
        const pos = this.getDefaultPosition();
        this.window_left = pos.left;
        this.window_top = pos.top;
        // メインカラー／サブカラーの初期値設定
        document.getElementById('axp_makecolor_div_mainColor').style.backgroundColor = '#800000';
        document.getElementById('axp_makecolor_div_subColor').style.backgroundColor = '#FFFFFF';
        this.maincolor = "#800000";
        this.subcolor = "#FFFFFF";
        this.createTemporaryPalette();

        // カラーピッカー：使用定義
        this.colorWheel = new _reinvented_color_wheel_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
            // appendTo is the only required property. specify the parent element of the color wheel.
            appendTo: document.querySelector('#axp_makecolor_div_colorPicker>div'),
            // initial color (can be specified in hsv / hsl / rgb / hex)
            rgb: [0, 0, 0],
            // hsl: [0, 100, 50],
            // rgb: [255, 0, 0],
            // hex: "#ff0000",

            // appearance
            wheelDiameter: 166,
            wheelThickness: 20,
            handleDiameter: 16,
            wheelReflectsSaturation: false,

            // handler
            onChange: (color) => {
                this.setMainColor(color.hex, 'picker');
            },
        });
        /*
        // 使用方法
        // set color in HSV / HSL / RGB / HEX
        colorWheel.hsv = [240, 100, 100];
        colorWheel.hsl = [120, 100, 50];
        colorWheel.rgb = [255, 128, 64];
        colorWheel.hex = '#888888';

        // get color in HSV / HSL / RGB / HEX
        console.log("hsv:", colorWheel.hsv[0], colorWheel.hsv[1], colorWheel.hsv[2]);
        console.log("hsl:", colorWheel.hsl[0], colorWheel.hsl[1], colorWheel.hsl[2]);
        console.log("rgb:", colorWheel.rgb[0], colorWheel.rgb[1], colorWheel.rgb[2]);
        console.log("hex:", colorWheel.hex);

        // please call redraw() after changing some appearance properties.
        colorWheel.wheelDiameter = 400;
        colorWheel.wheelThickness = 40;
        colorWheel.redraw();
        */
    }
    // イベント受付開始
    startEvent() {
        // ボタン：スワップ
        document.getElementById('axp_makecolor_button_swapColor').addEventListener('click', () => {
            // メインカラーとサブカラーの交換
            let colorcode = this.maincolor;
            this.maincolor = this.subcolor;
            this.subcolor = colorcode;
            this.displayColorMaker();
            // メインカラー RGB:(%1) <-> サブカラー (%2)
            this.axpObj.msg('@COL0003', (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.maincolor), (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.subcolor));
        });
        // ボタン：パレット登録
        document.getElementById('axp_makecolor_button_addColor').addEventListener('click', () => {
            this.axpObj.colorPaletteSystem.addcolor();
        });

        // レンジスライダー：三原色カラー
        const oninputRangeColor = () => {
            var r, g, b;
            r = Number(document.getElementById('axp_makecolor_range_red').value);
            g = Number(document.getElementById('axp_makecolor_range_green').value);
            b = Number(document.getElementById('axp_makecolor_range_blue').value);
            let colorcode = '#' + (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.rgb2hex)([r, g, b]);
            // メインカラー更新
            this.setMainColor(colorcode);
        }
        document.getElementById('axp_makecolor_range_red').oninput = oninputRangeColor;
        document.getElementById('axp_makecolor_range_green').oninput = oninputRangeColor;
        document.getElementById('axp_makecolor_range_blue').oninput = oninputRangeColor;

        // テキストボックス：カラーコード直接入力
        document.getElementById('axp_makecolor_text_colorCode').onchange = () => {
            var code = document.getElementById('axp_makecolor_text_colorCode').value;
            if ((0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.isColor)(code)) {
                var rgb = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(code);
                var hex = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.rgb2hex)(rgb);
                var colorcode = '#' + hex.toUpperCase();
                // メインカラー更新
                this.setMainColor(colorcode);
                // カラーコードの入力を受け付けました。%1 / RGB:(%2)
                this.axpObj.msg('@INF2000', colorcode, rgb);
            } else {
                // カラーコードが正しくありません。入力例：#ffffff または #fff（#は省略可）
                this.axpObj.msg('@CAU2000');
            }
        }

        // テキストボックス：三原色カラー数値入力
        const onchangeColorValue = () => {
            //console.log('onchange');
            //  RGBの取得
            var r = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.adjustColorValue)(document.getElementById('axp_makecolor_number_red').value);
            var g = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.adjustColorValue)(document.getElementById('axp_makecolor_number_green').value);
            var b = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.adjustColorValue)(document.getElementById('axp_makecolor_number_blue').value);

            // メインカラー更新
            let colorcode = '#' + (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.rgb2hex)([r, g, b]);
            this.setMainColor(colorcode);
        }
        document.getElementById('axp_makecolor_number_red').onchange = onchangeColorValue;
        document.getElementById('axp_makecolor_number_green').onchange = onchangeColorValue;
        document.getElementById('axp_makecolor_number_blue').onchange = onchangeColorValue;

        // イベント登録終了
    }
    selectMainColor() {
        this.selectPalette('main');
        this.setMainColor(this.maincolor);
        // %drawingColorName RGB:(%1)
        this.axpObj.msg('@COL0001', (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.maincolor));
    }
    selectSubColor() {
        this.selectPalette('sub');
        this.setMainColor(this.subcolor);
        // %drawingColorName RGB:(%1)
        this.axpObj.msg('@COL0001', (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.subcolor));
    }
    selectTransparent() {
        this.selectPalette('transparent');
        this.setMainColor(this.maincolor);
        // 透明色
        this.axpObj.msg('@COL0002');
    }
    getMainColor() {
        return this.maincolor;
    }
    getMainColorRGB() {
        return (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.maincolor);
    }
    setMainColor(colorcode, changer = null) {
        //console.log('setmaincolor:', colorcode, changer);
        // ＠サブカラー
        if (document.getElementById('axp_makecolor_div_subColor').dataset.selected === 'true') {
            this.subcolor = colorcode;
            // サブカラー表示
            document.getElementById('axp_makecolor_div_subColor').style.backgroundColor = colorcode;
        } else {
            this.maincolor = colorcode;
            // メインカラー表示
            document.getElementById('axp_makecolor_div_mainColor').style.backgroundColor = colorcode;
            // カラーコード(HEX)表示
            document.getElementById('axp_makecolor_text_colorCode').value = colorcode.toUpperCase();
        }

        // 各要素の表示更新

        // カラーピッカー（自分自身は更新しない）
        if (changer !== 'picker') {
            this.colorWheel.hex = colorcode;
        }

        // カラースライドバー
        let hex = colorcode.slice(1);
        let rgbcolor = hex.match(/.{2}/g);
        document.getElementById('axp_makecolor_range_red').value = parseInt(rgbcolor[0], 16);
        document.getElementById('axp_makecolor_range_green').value = parseInt(rgbcolor[1], 16);
        document.getElementById('axp_makecolor_range_blue').value = parseInt(rgbcolor[2], 16);
        document.getElementById('axp_makecolor_number_red').value = parseInt(rgbcolor[0], 16);
        document.getElementById('axp_makecolor_number_green').value = parseInt(rgbcolor[1], 16);
        document.getElementById('axp_makecolor_number_blue').value = parseInt(rgbcolor[2], 16);

        // 編集モードならカラーパレットにも反映
        this.axpObj.colorPaletteSystem.setColor(colorcode);
        // ペンプレビュー
        this.axpObj.penSystem.previewPenSize();
        this.updateTemporaryPalette();
        let temporary = document.querySelector('#axp_makecolor_div_mixedPalette>div>div[data-selected="true"]');
        if (temporary) {
            // メインカラー用表示を混色にする（CSS変数経由で疑似要素に参照させる）
            document.getElementById('axp_makecolor_div_mainColor').style.setProperty('--axp-mixedcolor', temporary.dataset.color);
        }
    }
    // 選択している描画色の名称（混色パレット対象外版）
    get drawingColorName() {
        if (document.getElementById('axp_makecolor_div_subColor').dataset.selected === 'true') {
            return 'サブカラー';
        } else {
            // 混色パレット、透明色も含む
            return 'メインカラー';
        }
    }
    // 選択している描画色の名称（混色パレット対象版）
    get addPaletteName() {
        let temporary = document.querySelector('#axp_makecolor_div_mixedPalette>div>div[data-selected="true"]');
        if (temporary) {
            return '混色パレット';
        } else {
            if (document.getElementById('axp_makecolor_div_subColor').dataset.selected === 'true') {
                return 'サブカラー';
            } else {
                // 透明色も含む
                return 'メインカラー';
            }
        }
    }
    displayColorMaker() {
        // メインカラー表示
        document.getElementById('axp_makecolor_div_mainColor').style.backgroundColor = this.maincolor;
        // カラーコード(HEX)表示
        document.getElementById('axp_makecolor_text_colorCode').value = this.maincolor.toUpperCase();
        // サブカラー表示
        document.getElementById('axp_makecolor_div_subColor').style.backgroundColor = this.subcolor;;

        let colorcode;
        // ＠サブカラー
        if (document.getElementById('axp_makecolor_div_subColor').dataset.selected === 'true') {
            colorcode = this.subcolor;
        } else {
            colorcode = this.maincolor;
        }
        // カラーピッカー
        this.colorWheel.hex = colorcode;

        // カラースライドバー
        let hex = colorcode.slice(1);
        let rgbcolor = hex.match(/.{2}/g);
        document.getElementById('axp_makecolor_range_red').value = parseInt(rgbcolor[0], 16);
        document.getElementById('axp_makecolor_range_green').value = parseInt(rgbcolor[1], 16);
        document.getElementById('axp_makecolor_range_blue').value = parseInt(rgbcolor[2], 16);
        document.getElementById('axp_makecolor_number_red').value = parseInt(rgbcolor[0], 16);
        document.getElementById('axp_makecolor_number_green').value = parseInt(rgbcolor[1], 16);
        document.getElementById('axp_makecolor_number_blue').value = parseInt(rgbcolor[2], 16);

        // 編集モードならカラーパレットにも反映
        this.axpObj.colorPaletteSystem.setColor(colorcode);
        // ペンプレビュー
        this.axpObj.penSystem.previewPenSize();
        this.updateTemporaryPalette();
    }
    // パレット選択状態の変更
    selectPalette(target = 'none') {
        //console.log('select', typeof target);
        // 混色パレットが既に選択されていれば解除
        let old = document.querySelector('#axp_makecolor_div_mixedPalette>div>div[data-selected="true"]');
        if (old) {
            old.dataset.selected = '';
        }
        // 未指定の場合、サブ以外が選択されているなら、メインに戻す
        if (target === 'none') {
            if (document.getElementById('axp_makecolor_div_subColor').dataset.selected === 'true') {
                // サブカラー選択状態
            } else {
                target = 'main';
            }
        }
        switch (target) {
            case 'main':
                document.getElementById('axp_makecolor_div_mainColor').dataset.selected = 'true';
                document.getElementById('axp_makecolor_div_subColor').dataset.selected = 'false';
                document.getElementById('axp_makecolor_div_transparent').dataset.selected = 'false';
                break;
            case 'sub':
                document.getElementById('axp_makecolor_div_mainColor').dataset.selected = 'false';
                document.getElementById('axp_makecolor_div_subColor').dataset.selected = 'true';
                document.getElementById('axp_makecolor_div_transparent').dataset.selected = 'false';
                break;
            case 'transparent':
                document.getElementById('axp_makecolor_div_mainColor').dataset.selected = 'false';
                document.getElementById('axp_makecolor_div_subColor').dataset.selected = 'false';
                document.getElementById('axp_makecolor_div_transparent').dataset.selected = 'true';
                break;
        }
        if (typeof target === 'object') {
            // 混色パレット指定
            target.dataset.selected = 'true';
            document.getElementById('axp_makecolor_div_mainColor').dataset.selected = 'false';
            document.getElementById('axp_makecolor_div_subColor').dataset.selected = 'false';
            document.getElementById('axp_makecolor_div_transparent').dataset.selected = 'false';
            document.getElementById('axp_makecolor_div_mainColor').dataset.mixed = 'true';
        } else {
            // 混色パレット以外
            document.getElementById('axp_makecolor_div_mainColor').dataset.mixed = 'false';
        }
    }
    // 混色パレット：新規作成
    createTemporaryPalette() {
        const box = document.querySelector('#axp_makecolor_div_mixedPalette>div');
        // パレットボックスの要素の全削除
        while (box.firstChild) {
            box.removeChild(box.firstChild);
        }
        // HTML生成
        const createPaletteHTML = (colorcode, index) => {
            const newDiv = document.createElement('div');
            newDiv.setAttribute('class', 'axpc_makecolor_mixedColorRect');
            newDiv.dataset.color = colorcode;
            newDiv.style.backgroundColor = colorcode;
            const percentage = (index + 1) * 5;
            // パレットにカーソルを当てたとき
            newDiv.addEventListener('pointerenter', (e) => {
                // 描画色を混色パレット(%1%)に変更します。RGB:(%2)
                this.axpObj.msg('@AXP2000', percentage, (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(e.target.dataset.color));
            });
            // パレットがクリックされたとき
            newDiv.addEventListener('click', (e) => {
                var colorcode = e.target.dataset.color;
                // 混色パレットを選択
                this.selectPalette(e.target);
                // ピッカーなどをメインカラーに戻す
                this.setMainColor(this.maincolor);
                // 混色パレット(%1%) RGB:(%2)
                this.axpObj.msg('@COL0004', percentage, (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(colorcode));
            });
            return newDiv;
        }
        // ２０個分ループ生成
        for (let index = 0; index < 20; index++) {
            // 画面に作成したカラーパレットを追加
            box.appendChild(
                createPaletteHTML(this.adjust(index), index)
            );
        }
    }
    // 混色パレット：更新
    updateTemporaryPalette() {
        const palettes = document.querySelectorAll('#axp_makecolor_div_mixedPalette>div>div');
        let index = 0;
        for (let item of palettes) {
            item.dataset.color = this.adjust(index);
            item.style.backgroundColor = this.adjust(index);
            index++;
        }
    }
    adjust(index) {
        // メインカラーを、明度補正の値を加味したカラーコードに調整して返却
        let rgb1 = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.maincolor);
        let rgb2 = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.subcolor);
        let alpha = (index + 1) * 5 / 100;
        let d_red;
        let d_green;
        let d_blue;
        d_red = Math.floor(rgb2[0] * alpha + rgb1[0] * (1 - alpha));
        d_green = Math.floor(rgb2[1] * alpha + rgb1[1] * (1 - alpha));
        d_blue = Math.floor(rgb2[2] * alpha + rgb1[2] * (1 - alpha));
        let newcolor = [d_red, d_green, d_blue];
        return "#" + (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.rgb2hex)(newcolor);
    };
    // 他システムが参照する色
    getAdjustColor() {
        return this.getPaletteColor();
    }
    getAdjustColorRGB() {
        return (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.getAdjustColor());
    }
    // 混色パレットを考慮した色の取得
    getPaletteColor() {
        let temporary = document.querySelector('#axp_makecolor_div_mixedPalette>div>div[data-selected="true"]');
        if (temporary) {
            return temporary.dataset.color;
        } else {
            if (document.getElementById('axp_makecolor_div_subColor').dataset.selected === 'true') {
                return this.subcolor;
            } else {
                // 透明色の時含む
                return this.maincolor;
            }
        }
    }
    getPaletteColorRGB() {
        return (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.getPaletteColor());
    }
    getSubColor() {
        return this.subcolor;
    }
    setSubColor(colorcode) {
        this.subcolor = colorcode;
        document.getElementById('axp_makecolor_div_subColor').style.backgroundColor = colorcode;
    }
    swap_maincolor() {
        // メインカラーとサブカラーの交換
        // サブカラー選択状態なら解除
        if (document.getElementById('axp_makecolor_div_subColor').dataset.selected === 'true') {
            this.selectPalette('main');
            this.setMainColor(this.maincolor);
            // メインカラー RGB:(%1)
            this.axpObj.msg('@COL0001', (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.maincolor));
        } else {
            this.selectPalette('sub');
            this.setMainColor(this.subcolor);
            // サブカラー RGB:(%1)
            this.axpObj.msg('@COL0001', (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.subcolor));
        }
        this.axpObj.penSystem.previewPenSize();
    }
    swap_transparent() {
        // 透明色選択状態なら解除
        if (document.getElementById('axp_makecolor_div_transparent').dataset.selected === 'true') {
            this.selectPalette('main');
            this.setMainColor(this.maincolor);
            // メインカラー RGB:(%1)
            this.axpObj.msg('@COL0001', (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.maincolor));
        } else {
            this.selectPalette('transparent');
            this.setMainColor(this.maincolor);
            // 透明色
            this.axpObj.msg('@COL0002');
        }
        this.axpObj.penSystem.previewPenSize();
    }
    updateMakeColorType() {
        // 混色パレット
        switch (this.axpObj.config('axp_config_form_makeColorTypeMixed')) {
            case 'off':
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide('axp_makecolor_div_mixedPalette');
                // 混色パレットの選択を解除する
                this.selectPalette('main');
                break;
            case 'on':
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show('axp_makecolor_div_mixedPalette');
                break;
        }
        // RGBスライダー
        switch (this.axpObj.config('axp_config_form_makeColorTypeRGB')) {
            case 'off':
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide('axp_makecolor_div_RGBSlider');
                break;
            case 'on':
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show('axp_makecolor_div_RGBSlider');
                break;
        }
        // カラーピッカータイプ
        switch (this.axpObj.config('axp_config_form_makeColorTypePicker')) {
            case 'off':
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide('axp_makecolor_div_colorPicker');
                break;
            case 'on':
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show('axp_makecolor_div_colorPicker');
                break;
        }
    }
}

/***/ }),

/***/ "./src/js/window_palette.js":
/*!**********************************!*\
  !*** ./src/js/window_palette.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorPaletteSystem: () => (/* binding */ ColorPaletteSystem)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./window.js */ "./src/js/window.js");
/* harmony import */ var _html_window_palette_txt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../html/window_palette.txt */ "./src/html/window_palette.txt");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./etc.js */ "./src/js/etc.js");
// @description ツールウィンドウ：親クラス＞パレット



// css適用
__webpack_require__(/*! ../css/window_palette.css */ "./src/css/window_palette.css");



// デフォルトカラーパレット
const arrayPaletteDefault = [
    '#000000',
    '#333333',
    '#777777',
    '#cccccc',
    '#32486f',
    '#1b25b5',
    '#ba09ba',
    '#ff3bde',
    '#0cc3e8',
    '#852f04',
    '#b80410',
    '#d12c2c',
    '#e88460',
    '#ff8b1f',
    '#56bc9d',
    '#0fc23c',
    '#87ee6d',
    '#ffff47',
    '#fffcb4',
    '#ffc076',
    '#ffc4b5',
    '#ffe4d6',
    '#fff5df',
    '#ffffff'
];

// カラーパレット制御オブジェクト
class ColorPaletteSystem extends _window_js__WEBPACK_IMPORTED_MODULE_0__.ToolWindow {
    CONST = {
        // 最大カラーパレット数
        COLOR_MAX: 50,
    }
    // パレット情報
    currentPalette = {
        column: 5,
        // パレット配列（カラーコードの配列）
        palette: [],
    }

    // 編集中フラグ
    isEditMode = false;
    // 現在選択中のパレット要素
    elementCurrentPalette;
    elementPaletteBox;

    constructor(axpObj) {
        super(axpObj);
    }
    // 初期ウィンドウ位置
    getDefaultPosition() {
        return {
            //left: this.axpObj.paintBodyElement.clientWidth - this.window_width - 200,
            left: this.axpObj.paintBodyElement.clientWidth - this.window_width - 74,
            top: 250,
        }
    }
    // 初期化（＆キャンバスリセット時の再初期化）
    init() {
        // HTML
        this.createHTML(
            'axp_palette',
            'PLT',
            this.axpObj._('@WINDOW.SWATCHES'),
            'axpc_icon_window_palette',
            _html_window_palette_txt__WEBPACK_IMPORTED_MODULE_1__
        );
        this.window_width = 46;
        // 初期座標設定
        const pos = this.getDefaultPosition();
        this.window_left = pos.left;
        this.window_top = pos.top;
        // パレット要素取得
        this.elementPaletteBox = document.getElementById('axp_palette_div_paletteBox');
        // デフォルトパレット配列生成
        this.setPaletteArray();
    }
    // イベント受付開始
    startEvent() {
        // ボタン：編集モード
        const edit = () => {
            // 編集モードに切り替わる場合、事前にメインカラーを更新
            if (!this.isEditMode) {
                this.axpObj.colorMakerSystem.setMainColor(this.getColor());
                // ペンプレビュー
                this.axpObj.penSystem.previewPenSize();
            }
            // 編集中フラグ更新
            this.isEditMode = !this.isEditMode;
            if (this.isEditMode) {
                // ボタンを凹ませる
                document.getElementById('axp_palette_button_edit').dataset.selected = 'true';
                // 削除ボタン表示
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show('axp_palette_button_delete');
                // 列数スライダー表示
                if (document.getElementById('axp_config_checkbox_paletteColumnEdit').checked) {
                    const elemSlider = document.getElementById('axp_palette_div_column');
                    //elemSlider.style.top = this.window_top + 'px';
                    //elemSlider.style.left = this.window_left + 'px';
                    _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show(elemSlider);
                }
                // ツールウィンドウの色を変化（注意喚起）
                document.getElementById('axp_palette').classList.add('axpc_window_attention');
                // パレット編集モードに切り替えました。（パレットの更新／位置入れ替え／削除が行えます）
                this.axpObj.msg('@INF3000');
            } else {
                // 設定の解除
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide('axp_palette_button_delete');
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide('axp_palette_div_column');
                document.getElementById('axp_palette_button_edit').dataset.selected = 'false';
                document.getElementById('axp_palette').classList.remove('axpc_window_attention');
                // パレット編集モードを解除しました。
                this.axpObj.msg('@INF3001');
            }
        }
        document.getElementById('axp_palette_button_edit').onclick = edit;

        const p_delete = () => {
            if (this.currentPalette.palette.length <= 1) {
                // すべてのパレットを削除することはできません。
                this.axpObj.msg('@CAU3000');
                return;
            }
            // index取得
            let idx;
            for (idx = 0; idx < this.elementPaletteBox.childElementCount; idx++) {
                if (this.elementPaletteBox.children[idx] === this.elementCurrentPalette) {
                    break;
                }
            }
            // パレット配列から削除
            this.currentPalette.palette.splice(idx, 1);
            // DBへ保存
            this.axpObj.saveSystem.save_palette(this.currentPalette.palette);

            // 画面から削除
            this.elementPaletteBox.removeChild(this.elementCurrentPalette);

            // パレット列数更新
            this.updatePaletteColumn();

            // カレントパレットの設定
            if (idx === this.elementPaletteBox.childElementCount) {
                // 末尾のパレットを削除した場合は、indexを一つ手前にずらす
                idx--;
            }
            this.elementCurrentPalette = this.elementPaletteBox.children[idx];
            this.elementCurrentPalette.dataset.selected = 'true';

            // 削除によって新しく選択されたパレット
            let colorcode = this.elementCurrentPalette.dataset.color;
            // 色を変更
            this.axpObj.colorMakerSystem.setMainColor(colorcode);
            // ペンプレビュー
            this.axpObj.penSystem.previewPenSize();

            // カラーパレットを削除しました。
            this.axpObj.msg('@INF3002');
        }
        document.getElementById('axp_palette_button_delete').onclick = p_delete;

        // ボタン：登録
        document.getElementById('axp_palette_button_addColor').addEventListener('click', () => {
            this.addcolor();
        });
        // カラーパレットの列数
        document.getElementById('axp_palette_range_column').oninput = (e) => {
            this.setPaletteColumn(e.target.value);
        }
    }

    addcolor() {
        let colorcode = this.axpObj.colorMakerSystem.getAdjustColor();
        if (this.currentPalette.palette.length >= this.CONST.COLOR_MAX) {
            // 登録できるパレット数は%1個までです。
            this.axpObj.msg('@CAU3001', this.CONST.COLOR_MAX);
            return;
        }

        var box = document.getElementById('axp_palette_div_paletteBox');
        // 現在のパレットを選択解除
        this.elementCurrentPalette.dataset.selected = '';
        // 登録：パレットボックスの最後尾に追加
        this.elementCurrentPalette = box.appendChild(this.createPaletteHTML(colorcode));
        // 新パレットを選択
        this.elementCurrentPalette.dataset.selected = 'true';

        // パレット配列追加
        this.currentPalette.palette.push(colorcode);
        // DBへ保存
        this.axpObj.saveSystem.save_palette(this.currentPalette.palette);

        // パレット列数更新
        this.updatePaletteColumn();
        // カラーパレットを登録しました。RGB:(%1)
        this.axpObj.msg('@INF3003', (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(colorcode));
    }

    // パレットのドラッグ＆ドロップ
    drag_down(e) {
        const target = e.currentTarget;
        const pageX = e.pageX;
        const pageY = e.pageY;
        ps_data.idx_source = palette_sorting.index(target); // 移動するパレットの添字
        ps_data.target = target;
        ps_data.diffX = pageX;
        ps_data.diffY = pageY;
        ps_data.ofx = target.offsetLeft;
        ps_data.ofy = target.offsetTop;

        const targetPosL = ps_data.ofx;
        const targetPosT = ps_data.ofy;
        target.style.left = `${targetPosL}px`;
        target.style.top = `${targetPosT}px`;

        ps_data.cloneName = palette_sorting.insertClone(target, palette_sorting.index(target));
        // クラス名axpc_onGRABを付与することで、CSSで指定してあるposition: absolute;が有効となる→自由にドラッグができる
        target.classList.add('axpc_onGRAB');
        // ドラッグ中
        const onPointerMove = (e) => {
            const target = ps_data.target;
            const pageX = e.pageX;
            const pageY = e.pageY;
            const targetPosL = ps_data.ofx + pageX - ps_data.diffX;
            const targetPosT = ps_data.ofy + pageY - ps_data.diffY;
            target.style.left = `${targetPosL}px`;
            target.style.top = `${targetPosT}px`;
            palette_sorting.swap(target);
        }
        // ドロップ
        const onPointerUp = () => {
            const target = ps_data.target;
            const cloneSelector = `.${ps_data.cloneName}`;
            const clone = document.querySelector(cloneSelector);
            ps_data.cloneName = '';
            clone.remove();
            target.classList.remove('axpc_onGRAB');
            // イベントリスナー解除
            window.removeEventListener('pointermove', onPointerMove);
            window.removeEventListener('pointerup', onPointerUp);

            // 操作終了時のインデックス
            ps_data.idx_dest = palette_sorting.index(target);

            //console.log(`開始:${ps_data.idx_source} 終了:${ps_data.idx_dest}`);

            // 実際に入れ替えが行われたかを判定する（開始時と終了時でindexが異なる場合）
            if (ps_data.idx_source !== ps_data.idx_dest) {
                // パレット配列
                const color = this.currentPalette.palette[ps_data.idx_source];
                // 開始位置のパレットを削除
                this.currentPalette.palette.splice(ps_data.idx_source, 1);
                // 終了位置にパレットを挿入
                this.currentPalette.palette.splice(ps_data.idx_dest, 0, color);
                // DBへ保存
                this.axpObj.saveSystem.save_palette(this.currentPalette.palette);
            }
        }
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
    }

    getColor() {
        // 現在選択中のパレットを返却
        // #13 バグ修正に伴い、引数指定は廃止
        return this.elementCurrentPalette.dataset.color;
    }
    setColor(colorCode) {
        // 編集モードでなければ処理しない
        if (!this.isEditMode) return;
        // index取得
        let idx;
        for (idx = 0; idx < this.elementPaletteBox.childElementCount; idx++) {
            if (this.elementPaletteBox.children[idx] === this.elementCurrentPalette) {
                break;
            }
        }
        // 現在選択中のパレットを、メインカラーに更新
        this.elementCurrentPalette.style.backgroundColor = colorCode;
        this.elementCurrentPalette.dataset.color = colorCode;
        // パレット配列更新
        this.currentPalette.palette[idx] = colorCode;
        // DBへ保存
        this.axpObj.saveSystem.save_palette(this.currentPalette.palette);

    }
    setPaletteArray(array) {
        if (array === undefined) {
            array = arrayPaletteDefault;
            this.currentPalette.column = 3;
        }
        // パレット最大数を超過していたらエラー
        if (array.length > this.CONST.COLOR_MAX) {
            throw new Error('colorPalette MAX over');
        }
        for (let idx = 0; idx < array.length; idx++) {
            // カラーコードの先頭に#がついていない場合、#を付与する（ver.1.13以前と互換）
            if (array[idx].substring(0, 1) !== '#') {
                array[idx] = '#' + array[idx];
            }
        }
        this.currentPalette.palette.splice(0);
        // そのまま代入するとパレットの更新で元の配列が上書きされてしまうため、値をコピーする
        for (let item of array) {
            this.currentPalette.palette.push(item);
        }
    }

    setPaletteColumn(col) {
        let column = Number(col)
        // 桁数０を折り返し無しと定義する
        if (column > this.currentPalette.palette.length) {
            column = 0;
        }
        this.currentPalette.column = column;
        // 列数の更新
        this.updatePaletteColumn();
        this.axpObj.configSystem.saveConfig('PLTCO', column);
    }
    // パレット全体の生成
    createPalette() {
        // パレットボックスの要素の全削除
        while (this.elementPaletteBox.firstChild) {
            this.elementPaletteBox.removeChild(this.elementPaletteBox.firstChild);
        }
        for (const item of this.currentPalette.palette) {
            // 画面に作成したカラーパレットを追加
            this.elementPaletteBox.appendChild(this.createPaletteHTML(item));
        }
        // 最初の要素を選択済みにする
        this.elementCurrentPalette = document.querySelector('#axp_palette_div_paletteBox :first-child');
        this.elementCurrentPalette.dataset.selected = 'true';
        // 列数の更新
        this.updatePaletteColumn();
    }
    // パレット全体の生成
    updatePaletteColumn() {
        const length = this.currentPalette.palette.length;
        const column = this.currentPalette.column;
        const row = column !== 0 ? Math.ceil(length / column) : 1;
        //console.log(`length:${length} row:${row} columm:${column}`);

        let elementWindow = document.getElementById('axp_palette');
        let elementContainer = document.getElementById('axp_palette_div_container');
        let elementButtonBox = document.getElementById('axp_palette_div_buttons');
        let elementPaletteBox = document.getElementById('axp_palette_div_paletteBox');

        let newColumn;
        if (column === 0) {
            // 折り返し無しの時
            newColumn = length;
            elementContainer.style.flexDirection = 'row';
            elementButtonBox.style.flexWrap = 'nowrap';
        } else {
            newColumn = column;
            elementContainer.style.flexDirection = 'column';
            elementButtonBox.style.flexWrap = 'wrap';
        }
        let newWidthPalette = newColumn * 32;
        let newWidthWindow = newWidthPalette + 14;

        // パレットの幅
        elementPaletteBox.style.width = newWidthPalette + 'px';

        // 折り返し無しの時以外で、列数が２以下の場合、ウィンドウ幅も縮める
        if (column !== 0 && newColumn <= 2) {
            elementWindow.style.width = newWidthWindow + 'px';
        } else {
            elementWindow.style.width = 'auto';
        }
        this.currentPalette.height = 32 * row;

        // 列数スライダーの値更新
        let range_index = column;
        let value = column;
        if (column === 0) {
            // 折り返し無しの場合、数値の表示を変換する
            range_index = length + 1;
            value = '∞';
        }

        // 現在のパレット数＋１までスライダーを選択できるようにする
        // パレット側スライダー
        document.getElementById('axp_palette_range_column').max = length + 1;
        document.getElementById('axp_palette_range_column').value = range_index;
        document.getElementById('axp_palette_form_column').result.value = value;
        // 設定側スライダー
        document.getElementById('axp_config_form_paletteColumnValue').volume.max = length + 1;
        document.getElementById('axp_config_form_paletteColumnValue').volume.value = range_index;
        document.getElementById('axp_config_form_paletteColumnValue').result.value = value;

        // 設定用カラーパレット表示更新
        this.axpObj.configSystem.dispPalettebox(document.getElementById('axp_config_div_paletteBox'), this.currentPalette);
    }

    // カラーパレット（単体）のHTML生成
    createPaletteHTML(colorcode) {
        const newButton = document.createElement('button');
        newButton.setAttribute('class', 'axpc_palette_colorRect');
        newButton.dataset.color = colorcode;
        newButton.style.backgroundColor = colorcode;

        // パレットにカーソルを当てたとき
        newButton.addEventListener('pointerenter', (e) => {
            //console.log(e);
            //console.log(this);
            if (this.isEditMode) {
                // [編集モード] ドラッグで位置を入れ替え。カラーツール操作で選択中パレットの色を更新。
                this.axpObj.msg('@AXP3000');
            } else {
                //%drawingColorNameを指定色に変更します。RGB:(%1)
                this.axpObj.msg('@AXP3001', (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(e.target.dataset.color));
            }
        });
        // パレットがクリックされたとき
        newButton.addEventListener('pointerdown', (e) => {
            var colorcode = e.target.dataset.color;

            // 編集モード
            if (this.isEditMode) {
                this.drag_down(e);
            }

            // 透明色選択状態なら解除
            this.axpObj.colorMakerSystem.selectPalette();

            // 現在選択されているカラーパレットIDの更新
            this.elementCurrentPalette.dataset.selected = "";
            this.elementCurrentPalette = e.target;
            this.elementCurrentPalette.dataset.selected = "true";

            // 色を変更
            this.axpObj.colorMakerSystem.setMainColor(colorcode);
            // ペンツールの表示を更新
            this.axpObj.penSystem.changePenMode();

            // %drawingColorName RGB:(%1)
            this.axpObj.msg('@COL0001', (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(colorcode));
        });

        return newButton;
    }
}

// カラーパレットのドラッグ＆ドロップ制御
const palette_sorting = {
    index(el) {
        const parent = el.parentElement;
        const siblings = parent.children;
        const siblingsArr = [].slice.call(siblings);
        const idx = siblingsArr.indexOf(el);

        return idx;
    },
    insertClone(target, insertIdx) {
        // その場に非表示のクローンを置いて全体のレイアウトが崩れないようにする
        const cloneName = `ddItemClone_${Math.trunc(Math.random() * 10000)}`;
        const clone = target.cloneNode(true);
        const parent = target.parentElement;
        const siblings = parent.children;

        clone.classList.add('axpc_HIDDEN');
        clone.classList.add(cloneName);
        siblings[insertIdx].insertAdjacentElement('afterend', clone);

        return cloneName;
    },
    swap(target) {
        const selfIdx = palette_sorting.index(target);
        const cloneIdx = selfIdx + 1;
        const parent = target.parentElement;
        const siblings = parent.querySelectorAll(`:scope > *:not(.axpc_onGRAB):not(.${ps_data.cloneName})`);

        for (let thatIdx = 0, len = siblings.length; thatIdx < len; thatIdx++) {
            const targetW = target.offsetWidth;
            const targetH = target.offsetHeight;
            const targetRect = target.getBoundingClientRect();
            const targetRectX = targetRect.left;
            const targetRectY = targetRect.top;
            const that = siblings[thatIdx];
            const thatW = that.offsetWidth;
            const thatH = that.offsetHeight;
            const thatRect = that.getBoundingClientRect();
            const thatRectX = thatRect.left;
            const thatRectY = thatRect.top;
            const thatRectXHalf = thatRectX + (thatW / 2);
            const thatRectYHalf = thatRectY + (thatH / 2);
            const hitX = targetRectX <= thatRectXHalf && (targetRectX + targetW) >= thatRectXHalf;
            const hitY = targetRectY <= thatRectYHalf && (targetRectY + targetH) >= thatRectYHalf;
            const isHit = hitX && hitY;

            if (isHit) {
                const siblingsAll = parent.children;
                const clone = siblingsAll[cloneIdx];

                parent.insertBefore(clone, selfIdx > thatIdx ? that : that.nextSibling);
                parent.insertBefore(target, clone);

                break;
            }

        }
    }
};
let ps_data = {
    target: null,
    diffX: 0,
    diffY: 0,
    ofx: 0,
    ofy: 0,
    idx_source: null,
    idx_dest: null,
};


/***/ }),

/***/ "./src/js/window_pen.js":
/*!******************************!*\
  !*** ./src/js/window_pen.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PenSystem: () => (/* binding */ PenSystem)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./window.js */ "./src/js/window.js");
/* harmony import */ var _html_window_pen_txt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../html/window_pen.txt */ "./src/html/window_pen.txt");
/* harmony import */ var _html_penmode_txt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../html/penmode.txt */ "./src/html/penmode.txt");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./etc.js */ "./src/js/etc.js");
/* harmony import */ var _pendefine_rangeindex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pendefine/rangeindex.js */ "./src/js/pendefine/rangeindex.js");
/* harmony import */ var _pendefine_round_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pendefine/round.js */ "./src/js/pendefine/round.js");
/* harmony import */ var _pendefine_eraser_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pendefine/eraser.js */ "./src/js/pendefine/eraser.js");
/* harmony import */ var _pendefine_eraser_dot_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pendefine/eraser_dot.js */ "./src/js/pendefine/eraser_dot.js");
/* harmony import */ var _pendefine_fill_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./pendefine/fill.js */ "./src/js/pendefine/fill.js");
/* harmony import */ var _pendefine_fillgradation_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pendefine/fillgradation.js */ "./src/js/pendefine/fillgradation.js");
/* harmony import */ var _pendefine_hand_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./pendefine/hand.js */ "./src/js/pendefine/hand.js");
/* harmony import */ var _pendefine_spuit_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./pendefine/spuit.js */ "./src/js/pendefine/spuit.js");
/* harmony import */ var _pendefine_square_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pendefine/square.js */ "./src/js/pendefine/square.js");
/* harmony import */ var _pendefine_move_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./pendefine/move.js */ "./src/js/pendefine/move.js");
/* harmony import */ var _pendefine_dot_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./pendefine/dot.js */ "./src/js/pendefine/dot.js");
/* harmony import */ var _pendefine_fude_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./pendefine/fude.js */ "./src/js/pendefine/fude.js");
/* harmony import */ var _pendefine_crayon_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./pendefine/crayon.js */ "./src/js/pendefine/crayon.js");
/* harmony import */ var _pendefine_brush_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./pendefine/brush.js */ "./src/js/pendefine/brush.js");
// @description ツールウィンドウ：親クラス＞ペンツール





// css適用
__webpack_require__(/*! ../css/window_pen.css */ "./src/css/window_pen.css");




// メイン










// サブ








// 共通処理：ペンモード変更時
class PenSystem extends _window_js__WEBPACK_IMPORTED_MODULE_0__.ToolWindow {
    pen_mode; // 選択中の機能
    exec_pen_mode; // 実行中の機能
    isTemporary = false;
    temporaryMode; // 一時的なモード変更（CTRL SPACE時）
    saveElement;
    saveMode;
    saveIcon;
    saveMsg;
    penObj = [];
    CONST = {
    }
    CANVAS = {
        // 描画内容を書き込む仮想キャンバス
        draw: null,
        draw_ctx: null,
        brush: null,
        brush_ctx: null,
        // スクリーントーン
        tone: null,
        tone_ctx: null,
        // スポイト拡大用キャンバス
        spuit: null,
        spuit_ctx: null,
        // ペンの太さプレビューキャンバス
        pensize: null,
        pensize_ctx: null,
    };

    base_index = null;
    old_x;
    old_y;
    preview_dragstart_x;
    preview_dragstart_y;

    stabilizerX = 0;
    stabilizerY = 0;

    constructor(axpObj) {
        super(axpObj);
    }
    // 初期ウィンドウ位置
    getDefaultPosition() {
        return {
            left: 0,
            top: 100,
        }
    }
    // 初期化
    init() {
        // HTML
        this.createHTML(
            'axp_pen',
            'PEN',
            this.axpObj._('@WINDOW.PEN_TOOL'),
            'axpc_icon_window_pen',
            _html_window_pen_txt__WEBPACK_IMPORTED_MODULE_1__
        );
        // ペン種別選択サブメニューのHTMLを展開
        document.getElementById('axp_canvas').insertAdjacentHTML('beforeend', this.axpObj.translateHTML(_html_penmode_txt__WEBPACK_IMPORTED_MODULE_2__));

        this.window_width = 180;
        // 初期座標設定
        const pos = this.getDefaultPosition();
        this.window_left = pos.left;
        this.window_top = pos.top;
        // 仮想キャンバス
        this.CANVAS.draw = document.createElement('canvas');
        this.CANVAS.draw_ctx = this.CANVAS.draw.getContext('2d', { willReadFrequently: true });
        // ブラシ用キャンバス
        this.CANVAS.brush = document.createElement('canvas');
        this.CANVAS.brush_ctx = this.CANVAS.brush.getContext('2d');
        // ペンの太さプレビューキャンバス
        this.CANVAS.pensize = document.getElementById('axp_pen_canvas_previewPenSize');
        this.CANVAS.pensize.width = 100;
        this.CANVAS.pensize.height = 100;
        this.CANVAS.pensize_ctx = this.CANVAS.pensize.getContext('2d');
        // スポイト用キャンバス
        this.CANVAS.spuit = document.getElementById('axp_pen_canvas_previewSpuit');
        this.CANVAS.spuit.width = 5;
        this.CANVAS.spuit.height = 5;
        this.CANVAS.spuit_ctx = this.CANVAS.spuit.getContext('2d');

        // メイン
        this.penObj['axp_penmode_round'] = new _pendefine_round_js__WEBPACK_IMPORTED_MODULE_5__.Round({ axpObj: this.axpObj, CANVAS: this.CANVAS });
        this.penObj['axp_penmode_eraser_round'] = new _pendefine_eraser_js__WEBPACK_IMPORTED_MODULE_6__.Eraser({ axpObj: this.axpObj, CANVAS: this.CANVAS });
        this.penObj['axp_penmode_eraser_dot'] = new _pendefine_eraser_dot_js__WEBPACK_IMPORTED_MODULE_7__.EraserDot({ axpObj: this.axpObj, CANVAS: this.CANVAS });

        this.penObj['axp_penmode_fill'] = new _pendefine_fill_js__WEBPACK_IMPORTED_MODULE_8__.Fill({ axpObj: this.axpObj, CANVAS: this.CANVAS });
        this.penObj['axp_penmode_fillgradation'] = new _pendefine_fillgradation_js__WEBPACK_IMPORTED_MODULE_9__.Fillgradation({ axpObj: this.axpObj, CANVAS: this.CANVAS });

        this.penObj['axp_penmode_hand'] = new _pendefine_hand_js__WEBPACK_IMPORTED_MODULE_10__.Hand({ axpObj: this.axpObj, CANVAS: this.CANVAS });
        this.penObj['axp_penmode_spuit'] = new _pendefine_spuit_js__WEBPACK_IMPORTED_MODULE_11__.Spuit({ axpObj: this.axpObj, CANVAS: this.CANVAS });
        // サブ
        this.penObj['axp_penmode_square'] = new _pendefine_square_js__WEBPACK_IMPORTED_MODULE_12__.Square({ axpObj: this.axpObj, CANVAS: this.CANVAS });
        this.penObj['axp_penmode_move'] = new _pendefine_move_js__WEBPACK_IMPORTED_MODULE_13__.Move({ axpObj: this.axpObj, CANVAS: this.CANVAS });
        this.penObj['axp_penmode_dot'] = new _pendefine_dot_js__WEBPACK_IMPORTED_MODULE_14__.Dot({ axpObj: this.axpObj, CANVAS: this.CANVAS });
        this.penObj['axp_penmode_fude'] = new _pendefine_fude_js__WEBPACK_IMPORTED_MODULE_15__.Fude({ axpObj: this.axpObj, CANVAS: this.CANVAS });
        this.penObj['axp_penmode_crayon'] = new _pendefine_crayon_js__WEBPACK_IMPORTED_MODULE_16__.Crayon({ axpObj: this.axpObj, CANVAS: this.CANVAS });
        this.penObj['axp_penmode_brush'] = new _pendefine_brush_js__WEBPACK_IMPORTED_MODULE_17__.Brush({ axpObj: this.axpObj, CANVAS: this.CANVAS });

        // サブメニューをメインメニューに反映
        let elementsButton = document.querySelectorAll('#axp_pen_div_rightSide>div>button');
        let elementsButtonSub = document.querySelectorAll('#axp_penmode>div>article>button:first-of-type');
        // メインメニューの初期割り当て（サブボタンの先頭を登録）
        elementsButton.forEach((element, index) => {
            // ガイドメッセージ（サブボタンのメインボタンのメッセージを結合）
            element.dataset.addmsg = elementsButtonSub[index].dataset.msg;
            // ID情報
            element.dataset.set = elementsButtonSub[index].id;
            // アイコン
            element.classList.add(this.getClassIcon(elementsButtonSub[index].id));
        });
        // 初期ペン
        this.pen_mode = elementsButtonSub[0].id;
    }
    // id名からアイコン用class名を取得
    getClassIcon(id) {
        return id.replace('axp_', 'axpc_');
    }
    resetCanvas() {
        // 描画用仮想キャンバスサイズ指定
        this.CANVAS.draw.width = this.axpObj.x_size;
        this.CANVAS.brush.width = this.axpObj.x_size * this.axpObj.CONST.DRAW_MULTI;

        this.CANVAS.draw.height = this.axpObj.y_size;
        this.CANVAS.brush.height = this.axpObj.y_size * this.axpObj.CONST.DRAW_MULTI;
    }
    // ペンツール変更（メインボタン）
    switchMainButton(element, caller = null) {
        if (!this.isSwitchable()) return;
        // メインボタン
        let target = element;
        // スポイト以外のボタンが再選択されたらサブメニューオープン（ショートカットで呼び出された場合caller!=null、サブメニューは開かない）
        if (target.dataset.idx !== '4' &&
            !caller &&
            target.dataset.selected === 'true') {

            let targetElements_button = document.querySelectorAll('#axp_pen_div_rightSide>div>button');
            for (const item of targetElements_button) {
                if (item !== target) {
                    item.style.opacity = '0.3';
                }
            }
            let idx = Number(target.dataset.idx);
            let targetElements_article = document.querySelectorAll('#axp_penmode>div>article');

            // 一旦全部非表示
            for (const item of targetElements_article) {
                _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.hide(item);
            }
            // 選択されたdata-idxに対応するサブウィンドウ要素
            let subwindow = targetElements_article[Number(idx)];
            // 種別名表示
            document.getElementById('axp_penmode_span_modeName').textContent = `${subwindow.dataset.name}${this.axpObj._('@PEN.TYPE')}`;
            // 選択されたメインボタンに対応するサブウィンドウだけ表示
            _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.show(subwindow);
            // キャンバスタブエリアの位置（左上座標調整用）
            const canvasRect = document.getElementById('axp_canvas').getBoundingClientRect();
            // サブボタンメニューの表示座標指定
            let rect = document.getElementById('axp_pen_div_leftSide').getBoundingClientRect();
            let elem = document.querySelector('#axp_penmode>div');
            elem.style.width = (rect.width + 5) + 'px';
            elem.style.height = (rect.height + 4) + 'px';
            elem.style.marginLeft = (rect.left - 4 - canvasRect.left) + 'px';
            elem.style.marginTop = (rect.top - 2 - canvasRect.top) + 'px';
            // サブウィンドウの表示
            this.axpObj.isModalOpen = true;
            // ペンツールの機能選択中です。
            this.axpObj.msg('@AXP5010');
            _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.show('axp_penmode');
        } else {
            this.switchButton(target);
        }
    }
    // ペン種別変更（サブボタン）
    switchSubButton(element) {
        if (!this.isSwitchable()) return;
        // 押されたボタン
        let target = element;
        // メインボタン（data-idxをキーに対応するメインボタンを特定する）
        const elementButtonMain = document.querySelector(`#axp_pen_div_rightSide>div>button[data-idx="${target.dataset.idx}"]`);
        // メインボタンにセットされているサブボタンclassを消去
        console.log(elementButtonMain);
        elementButtonMain.classList.remove(this.getClassIcon(elementButtonMain.dataset.set));
        // メインボタンに押されたサブボタンのid名のclassを付与（これによりメインボタンのアイコンが変更される）
        elementButtonMain.classList.add(this.getClassIcon(target.id));
        // メインボタンに選択されたサブボタンのidを格納（これによりメインボタンを押すことで、サブボタンのペンが呼び出される）
        elementButtonMain.dataset.set = target.id;
        // メインボタンにメッセージを格納
        elementButtonMain.dataset.addmsg = target.dataset.msg;
        let newMode = target.id;
        console.log('サブ選択:', newMode);
        // モード変更
        this.switchButton(elementButtonMain);
    }
    // メインボタンの選択状態切替
    switchButton(elementButton) {
        // 選択状態の全クリア
        const elems_penicon = document.querySelectorAll('#axp_pen_div_rightSide>div>button');
        for (const item of elems_penicon) {
            item.dataset.selected = 'false';
        }
        // ボタンを選択状態にする
        elementButton.dataset.selected = 'true';
        let newMode = elementButton.dataset.set;
        console.log('メイン選択:', newMode);
        // モード変更
        this.changePenMode(newMode);
    }
    // メインボタンが切り替え可能な状態であるかのチェック
    isSwitchable() {
        // ショートカットによるスポイト、ハンド使用時は、処理しない（状態を上書きしてしまうと元に戻せないため）
        if (this.axpObj.isCTRL) {
            // [ CTRL ]キーでスポイトに変化中です。別のペンは選択できません。
            this.axpObj.msg('@CAU5000');
            return false;
        }
        if (this.axpObj.isSPACE) {
            // [ SPACE ]キーでハンドに変化中です。別のペンは選択できません。
            this.axpObj.msg('@CAU5001');
            return false;
        }
        return true;
    }
    startEvent() {
        // スライダーの並び順序
        this.changeOrderSlider();

        // サブメニュー選択中メッセージ
        document.getElementById('axp_penmode').addEventListener('pointermove', (e) => {
            if (e.target.id === 'axp_penmode') {
                // ペンツールの機能選択中です。
                this.axpObj.msg('@AXP5010');
            }
        });

        // ペンツールのサブウィンドウ
        document.getElementById('axp_penmode').addEventListener('click',
            (e) => {
                // モーダルウィンドウを閉じる
                this.axpObj.isModalOpen = false;
                _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.hide(e.currentTarget);
                // ボタンの暗転を戻す
                let targetElements_button = document.querySelectorAll('#axp_pen_div_rightSide>div>button');
                for (const item of targetElements_button) {
                    item.style.opacity = '1';
                }
            }
        );
        // レンジスライダー：ペンの太さ
        document.getElementById('axp_pen_range_penSize').addEventListener('input',
            (e) => {
                const index = Number(e.target.value);
                const name = this.getName();
                // indexを更新し、sizeを受け取る
                const size = this.setIndex(index);
                document.getElementById('axp_pen_form_penSize').result.value = size; // スライダーの数値表示更新
                // %1の太さ：%2
                this.axpObj.msg('@AXP5000', name, size);
                // ペンの太さプレビュー
                this.previewPenSize();
                // コンフィグオブジェクトをDBに保存
                this.axpObj.configSystem.saveConfig('P-SIZ_' + this.pen_mode, size);
            }
        );
        // レンジスライダー：ペンの不透明度
        document.getElementById('axp_pen_range_alpha').addEventListener('input',
            (e) => {
                let alpha = Number(e.target.value);
                let name = this.getName();
                this.setAlpha(alpha);
                // %1の不透明度：%2
                this.axpObj.msg('@AXP5001', name, alpha);
                // ペンの太さプレビュー
                this.previewPenSize();
                // コンフィグオブジェクトをDBに保存
                this.axpObj.configSystem.saveConfig('P-ALP_' + this.pen_mode, alpha);
            }
        );

        // レンジスライダー：塗り残し補正
        document.getElementById('axp_pen_range_fillThreshold').addEventListener('input',
            (e) => {
                let threshold = Number(e.target.value);
                let name = this.getName();
                this.setThreshold(threshold);
                // %1の塗り残し補正：%2
                this.axpObj.msg('@AXP5002', name, threshold);
                // バケツ専用なのでプレビューは無し

                // コンフィグオブジェクトをDBに保存
                this.axpObj.configSystem.saveConfig('P-THR_' + this.pen_mode, threshold);
            }
        );
        // レンジスライダー：角度
        document.getElementById('axp_pen_range_fillGradationDeg').addEventListener('input',
            (e) => {
                const deg = Number(e.target.value);
                const name = this.getName();
                this.setGradation(deg);
                // %1の角度：%2
                this.axpObj.msg('@AXP5003', name, deg);
                // ペンの太さプレビュー
                this.previewPenSize();
                // コンフィグオブジェクトをDBに保存
                this.axpObj.configSystem.saveConfig('P-DEG_' + this.pen_mode, deg);
            }
        );

        // レンジスライダー：トーン濃度
        document.getElementById('axp_pen_range_toneLevel').addEventListener('input',
            (e) => {
                let tone_level = Number(e.target.value);
                let name = this.getName();
                this.setToneLevel(tone_level);
                // %1のトーン濃度：%2
                this.axpObj.msg('@AXP5004', name, tone_level);
                // ペンの太さプレビュー
                this.previewPenSize();
                // コンフィグオブジェクトをDBに保存
                this.axpObj.configSystem.saveConfig('P-TON_' + this.pen_mode, tone_level);
            }
        );
        // レンジスライダー：ぼかし度
        document.getElementById('axp_pen_range_blur').addEventListener('input',
            (e) => {
                let blur_level = Number(e.target.value);
                this.setBlurLevel(blur_level);
                // %1のぼかし度：%2
                this.axpObj.msg('@AXP5008', this.getName(), blur_level);
                // ペンの太さプレビュー
                this.previewPenSize();
                // コンフィグオブジェクトをDBに保存
                this.axpObj.configSystem.saveConfig('P-BLU_' + this.pen_mode, blur_level);
            }
        );
        // レンジスライダー：丸み
        document.getElementById('axp_pen_form_radius').addEventListener('input',
            (e) => {
                let radius = Number(e.target.value);
                this.setRadius(radius);
                // %1の丸み：%2
                this.axpObj.msg('@AXP5009', this.getName(), radius);
                // ペンの太さプレビュー
                this.previewPenSize();
                // コンフィグオブジェクトをDBに保存
                this.axpObj.configSystem.saveConfig('P-RAD_' + this.pen_mode, radius);
            }
        );

        // キャンバス：ペンの太さプレビュー
        // 原点からの座標に対する角度（0～359）を算出
        const calcDeg = (dy, dx) => {
            let r = Math.atan2(dy, dx);
            if (r < 0) {
                r = r + 2 * Math.PI;
            }
            return Math.round(r * 180 / Math.PI);
        };
        const setPenSizeByPreview = (e) => {
            if (e.type === 'pointerdown') {
                e.target.classList.add('axpc_onGRAB');
                // 初期位置保存
                this.preview_dragstart_x = e.offsetX;
                this.preview_dragstart_y = e.offsetY;
                //console.log(this.preview_dragstart_x, this.preview_dragstart_y);
            }
            if (e.target.classList.contains('axpc_onGRAB')) {

                let target = e.currentTarget;
                let name = this.getName();
                if (this.pen_mode === 'axp_penmode_fillgradation') {
                    // ドラッグ差分
                    let dx = e.offsetX - this.preview_dragstart_x;
                    let dy = e.offsetY - this.preview_dragstart_y;
                    let deg = calcDeg(dy, dx) - 270;
                    if (deg < 0) { deg = deg + 360 }
                    // %1の角度：%2
                    this.axpObj.msg('@AXP5003', name, deg);
                    this.setGradation(deg);
                    // スライダー更新
                    document.getElementById('axp_pen_range_fillGradationDeg').value = deg;
                    document.getElementById('axp_pen_form_fillGradationDeg').result.value = deg;
                    // ペンの太さプレビュー
                    this.previewPenSize();
                    // コンフィグオブジェクトをDBに保存
                    this.axpObj.configSystem.saveConfig('P-DEG_' + this.pen_mode, deg);
                    return;
                }


                var x0 = target.width / 2;
                var y0 = target.height / 2;
                var x1 = e.offsetX;
                var y1 = e.offsetY;
                var distance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
                var basesize = distance * 2;
                // ペンの太さ（最小１、最大200）
                var size = Math.min(200, Math.max(1, parseInt(basesize * 100 / this.axpObj.scale)));


                // size更新とindex取得
                var index = this.setSize(size);
                if (!index) {
                    // %1の太さは変更できません。
                    this.axpObj.msg('@CAU0203', name);
                    return;
                }
                // ペンツール表示更新
                this.changePenMode();
                // %1の太さ：%2
                this.axpObj.msg('@AXP5000', name, size);

            }
        }

        this.CANVAS.pensize.addEventListener('pointerdown', setPenSizeByPreview);
        this.CANVAS.pensize.addEventListener('pointermove', setPenSizeByPreview);
        this.CANVAS.pensize.addEventListener('pointerleave', () => {
            this.axpObj.msg('');
        });

        const setPenSizeByPreview_end = (e) => {
            // ドラッグを終了したとき
            if (e.target.classList.contains('axpc_onGRAB')) {
                e.target.classList.remove('axpc_onGRAB');
                // 太さ変更可能なペン種のみ、変更された太さを保存する
                if (this.getSize()) {
                    // コンフィグオブジェクトをDBに保存
                    this.axpObj.configSystem.saveConfig('P-SIZ_' + this.pen_mode, this.getSize());
                }
            }
        }
        this.CANVAS.pensize.addEventListener('pointerup', setPenSizeByPreview_end);
        this.CANVAS.pensize.addEventListener('pointerleave', setPenSizeByPreview_end);
    }

    start(x, y, e, mode, option) {
        // ペンの太さ変更モード時、クリックされた初期座標を記憶
        if (this.axpObj.codeCHANGE_SIZE_KEY) {
            this.base_index = this.getIndex();
            this.old_x = e.clientX;
            this.old_y = e.clientY;
            //console.log('base_index:', typeof this.base_index, this.base_index);
            //console.log('old_x:', typeof this.old_x, this.old_x);
            //console.log('old_y:', typeof this.old_y, this.old_y);
            return;
        }
        //console.log('exec_mode:', mode);
        // 実行する処理のタイプを記憶
        this.exec_pen_mode = mode;
        this.penObj[this.exec_pen_mode].start(x, y, e, option);
        // 手ぶれ補正用記録
        this.stabilizerX = e.clientX;
        this.stabilizerY = e.clientY;
    }
    move(x, y, e) {
        let name = this.getName();
        // ペンの太さ変更モード時、初期座標との差異からindexを算出し、ペンの太さを変更する
        if (this.axpObj.codeCHANGE_SIZE_KEY) {
            if (this.base_index !== null) {
                let difference_x = e.clientX - this.old_x;
                //console.log('difference_x:', typeof difference_x, difference_x);
                // ※Mac環境の場合、入力値が小数点を含むため、整数化が必要
                let index = Math.trunc(Math.max(1, Math.min(100, Number(this.base_index) + difference_x)));
                //console.log('index:', typeof index, index);
                let size = this.setIndex(index);
                //console.log('size:', typeof size, size);
                // ペンツール表示更新
                this.changePenMode();
                // %1の太さ：%2
                this.axpObj.msg('@AXP5000', name, size);
            }
        }
        // 処理中は処理中のモードを継続、処理を行っていない場合は引数のモードの処理をする
        let exec_mode = this.exec_pen_mode || this.pen_mode;
        // ペンカーソル表示
        if (e.target.id === this.axpObj.CANVAS.main.id || e.target.id === this.axpObj.ELEMENT.view.id) {
            this.penObj[exec_mode].drawCursor(e);
        }
        //console.log('exec_mode:', exec_mode);
        // ペンと消しゴムの場合、手ぶれ補正を判定（描画開始を判定するため、ピンチズームにも影響する）
        if (this.penObj[exec_mode].type === 'draw' ||
            this.penObj[exec_mode].type === 'eraser'
        ) {
            const stabilizer_value = Number(document.getElementById('axp_config_form_stabilizerValue').volume.value);
            if (stabilizer_value !== 0) {
                // 手ぶれ補正あり
                // 前回の位置からの距離によって、入力を間引きする
                // ２点間の距離の算出（三平方の定理）
                const distance = (0,_etc_js__WEBPACK_IMPORTED_MODULE_3__.calcDistance)(
                    this.stabilizerX,
                    this.stabilizerY,
                    e.clientX,
                    e.clientY
                )
                if (distance < stabilizer_value) {
                    //console.log('補正', distance);
                    return;
                }
                this.stabilizerX = e.clientX;
                this.stabilizerY = e.clientY;
            }
        }
        this.penObj[exec_mode].move(x, y, e);

    }
    end(x, y, e) {
        if (this.axpObj.codeCHANGE_SIZE_KEY) {
            if (this.base_index !== null) {
                this.base_index = null;
                if (this.getSize()) {
                    // コンフィグオブジェクトをDBに保存
                    this.axpObj.configSystem.saveConfig('P-SIZ_' + this.pen_mode, this.getSize());
                }
            }
        }
        // 処理実行中でないなら、終了処理を行わない
        if (!this.exec_pen_mode) return;
        this.penObj[this.exec_pen_mode].end(x, y, e);
        // 実行中解除
        this.exec_pen_mode = null;
    }
    getSize() {
        return this.penObj[this.pen_mode].size;
    }
    setSize(size) {
        let index = null;
        // セット可能チェック
        if (this.penObj[this.pen_mode].size !== null) {
            // size更新
            this.penObj[this.pen_mode].size = size;
            // sizeに対応するindex（スライダーの添字）を配列走査で取得
            index = (0,_pendefine_rangeindex_js__WEBPACK_IMPORTED_MODULE_4__.range_index)(size);
            this.penObj[this.pen_mode].index = index;
        } else {
            // 太さを指定できないペンを、ショートカット等で設定しようとした場合はnullを返却
        }
        return index;
    }
    /**
     * キーボードショートカット＋機能割り当て用ペンの太さサイズ変更
     * @param {*} size ペンの太さ
     */
    setPenSize(size) {
        // size更新とindex取得
        let index = this.setSize(size);
        let name = this.getName();
        if (!index) {
            // %1の太さは変更できません。
            this.axpObj.msg('@CAU0203', name);
            return;
        }
        // %1の太さ：%2
        this.axpObj.msg('@AXP5000', name, size);
        // ペンツール表示更新
        this.changePenMode();
        // コンフィグオブジェクトをDBに保存
        this.axpObj.configSystem.saveConfig('P-SIZ_' + this.pen_mode, this.getSize());
    }
    getIndex() {
        return this.penObj[this.pen_mode].index;
    }
    setIndex(index) {
        let size;
        // セット可能チェック(sizeがnullではない事で判定)
        if (this.penObj[this.pen_mode].size !== null) {
            // 更新
            this.penObj[this.pen_mode].index = index;
            // indexに対応するsizeを取得
            size = _pendefine_rangeindex_js__WEBPACK_IMPORTED_MODULE_4__.range_value[index];
            //console.log('range_value_size:', typeof size, size);
            this.penObj[this.pen_mode].size = size;
        } else {
            throw new Error('内部エラー：不正な太さ指定です');
        }
        // sizeを返却
        return size;
    }
    getAlpha() {
        return this.penObj[this.pen_mode].alpha;
    }
    setAlpha(alpha) {
        // セット可能チェック
        if (this.penObj[this.pen_mode].alpha !== null) {
            // 更新
            this.penObj[this.pen_mode].alpha = alpha;
        } else {
            throw new Error('内部エラー：不正な不透明度指定です');
        }
    }
    getThreshold() {
        return this.penObj[this.pen_mode].threshold;
    }
    setThreshold(threshold) {
        // セット可能チェック
        if (this.penObj[this.pen_mode].threshold !== null) {
            // 更新
            this.penObj[this.pen_mode].threshold = threshold;
        } else {
            throw new Error('内部エラー：不正な塗り残し補正指定です');
        }
    }
    getGradation() {
        return this.penObj[this.pen_mode].gradation;
    }
    setGradation(gradation) {
        // セット可能チェック
        if (this.penObj[this.pen_mode].gradation !== null) {
            // 更新
            this.penObj[this.pen_mode].gradation = gradation;
        } else {
            throw new Error('内部エラー：不正な角度指定です');
        }
    }
    getToneLevel() {
        return (this.penObj[this.pen_mode].toneLevel !== undefined) ? this.penObj[this.pen_mode].toneLevel : null;
    }
    setToneLevel(toneLevel) {
        // セット可能チェック
        if (this.penObj[this.pen_mode].toneLevel !== null) {
            // 更新
            this.penObj[this.pen_mode].toneLevel = Number(toneLevel);
        } else {
            throw new Error('内部エラー：不正なトーン濃度指定です');
        }
    }
    getBlurLevel() {
        return (this.penObj[this.pen_mode].blurLevel !== undefined) ? this.penObj[this.pen_mode].blurLevel : null;
    }
    setBlurLevel(blurLevel) {
        // セット可能チェック
        if (this.penObj[this.pen_mode].blurLevel !== null) {
            // 更新
            this.penObj[this.pen_mode].blurLevel = Number(blurLevel);
        } else {
            throw new Error('内部エラー：不正なぼかし度指定です');
        }
    }
    getRadius() {
        return (this.penObj[this.pen_mode].radius !== undefined) ? this.penObj[this.pen_mode].radius : null;
    }
    setRadius(radius) {
        // セット可能チェック
        if (this.penObj[this.pen_mode].radius !== null) {
            // 更新
            this.penObj[this.pen_mode].radius = Number(radius);
            this.penObj[this.pen_mode].borderRadius = Number(radius);
        } else {
            throw new Error('内部エラー：不正な丸み指定です');
        }
    }
    getType() {
        return this.penObj[this.pen_mode].type;
    }
    getName() {
        return this.penObj[this.pen_mode].name;
    }
    resetPenStyle() {
        Object.keys(this.penObj).forEach(
            (key) => {
                console.log('key', key);
                this.penObj[key].init();
            }
        )
    }
    /**
     * 現在選択中のペン種別を返却する
     * @returns {String} ペン種別
     */
    getPenMode() {
        return this.pen_mode;
    }
    // 一時的モード更新（引数未指定の場合、変更無しで、ペンツールの再描画を行う）
    changePenModeTemporary(mode) {
        console.log('changePenModeTemporary:', mode);
        // 既に変更中の場合、重複処理しない
        if (this.isTemporary) {
            return;
        }
        this.isTemporary = true;
        this.temporaryMode = mode;
        this.saveMode = this.getPenMode();
        // 現在選択中の要素を記憶し、選択状態を解除
        const elems_penicon = document.querySelectorAll('#axp_pen_div_rightSide>div>button');
        for (const item of elems_penicon) {
            if (item.dataset.selected === 'true') {
                this.saveElement = item;
                item.dataset.selected = 'false';
            }
        }
        // アイコン変更
        switch (mode) {
            case 'axp_penmode_spuit':
                // マウスポインタ：スポイト
                this.axpObj.ELEMENT.view.style.cursor = 'crosshair';
                // ペンガイド線非表示
                this.axpObj.ELEMENT.cursor.style.visibility = 'hidden';
                // [ CTRL ]: 押している間、ペンがスポイトに変化します。
                this.axpObj.msg('@AXP5005');
                document.getElementById('axp_pen_button_spuitBase').dataset.selected = 'true';
                break;
            case 'axp_penmode_hand': {
                // マウスポインタ：ハンド
                this.axpObj.ELEMENT.view.style.cursor = 'grab';
                // ペンガイド線非表示
                this.axpObj.ELEMENT.cursor.style.visibility = 'hidden';
                // [ SPACE ]: 押している間、ペンがハンドに変化します。
                this.axpObj.msg('@AXP5006');
                // ハンド以外（移動ツール）が選択されているとき、アイコンをハンドに変化
                let elementHand = document.getElementById('axp_pen_button_handBase');
                elementHand.dataset.selected = 'true';
                this.saveIcon = elementHand.dataset.set;
                elementHand.classList.remove(this.getClassIcon(this.saveIcon));
                elementHand.classList.add(this.getClassIcon(mode));
                this.saveMsg = elementHand.dataset.msg;
                elementHand.dataset.msg = document.getElementById(mode).dataset.msg;
                break;
            }
        }
        this.changePenMode(mode);
    }
    restorePenModeTemporary(mode) {
        console.log('restorePenModeTemporary:', mode);
        // 変更中でなければ、処理しない
        if (!this.isTemporary) {
            return;
        }
        //console.log('比較:', this.temporaryMode, mode);
        // 変更中モードと一致した引数指定でなければ、処理しない（複数キーが押された時の競合回避）
        if (this.temporaryMode != mode) {
            console.log('処理しない');
            return;
        }
        this.isTemporary = false;
        // 一時的に選択していたモードの解除
        // アイコン変更
        switch (mode) {
            case 'axp_penmode_spuit':
                document.getElementById('axp_pen_button_spuitBase').dataset.selected = 'false';
                break;
            case 'axp_penmode_hand': {
                // ハンド以外（移動ツール）が選択されていたとき、アイコンを元に戻す
                let elementHand = document.getElementById('axp_pen_button_handBase');
                elementHand.dataset.selected = 'false';
                elementHand.dataset.msg = this.saveMsg;
                elementHand.classList.remove(this.getClassIcon(mode));
                elementHand.classList.add(this.getClassIcon(this.saveIcon));
                break;
            }
        }
        // 復元
        this.saveElement.dataset.selected = 'true';
        this.changePenMode(this.saveMode);
        this.temporaryMode = null;
        this.saveMode = null;
        this.saveElement = null;
        this.saveIcon = null;
        this.saveMsg = null;
        this.axpObj.msg('');
    }
    // モード更新（引数未指定の場合、変更無しで、ペンツールの再描画を行う）
    changePenMode(mode) {
        if (mode) {
            this.pen_mode = mode;
        }
        let type = this.getType();
        // 状態に応じてスライダーの表示／非表示を切り替える
        const displaySlider = (id, value, enabled = true) => {
            if (value === null || enabled === false) {
                _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.hide(id);
            } else {
                _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.show(id);
                // スライダーつまみ位置
                if (id === 'axp_pen_form_penSize') {
                    // 線の太さの時、レンジスケール補正をかけるためindexを参照
                    document.getElementById(id).volume.value = this.getIndex();
                } else {
                    document.getElementById(id).volume.value = value;
                }
                // スライダーの値
                document.getElementById(id).result.value = value;
            }
        }
        // ペンの太さ
        displaySlider(
            'axp_pen_form_penSize',
            this.getSize(),
        )
        // 不透明度
        displaySlider(
            'axp_pen_form_alpha',
            this.getAlpha(),
        )
        // バケツ閾値
        displaySlider(
            'axp_pen_form_fillThreshold',
            this.getThreshold(),
        )
        // バケツ角度
        displaySlider(
            'axp_pen_form_fillGradationDeg',
            this.getGradation(),
        )
        // クレヨンの丸み
        displaySlider(
            'axp_pen_form_radius',
            this.getRadius(),
        )
        // トーン濃度
        displaySlider(
            'axp_pen_form_toneLevel',
            this.getToneLevel(),
            this.axpObj.config('axp_config_form_ToneLevel') === 'on',
        )
        // ぼかし
        displaySlider(
            'axp_pen_form_blur',
            this.getBlurLevel(),
            this.axpObj.config('axp_config_form_blurLevel') === 'on',
        )
        // 手ぶれ
        displaySlider(
            'axp_pen_form_stabilizer',
            document.getElementById('axp_config_form_stabilizerValue').volume.value,
            type === 'draw' && document.getElementById('axp_config_checkbox_stabilize').checked,
        )


        // 描画セレクトボックス
        if (this.penObj[this.pen_mode].usePenStyle) {
            _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.show('axp_pen_select_drawMode');
        } else {
            _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.hide('axp_pen_select_drawMode');
        }
        // 塗り潰し判定セレクトボックス
        if (type === 'fill') {
            _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.show('axp_pen_select_fillMode');
        } else {
            _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.hide('axp_pen_select_fillMode');
        }
        // スポイトRGB表示
        if (type === 'spuit') {
            _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.show('axp_pen_div_spuitColorRGBA');
        } else {
            _etc_js__WEBPACK_IMPORTED_MODULE_3__.UTIL.hide('axp_pen_div_spuitColorRGBA');
        }
        // ペンの太さプレビュー
        if (this.penObj[this.pen_mode].usePenPreview) {
            document.getElementById('axp_pen_div_preview').style.visibility = 'visible';
        } else {
            document.getElementById('axp_pen_div_preview').style.visibility = 'hidden';
        }
        this.previewPenSize();

        // 選択されたペンの名称をウィンドウに表示
        document.getElementById('axp_pen_span_penName').textContent = this.getName();
    }
    previewPenSize() {
        this.penObj[this.pen_mode].previewPenSize();
    }
    spuit(e) {
        // キャンバス外の場合処理しない
        // console.log('spuit:', e.target.id, this.axpObj.CANVAS.main.id);
        if (e.target.id !== this.axpObj.CANVAS.main.id) {
            // スポイトを使用するにはキャンバス内を指定してください。
            this.axpObj.msg('@CAU5002');
            return;
        }
        var clientRect_draw = this.axpObj.CANVAS.main.getBoundingClientRect();
        var x = parseInt((e.clientX - clientRect_draw.left) * 100 / this.axpObj.scale);
        var y = parseInt((e.clientY - clientRect_draw.top) * 100 / this.axpObj.scale);
        // 座標のドットを読み取る
        var imagedata = this.axpObj.CANVAS.main_ctx.getImageData(x, y, 1, 1);
        // RGBAの取得
        var r = imagedata.data[0];
        var g = imagedata.data[1];
        var b = imagedata.data[2];

        // メインカラーに反映
        this.axpObj.colorMakerSystem.selectPalette();
        this.axpObj.colorMakerSystem.setMainColor('#' + (0,_etc_js__WEBPACK_IMPORTED_MODULE_3__.rgb2hex)([r, g, b]));

        // %drawingColorName RGB:(%1)
        this.axpObj.msg('@COL0001', this.axpObj.colorMakerSystem.getMainColorRGB());
    }
    autoChangePen() {
        // 自動ペン切換え有効
        if (this.axpObj.config('axp_config_form_autoChangeSpuitToPen') === 'on') {
            // スポイトが選択されているとき（ctrlの一時的なスポイトではない時）ペンに切り替える
            if (!this.axpObj.isCTRL) {
                this.switchMainButton(document.getElementById('axp_pen_button_penBase'), 'spuit');
            }
        }
    }
    fillAll() {
        // アンドゥ用記録
        const targetId = this.axpObj.layerSystem.getId();
        this.axpObj.undoSystem.setUndo({
            type: 'draw',
            detail: 'fillall',
            layerObj: this.axpObj.layerSystem.layerObj[this.axpObj.layerSystem.getLayerIndex(targetId)],
        });

        // 有色と透明の選択
        let type;
        // 透明色または消しゴムの場合は透明
        if (document.getElementById('axp_makecolor_div_transparent').dataset.selected === 'true' || this.getType() === 'eraser') {
            // 透明色
            type = 'destination-out';
        } else {
            if (this.axpObj.layerSystem.getMasked()) {
                // 透明部分の保護
                type = 'source-atop';
            } else {
                type = 'source-over';
            }
        }
        this.CANVAS.draw_ctx.globalCompositeOperation = type;

        this.CANVAS.draw_ctx.globalAlpha = this.getAlpha() / 100;
        this.CANVAS.draw_ctx.shadowBlur = 0; // ぼかし無効

        let toneLevel = this.getToneLevel();
        console.log(toneLevel);
        let adjustColor = this.axpObj.colorMakerSystem.getAdjustColor();
        if (this.axpObj.config('axp_config_form_ToneLevel') === 'on' &&
            toneLevel !== null &&
            toneLevel !== 16) {
            // トーン濃度使用時トーンパターン生成して色指定
            this.CANVAS.brush_ctx.fillStyle = (0,_etc_js__WEBPACK_IMPORTED_MODULE_3__.createTonePattern)(toneLevel, adjustColor);
        } else {
            // 通常時の色指定
            this.CANVAS.brush_ctx.fillStyle = adjustColor;
        }
        this.CANVAS.brush_ctx.globalAlpha = 1;
        this.CANVAS.brush_ctx.globalCompositeOperation = 'source-over';
        // 全面塗り潰しデータを作成
        this.CANVAS.brush_ctx.clearRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);
        this.CANVAS.brush_ctx.fillRect(0, 0, this.axpObj.x_size, this.axpObj.y_size);

        // 現在のレイヤーの画像に、透明度を指定して合成
        this.CANVAS.draw_ctx.putImageData(this.axpObj.layerSystem.getImage(), 0, 0);
        this.CANVAS.draw_ctx.drawImage(this.CANVAS.brush, 0, 0);

        // レイヤー更新
        this.axpObj.layerSystem.write(
            this.CANVAS.draw_ctx.getImageData(0, 0, this.axpObj.x_size, this.axpObj.y_size)
        );
        this.axpObj.layerSystem.updateCanvas();
    }
    // 90°回転
    rotate90() {
        // アンドゥ用記録
        const targetId = this.axpObj.layerSystem.getId();
        this.axpObj.undoSystem.setUndo({
            type: 'draw',
            detail: 'rotate90',
            layerObj: this.axpObj.layerSystem.layerObj[this.axpObj.layerSystem.getLayerIndex(targetId)],
        });

        // 現在のレイヤーと同じ画像をもつ、新しいイメージを作成
        // （これを行わないと、アンドゥができなくなるため）
        this.CANVAS.draw_ctx.putImageData(this.axpObj.layerSystem.getImage(), 0, 0);
        this.axpObj.layerSystem.write(
            this.CANVAS.draw_ctx.getImageData(0, 0, this.axpObj.x_size, this.axpObj.y_size)
        );

        // キャンバスが正方形
        const rotate_square = (image) => {
            let width = image.width;
            let layer;
            let n = width;
            for (layer = 0; layer < n / 2; ++layer) {
                let first = layer;
                let last = n - 1 - layer;
                for (let i = first; i < last; i++) {

                    let j = last - i + first;

                    let idx_base = (first * width + i) * 4;
                    let idx_swap = (j * width + first) * 4;
                    let idx_last = (last * width + j) * 4;
                    let idx_las2 = (i * width + last) * 4;

                    var tmp0 = 0;
                    var tmp1 = 0;
                    var tmp2 = 0;
                    var tmp3 = 0;

                    tmp0 = image.data[idx_base + 0];
                    tmp1 = image.data[idx_base + 1];
                    tmp2 = image.data[idx_base + 2];
                    tmp3 = image.data[idx_base + 3];

                    image.data[idx_base + 0] = image.data[idx_swap + 0];
                    image.data[idx_base + 1] = image.data[idx_swap + 1];
                    image.data[idx_base + 2] = image.data[idx_swap + 2];
                    image.data[idx_base + 3] = image.data[idx_swap + 3];

                    image.data[idx_swap + 0] = image.data[idx_last + 0];
                    image.data[idx_swap + 1] = image.data[idx_last + 1];
                    image.data[idx_swap + 2] = image.data[idx_last + 2];
                    image.data[idx_swap + 3] = image.data[idx_last + 3];

                    image.data[idx_last + 0] = image.data[idx_las2 + 0];
                    image.data[idx_last + 1] = image.data[idx_las2 + 1];
                    image.data[idx_last + 2] = image.data[idx_las2 + 2];
                    image.data[idx_last + 3] = image.data[idx_las2 + 3];

                    image.data[idx_las2 + 0] = tmp0;
                    image.data[idx_las2 + 1] = tmp1;
                    image.data[idx_las2 + 2] = tmp2;
                    image.data[idx_las2 + 3] = tmp3;
                }
            }
        }
        // キャンバスの縦と横の長さが異なる場合
        const rotate_rectangle = (image) => {

            let width = image.width;
            let height = image.height;
            let shift_width = 0;
            let shift_height = 0;

            // センタリング用の補正値
            if (width > height) {
                shift_height = Math.trunc((width - height) / 2);
            } else {
                shift_width = Math.trunc((height - width) / 2);
            }

            // キャンバスが正方形ではない場合、サイズを拡張して一時的に正方形とみなす
            width = height = Math.max(width, height);

            // 描画内容を書き込む仮想キャンバス
            let canvas_rotate = document.createElement('canvas');
            let ctx_rotate = canvas_rotate.getContext('2d');
            canvas_rotate.width = width;
            canvas_rotate.height = height;
            ctx_rotate.clearRect(0, 0, width, height);
            ctx_rotate.putImageData(image, shift_width, shift_height);

            let tmp_image = ctx_rotate.getImageData(0, 0, width, height);

            let layer;
            let n = width;
            for (layer = 0; layer < n / 2; ++layer) {
                let first = layer;
                let last = n - 1 - layer;
                for (let i = first; i < last; i++) {

                    let j = last - i + first;

                    let idx_base = (first * width + i) * 4;
                    let idx_swap = (j * width + first) * 4;
                    let idx_last = (last * width + j) * 4;
                    let idx_las2 = (i * width + last) * 4;

                    var tmp0 = 0;
                    var tmp1 = 0;
                    var tmp2 = 0;
                    var tmp3 = 0;

                    tmp0 = tmp_image.data[idx_base + 0];
                    tmp1 = tmp_image.data[idx_base + 1];
                    tmp2 = tmp_image.data[idx_base + 2];
                    tmp3 = tmp_image.data[idx_base + 3];

                    tmp_image.data[idx_base + 0] = tmp_image.data[idx_swap + 0];
                    tmp_image.data[idx_base + 1] = tmp_image.data[idx_swap + 1];
                    tmp_image.data[idx_base + 2] = tmp_image.data[idx_swap + 2];
                    tmp_image.data[idx_base + 3] = tmp_image.data[idx_swap + 3];

                    tmp_image.data[idx_swap + 0] = tmp_image.data[idx_last + 0];
                    tmp_image.data[idx_swap + 1] = tmp_image.data[idx_last + 1];
                    tmp_image.data[idx_swap + 2] = tmp_image.data[idx_last + 2];
                    tmp_image.data[idx_swap + 3] = tmp_image.data[idx_last + 3];

                    tmp_image.data[idx_last + 0] = tmp_image.data[idx_las2 + 0];
                    tmp_image.data[idx_last + 1] = tmp_image.data[idx_las2 + 1];
                    tmp_image.data[idx_last + 2] = tmp_image.data[idx_las2 + 2];
                    tmp_image.data[idx_last + 3] = tmp_image.data[idx_las2 + 3];

                    tmp_image.data[idx_las2 + 0] = tmp0;
                    tmp_image.data[idx_las2 + 1] = tmp1;
                    tmp_image.data[idx_las2 + 2] = tmp2;
                    tmp_image.data[idx_las2 + 3] = tmp3;
                }
            }
            // 回転させたデータを書き込む
            ctx_rotate.putImageData(tmp_image, 0, 0);
            // 元のキャンバスサイズの範囲だけ画像を切り抜く
            this.axpObj.layerSystem.write(
                ctx_rotate.getImageData(shift_width, shift_height, image.width, image.height)
            );
        }
        if (this.axpObj.x_size === this.axpObj.y_size) {
            rotate_square(this.axpObj.layerSystem.getImage());
        } else {
            rotate_rectangle(this.axpObj.layerSystem.getImage());
        }
        this.axpObj.layerSystem.updateCanvas();
    }
    modeChangeSizeOn(inkey, code) {
        // 既に他のキーにより「ペンの太さ調整」中の場合は無効
        if (this.axpObj.codeCHANGE_SIZE_KEY) {
            return;
        }
        let name = this.getName();
        if (this.getSize() === null) {
            // %1の太さは変更できません。
            this.axpObj.msg('@CAU0203', name);
            return;
        }
        this.axpObj.codeCHANGE_SIZE_KEY = code;
        // %1押している間、その場でペンの太さレンジスライダーを操作できます。
        this.axpObj.msg('@AXP5007', `[ ${inkey} ]:`);
    }
    modeChangeSizeOff() {
        if (this.axpObj.codeCHANGE_SIZE_KEY) {
            this.axpObj.codeCHANGE_SIZE_KEY = null;
        }
        this.axpObj.msg('');
    }
    changeOrderSlider() {
        if (this.axpObj.config('axp_config_form_pentoolRangeOrder') === 'size') {
            document.getElementById('axp_pen_form_penSize').style.order = '-1';
        } else {
            document.getElementById('axp_pen_form_penSize').style.order = '0';
        }
    }
    upPenSize() {
        let name = this.getName();
        let size = this.getSize();
        // 太さを変更できないペンを変更したとき
        if (size === null) {
            // %1の太さは変更できません。
            this.axpObj.msg('@CAU0203', name);
            return
        } else {
            size = Number(size);
            if (size >= 200) {
                // %1の太さは200が最大値です。
                this.axpObj.msg('@CAU0204', name);
                return;
            }
            // 一つ上の大きさのサイズをサーチ
            var index = this.getIndex();
            while (_pendefine_rangeindex_js__WEBPACK_IMPORTED_MODULE_4__.range_value[index] === size) {
                index++;
            }
            size = _pendefine_rangeindex_js__WEBPACK_IMPORTED_MODULE_4__.range_value[index];
            // ペンサイズ更新（＋ペンツール表示更新、コンフィグ保存）
            this.setPenSize(size);
        }
    }
    downPenSize() {
        let name = this.getName();
        let size = this.getSize();
        // 太さを変更できないペンを変更したとき
        if (size === null) {
            // %1の太さは変更できません。
            this.axpObj.msg('@CAU0203', name);
            return
        } else {
            size = Number(size);
            if (size <= 1) {
                // %1の太さは1が最小値です。
                this.axpObj.msg('@CAU0205', name);
                return;
            }
            // 一つ下の大きさのサイズをサーチ
            var index = this.getIndex();
            while (_pendefine_rangeindex_js__WEBPACK_IMPORTED_MODULE_4__.range_value[index] === size) {
                index--;
            }
            size = _pendefine_rangeindex_js__WEBPACK_IMPORTED_MODULE_4__.range_value[index];
            // ペンサイズ更新（＋ペンツール表示更新、コンフィグ保存）
            this.setPenSize(size);
        }
    }
    changePenAlpha(type) {
        let name = this.getName();
        let alpha = this.getAlpha();
        // 不透明度を変更できないペンを変更したとき
        if (alpha === null) {
            // %1の不透明度は変更できません。
            this.axpObj.msg('@CAU0200', name);
            return;
        } else {
            alpha = Number(alpha);
            // 上キーなら不透明度を上げる、下キーなら下げる
            if (type === 'up') {
                if (alpha >= 100) {
                    // %1の不透明度は100が最大値です。
                    this.axpObj.msg('@CAU0201,', name);
                    return;
                }
                alpha = alpha + 5;
            } else {
                if (alpha <= 5) {
                    // %1の不透明度は5が最小値です。
                    this.axpObj.msg('@CAU0202', name);
                    return;
                }
                alpha = alpha - 5;
            }
            // %1の不透明度：%2
            this.axpObj.msg('@AXP0003', name, alpha);
            this.axpObj.penSystem.setAlpha(alpha);
            // ペンの太さプレビュー
            this.axpObj.penSystem.previewPenSize();
            // 変更をレンジスライダーにも反映
            document.getElementById('axp_pen_form_alpha').result.value = alpha;
            document.getElementById('axp_pen_range_alpha').value = alpha;
            // コンフィグオブジェクトをDBに保存
            this.axpObj.configSystem.saveConfig('P-ALP_' + this.axpObj.penSystem.pen_mode, alpha);
        }
    }
}


/***/ }),

/***/ "./src/js/window_tool.js":
/*!*******************************!*\
  !*** ./src/js/window_tool.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AssistToolSystem: () => (/* binding */ AssistToolSystem)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./window.js */ "./src/js/window.js");
/* harmony import */ var _html_window_tool_txt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../html/window_tool.txt */ "./src/html/window_tool.txt");
/* harmony import */ var _etc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./etc.js */ "./src/js/etc.js");
/* harmony import */ var _reinvented_color_wheel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reinvented-color-wheel.js */ "./src/js/reinvented-color-wheel.js");
// @description ツールウィンドウ：親クラス＞補助ツール




// css適用
__webpack_require__(/*! ../css/window_tool.css */ "./src/css/window_tool.css");

// カラーピッカーライブラリ

__webpack_require__(/*! ../css/reinvented-color-wheel.css */ "./src/css/reinvented-color-wheel.css");

// 補助ツール制御オブジェクト
class AssistToolSystem extends _window_js__WEBPACK_IMPORTED_MODULE_0__.ToolWindow {
    isDragingMap = false;
    isGrid = false;
    isTransparent = false;
    elementProcessingColor = null;
    constructor(axpObj) {
        super(axpObj);
    }
    CANVAS = {
        // 補助ツールのサムネイル表示
        thumbnail: null,
        thumbnail_ctx: null,
    }
    CONST = {
        // 補助ツールのサムネイル表示のサイズ
        X_LOUPE_MAX: 120,
        Y_LOUPE_MAX: 120,
    }
    // 初期ウィンドウ位置
    getDefaultPosition() {
        return {
            left: this.axpObj.paintBodyElement.clientWidth - this.window_width - 10,
            top: 10,
        }
    }
    // 初期化
    init() {
        // HTML
        this.createHTML(
            'axp_tool',
            'AST',
            this.axpObj._('@WINDOW.MISC'),
            'axpc_icon_window_subtool',
            _html_window_tool_txt__WEBPACK_IMPORTED_MODULE_1__,
        );
        this.window_width = 300;
        // 初期座標設定
        const pos = this.getDefaultPosition();
        this.window_left = pos.left;
        this.window_top = pos.top;
        //ルーペツールのサムネ表示用キャンバス
        this.CANVAS.thumbnail = document.getElementById('axp_tool_canvas_minimap');
        this.CANVAS.thumbnail_ctx = this.CANVAS.thumbnail.getContext('2d');

        // カラーピッカー：使用定義
        this.colorWheel_subwindow = new _reinvented_color_wheel_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
            appendTo: document.getElementById('axp_gridconfig_div_colorPicker'),
            rgb: [0, 0, 0],
            wheelDiameter: 166,
            wheelThickness: 20,
            handleDiameter: 16,
            wheelReflectsSaturation: false,
            // handler
            onChange: () => {
                this.changeGridColor();
            },
        });
    }
    resetCanvas() {
        // キャンバスサイズ表示
        document.getElementById('axp_tool_span_canvasSize').textContent =
            `${this.axpObj._('@COMMON.WIDTH')}:${this.axpObj.x_size} ${this.axpObj._('@COMMON.HEIGHT')}:${this.axpObj.y_size}`;

        // 投稿キャンバス サムネイル
        let x = Number(this.axpObj.x_size);
        let y = Number(this.axpObj.y_size);
        let thumbnail_x;
        let thumbnail_y;

        // 縦横どちらかが最大120pxになるように縮小率を計算してキャンバスサイズに反映
        const sc = this.CONST.X_LOUPE_MAX / Math.max(x, y);
        thumbnail_x = Math.round(x * sc);
        thumbnail_y = Math.round(y * sc);
        this.CANVAS.thumbnail.width = thumbnail_x;
        this.CANVAS.thumbnail.height = thumbnail_y;
        this.CANVAS.thumbnail_ctx.clearRect(0, 0, thumbnail_x, thumbnail_y);

        // 表示位置の補正（レイヤーサムネイル用）
        this.axpObj.ctx_map_shift_x = 0;
        this.axpObj.ctx_map_shift_y = 0;
        if (x > y) {
            this.axpObj.ctx_map_shift_y = (x - y) / 2;
        }
        if (x < y) {
            this.axpObj.ctx_map_shift_x = (y - x) / 2;
        }
    }
    // イベント受付開始
    startEvent() {
        // サムネイルをドラッグによるハンド機能
        // 注意：赤線が表示されるとキャンバスがイベントを受け取れなくなるので、外側のDIVでイベントを受け取る
        const thumbnailHandMove = (e) => {
            // サムネイル内の入力座標を取得
            const rectThumbnail = this.CANVAS.thumbnail.getBoundingClientRect();
            const curX = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.adjustInRange)(e.clientX - rectThumbnail.left - 6, 4, this.CONST.X_LOUPE_MAX - 4 - 1);
            const curY = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.adjustInRange)(e.clientY - rectThumbnail.top - 6, 4, this.CONST.Y_LOUPE_MAX - 4 - 1);

            // 可動範囲を算出
            const rectView = this.axpObj.ELEMENT.view.getBoundingClientRect();
            const rectCanvas = this.axpObj.CANVAS.main.getBoundingClientRect();
            const rangeWidth = rectView.width + rectCanvas.width;
            const rangeHeight = rectView.height + rectCanvas.height;

            // 入力座標に対応するカメラ座標を算出 ※画面中央の時[0,0]とする
            const dx = curX * rangeWidth / this.CONST.X_LOUPE_MAX - rangeWidth / 2;
            const dy = curY * rangeHeight / this.CONST.Y_LOUPE_MAX - rangeHeight / 2;
            this.axpObj.cameraX = Math.round(dx * 100 / this.axpObj.scale);
            this.axpObj.cameraY = Math.round(dy * 100 / this.axpObj.scale);

            // キャンバス表示更新
            this.axpObj.refreshCanvas();
        }
        // ドラッグ開始
        document.getElementById('axp_tool_div_minimap_outer').onpointerdown = (e) => {
            this.isDragingMap = true;
            thumbnailHandMove(e);
        }
        // ドラッグ中
        document.getElementById('axp_tool_div_minimap_outer').onpointermove = (e) => {
            if (this.isDragingMap) {
                thumbnailHandMove(e);
            }
        }
        // ドラッグ終了
        document.getElementById('axp_tool_div_minimap_outer').onpointercancel =
            document.getElementById('axp_tool_div_minimap_outer').onpointerleave =
            document.getElementById('axp_tool_div_minimap_outer').onpointerup = () => {
                this.isDragingMap = false;
            }


        // 補助線スライダー
        const inputRangeGridVH = (e) => {
            //console.log(e.target.id, e.target.value);
            const newValue = e.target.value;
            const elementFormGridH = document.getElementById('axp_tool_form_gridH');
            const elementFormGridV = document.getElementById('axp_tool_form_gridV');
            // 縦横連動
            if (document.getElementById('axp_tool_checkbox_gridVHLink').checked) {
                elementFormGridH.volume.value = newValue;
                elementFormGridH.result.value = newValue;
                elementFormGridV.volume.value = newValue;
                elementFormGridV.result.value = newValue;
            }
            this.axpObj.updateGrid();
            this.axpObj.configSystem.saveConfig('RANGE_axp_tool_form_gridH', elementFormGridH.volume.value);
            this.axpObj.configSystem.saveConfig('RANGE_axp_tool_form_gridV', elementFormGridV.volume.value);
        };
        document.getElementById('axp_tool_range_gridH').addEventListener('input', inputRangeGridVH);
        document.getElementById('axp_tool_range_gridV').addEventListener('input', inputRangeGridVH);

        // 縦横連動チェックボックス
        document.getElementById('axp_tool_checkbox_gridVHLink').addEventListener('change', (e) => {
            // チェックした時、横と縦の値を同値にする
            if (e.target.checked) {
                const newValue = document.getElementById('axp_tool_range_gridH').value;
                document.getElementById('axp_tool_form_gridV').volume.value = newValue;
                document.getElementById('axp_tool_form_gridV').result.value = newValue;
                this.axpObj.updateGrid();
                this.axpObj.configSystem.saveConfig('RANGE_axp_tool_form_gridV', newValue);
            }
        });

        // 補助線スライダー（px指定）
        const inputRangeGridPX = (e) => {
            let inputValue = e.target.value;
            // 入力値を範囲内に補正
            let newValue = (0,_etc_js__WEBPACK_IMPORTED_MODULE_2__.adjustInRange)(Number(inputValue), 1, 100);
            e.target.value = newValue;
            this.axpObj.updateGrid();
            this.axpObj.configSystem.saveConfig(`VALUE_${e.target.id}`, newValue);
        };
        document.getElementById('axp_tool_number_gridPixel1').addEventListener('change', inputRangeGridPX);
        document.getElementById('axp_tool_number_gridPixel2').addEventListener('change', inputRangeGridPX);

        // 共通部品トグル式スイッチ
        const elementTogglebuttons = document.querySelectorAll('.axpc_toggle_switch');
        for (const elem of elementTogglebuttons) {
            const input = elem.querySelector('input');
            // 初期設定（配下のチェックボックスのcheckedの値を要素のdata-checkedに転記）
            if (input.checked) {
                elem.dataset.checked = 'true';
            } else {
                elem.dataset.checked = 'false';
            }
            elem.addEventListener('click', () => {

                if (input.checked) {
                    input.checked = false;
                    elem.dataset.checked = 'false';
                } else {
                    input.checked = true;
                    elem.dataset.checked = 'true';
                }
                // コンフィグ保存
                this.axpObj.configSystem.saveConfig(`TOGSW_${elem.id}`, input.checked);
            });
        }
        // 補助線ON/OFF切り替えボタン
        const elementButtons = document.querySelectorAll('.axp_grid_switch');
        for (const elem of elementButtons) {
            elem.addEventListener('click', () => {
                this.axpObj.updateGrid();
            });
        }
        // 補助線サブメニュー表示切替
        document.getElementById('axp_tool_button_gridConfig').addEventListener('click', (e) => {
            // ボタンの属性を更新することで、適用CSSを変更し、ボタンを凹ませる
            let isOpenConfig = (e.target.dataset.selected === 'true');
            e.target.dataset.selected = isOpenConfig ? 'false' : 'true';
            if (isOpenConfig) {
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide('axp_tool_div_gridConfig');
            } else {
                _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show('axp_tool_div_gridConfig');
            }
        });

        // 色選択
        const elementInputColor = document.querySelectorAll('.axp_common_inputcolor');
        for (const elem of elementInputColor) {
            elem.addEventListener('click', (e) => {
                console.log('open:', e.target.id, e.pageX, e.pageY);
                // 押されたボタン要素を記憶
                this.elementProcessingColor = e.target;

                // カラーピッカーと不透明度スライダーを押されたボタンの色に更新
                let colorcode = this.elementProcessingColor.dataset.colorcode;
                let hex = colorcode.substring(0, 7);
                let alpha = Math.round(100 * parseInt(colorcode.substring(7, 9), 16) / 255);
                const elementRange = document.getElementById('axp_gridconfig_form_gridColor');
                elementRange.volume.value = alpha;
                elementRange.result.value = alpha;
                this.colorWheel_subwindow.hex = hex;
                // サブウィンドウオープン
                this.axpObj.openSubwindow('axp_gridconfig', e.target);
            });
        }

        // 不透明度
        document.getElementById('axp_gridconfig_range_gridColor').addEventListener('input', () => {
            this.changeGridColor();
        });

        document.getElementById('axp_gridconfig').addEventListener('click', () => {
            // 操作中ボタン要素をリセット
            this.elementProcessingColor = null;
            this.axpObj.closeSubwindow('axp_gridconfig');
        });
        document.querySelector('#axp_gridconfig>div').addEventListener('click', (e) => {
            // サブウィンドウ内クリックでウィンドウが閉じないように、親へのイベント伝播を中止
            e.stopPropagation();
        });
        document.getElementById('axp_gridconfig_button_confirm').addEventListener('click', () => {
            // 操作中ボタン要素をリセット
            this.elementProcessingColor = null;
            this.axpObj.closeSubwindow('axp_gridconfig');
        });

    }
    changeGridColor() {
        // カラーピッカーと不透明度スライダーからカラーコード（アルファ含む）を生成
        let hex = this.colorWheel_subwindow.hex;
        let alpha = Math.trunc(255 * document.getElementById('axp_gridconfig_range_gridColor').value / 100);
        let colorcode = `${hex}${alpha.toString(16)}`;
        // 操作中のボタン要素の色を変更（※重要：アルファを含まない色を背景色に指定する）
        this.elementProcessingColor.style.backgroundColor = hex;
        // カラーコードをdatasetに保存（※重要：アルファを含む色を保存する）
        this.elementProcessingColor.dataset.colorcode = colorcode;
        // 補助線表示一活更新
        this.axpObj.updateGrid();
        // コンフィグ保存
        this.axpObj.configSystem.saveConfig(`GRIDC_${this.elementProcessingColor.id}`, colorcode);
    }

    // 左右反転
    flip_h() {
        // 全体
        this.axpObj.layerSystem.flip_h('all');
        // 全レイヤーの左右を反転しました。
        this.axpObj.msg('@INF1000');
        // アンドゥ用記録
        this.axpObj.undoSystem.setUndo({
            type: 'flip_h',
            id: 'all',
        });
    }
    // 上下反転
    flip_v() {
        // 全体
        this.axpObj.layerSystem.flip_v('all');
        // 全レイヤーの上下を反転しました。
        this.axpObj.msg('@INF1002');
        // アンドゥ用記録
        this.axpObj.undoSystem.setUndo({
            type: 'flip_v',
            id: 'all',
        });
    }
    grid() {
        this.isGrid = !this.isGrid;
        // ボタンの属性を更新することで、適用CSSを変更し、ボタンを凹ませる
        document.getElementById('axp_tool_button_grid').dataset.selected = this.isGrid ? 'true' : 'false';
        if (this.isGrid) {
            // 表示
            _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show('axp_canvas_div_grid');
            // キャンバス表示更新
            this.axpObj.refreshCanvas();
        } else {
            // 非表示
            _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide('axp_canvas_div_grid');
        }
        var msgtext = this.isGrid ? "表示" : "非表示";
        // 補助線の表示を切り替えました。（現在の状態:%1）
        this.axpObj.msg('@INF1004', msgtext);
    }
    transparent() {
        this.isTransparent = !this.isTransparent;
        document.getElementById('axp_tool_button_transparent').dataset.selected = this.isTransparent ? 'true' : 'false';
        this.axpObj.layerSystem.draw();
        var msgtext = this.isTransparent ? "透過" : "白地";
        // 背景を切り替えました。（現在の状態:%1）
        this.axpObj.msg('@INF1005', msgtext);
        this.axpObj.layerSystem.updateCanvas();

        // 投稿フォーム連動
        let input_transparent = document.querySelectorAll("input[name=axp_post_radio_bg]");
        for (let element of input_transparent) {
            if (element.value === 'transparent') {
                element.checked = this.isTransparent;
            } else {
                element.checked = !this.isTransparent;
            }
        }
    }
    getIsTransparent() {
        return this.isTransparent;
    }
    setIsTransparent(flag) {
        this.isTransparent = flag;
        // 補助ツールのボタン
        document.getElementById('axp_tool_button_transparent').dataset.selected = this.isTransparent ? 'true' : 'false';
        // 投稿画面のラジオボタン
        if (flag) {
            document.getElementById('axp_post_radio_bgTransparent').checked = true;
        } else {
            document.getElementById('axp_post_radio_bgWhite').checked = true;
        }
    }
    // サムネイル：キャンバス表示範囲線
    mapguide() {
        var b_rect = this.axpObj.ELEMENT.view.getBoundingClientRect();
        var c_rect = this.axpObj.CANVAS.main.getBoundingClientRect();

        var sub_w = 0;
        var sub_h = 0;

        var sub_top = 0;
        var sub_left = 0;

        var overflow = false;
        var isDisplay = false;

        if (c_rect.top < 0) {
            //console.log('上はみ出し');
            const dy = Math.abs(c_rect.top);
            const dy_sc = (1 - ((c_rect.height - dy) / c_rect.height)) * 120;
            sub_top = dy_sc;
            sub_h = sub_h + parseInt(dy_sc);
            overflow = true;
        }

        var v_down = c_rect.top + c_rect.height;
        if (b_rect.height < v_down) {
            //console.log('下はみ出し');
            const dy = v_down - b_rect.height;
            const dy_sc = (1 - ((c_rect.height - dy) / c_rect.height)) * 120;
            sub_h = sub_h + parseInt(dy_sc);
            overflow = true;
        }

        if (c_rect.left < 0) {
            //console.log('左はみ出し');
            const dx = Math.abs(c_rect.left);
            const dx_sc = (1 - ((c_rect.width - dx) / c_rect.width)) * 120;
            sub_left = dx_sc;
            sub_w = sub_w + parseInt(dx_sc);
            overflow = true;
        }

        var v_left = c_rect.left + c_rect.width;
        if (b_rect.width < v_left) {
            //console.log('右はみ出し');
            const dx = v_left - b_rect.width;
            const dx_sc = (1 - ((c_rect.width - dx) / c_rect.width)) * 120;
            sub_w = sub_w + parseInt(dx_sc);
            overflow = true;
        }

        if (overflow) {
            // キャンバスが表示領域からはみ出した時に表示
            isDisplay = true;

            // ただし、キャンバス全体が完全に表示範囲からはみ出している場合は非表示
            if (sub_left > 120 || sub_top > 120) {
                isDisplay = false;
            }
            if (120 - sub_w < 1 || 120 - sub_h < 1) {
                isDisplay = false;
            }
        }

        const elementRedLine = document.getElementById('axp_tool_div_minimap_line');
        if (isDisplay) {
            _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.show(elementRedLine);
            elementRedLine.style.left = -1 + sub_left + "px";
            elementRedLine.style.top = -1 + sub_top + "px";
            elementRedLine.style.width = 1 + 120 - sub_w + "px";
            elementRedLine.style.height = 1 + 120 - sub_h + "px";
        } else {
            _etc_js__WEBPACK_IMPORTED_MODULE_2__.UTIL.hide(elementRedLine);
        }
    }
}






/***/ }),

/***/ "./resource/brush.png":
/*!****************************!*\
  !*** ./resource/brush.png ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAC5klEQVRYhe2VX0hTURzHP/dqsUFQlnOOoezB2Epd6INEaIwIJInECdZL0ZtPRS+LVPAPQoOigh4shF70yQeJQSVh+VIKFUgxF467ic9ZSGEw2HZPD+dO17gbzBw+tC8cuOec3/39vuf3F8oo439HRc5eBS4DOrCxHwSOANNAArABt4C3QCpHTgUuASHADcyVgpwf+AxUGYZCWXfTgF5fX58EfgOeUhDIxkXgjvF9GEj19vbqq6uroqmpSQAvgSAwUKxi1eTMYZxXA9eAk8ABwAVYgdOAMj8/r0SjUZxOpwAuADeN+0bgOnC0WDIAx5AJ2A2cA+LIl/uBp4AFUJBx/2XI/gACQBtwH9gyzh/uhgBArWEkG43AA+CgsZ8D0sBjwAl0ARtWqzUxMjIixsbGBDJxz+yWRAYqMiQDwAIyFACDhnILcA9I+3w+fXFxUY/H42JlZUW4XC4BvPhXAn7kS6qAq0BP1t0p4IvFYtFHR0d1TdNEPB7fXpOTkxkvdBVr1IaM9wmkB2qN8xA7WX4eEK2trfrS0pKebTizNE0THo9HID2XG9JtmFVBM3DW+EkHfiIzuhtZahmSDA8PK3a73VS5qqqMj4+jKIqPAl4wI7CALL2vxv4R8CZHJgR8m5iYQAiRTzctLS10dnaCzBOrmUxuKzbDGvCcv2dDEoiura1d6ejowOFwmHpBURTq6uqUmZmZauA78KEYAj3IPHiH+WDSgLbl5eXjfX19VFZWmpKoqakhHA4r6+vrXuAJOXOlEAE/shu+LyDzcXNz80YymaS9vT2vF9xuN7Ozs4dSqdQBcsJplgMZ3GUn6fIhBgxOTU0RDodNBYQQJBIJVFVVkBN0z1EBvGpoaBCRSGS7DGOxmIhEIqK/v19YLBYdGf/mUhAA2aq3AoGAiMViQtM0PRgMCpvNpiNnw20Ke3tPMAiIoaGhtNfrTSN7yGvAXmrDGVQAzwzDn5BVlLcDlgrqfhkuo4xd4w+Gc/4wRA2pHgAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./resource/caution.png":
/*!******************************!*\
  !*** ./resource/caution.png ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAqElEQVRIibVVWRaAIAhEX6fp/mfpOvRlobKJMp8as0BRAT9QOC9akXppELt4rhVyfAbWe0OZko/EggjLVS0HGrlkqDOgPUzJuXa0ey2FmWARUwpOwOW+K1DaeDqBKTC5D6Br05QgSi7VUQHPF7uM8AyMpJ/ZSg82e8/WZ75FmCIwpqhwqD0SrHUNm+LoEhhXhSWIz18TmoHnR9OQvouyZwAFklZEQ3qLXjz+NU6cSgzSAAAAAElFTkSuQmCC";

/***/ }),

/***/ "./resource/clip.png":
/*!***************************!*\
  !*** ./resource/clip.png ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAoCAYAAADDo7u9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAZUlEQVQ4je1RWwqAMAxLZVfI/Q+YQ8wPKXSwOsQqCOarj0DSBvjxEiw2knrsSVq69Nm2kiggZNqFErcJzQuS5ubiB1tkD68t8wAgDwoIcZ9G/SxsZnAgAPMrgMPotSsk9ZXkN7EDuUc2YkzwIXMAAAAASUVORK5CYII=";

/***/ }),

/***/ "./resource/clip_invalid.png":
/*!***********************************!*\
  !*** ./resource/clip_invalid.png ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAoCAYAAADDo7u9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAg0lEQVQ4jdWRQQ6AMAgEB+NTeRZ/xYOpgSitxnqQU8su7AIwCgfvYUtFSjkHj4n4l0pKAlZ2ut+h6yGYSZpHwWgPFXY2CWBmqUJVpQRbbhlJTCBU2hMlXhPW9lBVaebiBtfITqud5gGoDwXh3N1TfxtyZTAR4HoK2I0+m8LMfCT5z9gA7PxXykWr3MUAAAAASUVORK5CYII=";

/***/ }),

/***/ "./resource/config.png":
/*!*****************************!*\
  !*** ./resource/config.png ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAHFJREFUOE+tU0cOACAIs/9/NAYTTDUMjXpitTLR6ImIsA4Aqkd29Y0AexrIoEpOCfhnIzIb6+D02MGZ7fKC4bQzkOcb2Igga9zSMwvM6vRqn7hqApV/jjEaYUnwXMKXJp7O39uH90WKbuF4lb8f0+05d/uyv/FrQqysAAAAAElFTkSuQmCC";

/***/ }),

/***/ "./resource/crayon.png":
/*!*****************************!*\
  !*** ./resource/crayon.png ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAEKUlEQVRYhe2WXUikZRTHf+84ujrN6Gg4ss0kS22aQazlRZJ13UUYiF+IgaViF0nF3qngjd6EXSRC0VWEOkRJCH57oY4wUhHLQGxu69iG2dbU+JFfO7Y7c7p4ntlmZkdnDISC/vAw7/ue5z3nf/7nOecd+B//cWQAfcD1nJycW9nZ2beAL4G3tO3c8Z7ZbJaBgQGZn5+X1dVVmZ2dlaqqqggwct4kngckdhUXF0t3d7f4fD4pLCyMAG+fV/BC4LvKykqZm5sTj8cjIyMj0tHRIRaLRcrLy6WsrOwe8Ol5BDcBszabTbxer/j9fllfX7+/xsfHxWazCRABOlM5+yc1egd4c3h4mJKSEgzDiDM6HA6CwaD4fL5D4HUglCqbs+Ai0FtbW0tFRQUigojEbRARWVhYAPgI2E3l0HyG4CbgY4fDYe/q6nog8ygWFxfZ2NiIAJ+k6zRdvAq81NnZyeHhIYFA4AEFRITR0dEIMAt8ewbfKVEAbJLQdna7XRoaGsTtdovf75fJyUkxDCMCvJyu43RKYAI+KCoqemR6epq8vDwAgsEgy8vLuN1umpubaWxsZGdnBxH5Bpg6a4anoQUQq9UacTqd4nQ6xeVySX19vUxMTMja2pr09/dHVYmgSpWIF4HngBeAZ2MN6ShwNT8/n7a2NsPhcACwtbXF1NQU1dXV9PX10dTUhNfrZWZmZhP4PImPy4AdOES1/rV0CdiByz09PdTU1MQZ2tvbGRwcpLe3l6OjI5aWlgR4FzhO4qcUuAs8DARiDcl76W9cAn7weDzicrniOibaAa2traysrEg4HN4EnkhCwAR8iEo2C9gAemKNp2EXOBoaGiIcDscZDMPAZDLR0tIi2jaSJDhADvAHSv4Q8FMiu1QEro6NjRl1dXXi8/mOQ6HQ/exDoRCBQCA6CIZP8FGsf0X724lLJAWBKF4B3gcu5eXlGVarFYC9vT329/dFB39NB0lEKfAGqkP+BD4DfOkQMAGZQFi/LKgaVya8dwP46gQfuUAHkA9YgCPUN2IjuiFZF5iBJ4HHgQP90g2UdDf1SgcZQBlqiubqBNaB7cRgiXgUeBp4DPgV1TbplioKE/AMaujY9X1Akz9IReAp1MSyAuXAF8CdMwS3oD7bV1BtHFXxGvB94uZkBDJRkrlQ9c/VZE4jkY2SvEgHvYJS0Ar8COwDvwDBdAiYUL27rR1W6PvfUW20CzyEqmkB6oBaNfF8vXZi1m1gEfAnY56MQFBvztJOD1CHsgi4h1LFoq+3Ua2FJmUCftbXv6Gk/1o/S4pk/wm3UBPNrAlk6EAXdPBMlOR39PMClMSgpp2hA98EvKj/EckmJHDy6b6AqmUpKvss/ewiqgQ5OugxSqEDTfw2qtZ7+j5yUuBUBGJh1gGtmoQZJbWgzkUYNePvpuHr34e/AD3wjysuWELmAAAAAElFTkSuQmCC";

/***/ }),

/***/ "./resource/dot.png":
/*!**************************!*\
  !*** ./resource/dot.png ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAABFklEQVRYhe1WSRLDMAgTnT4iD8j/f+R7XlF6ouMkGLN4podWp8TCDhKYFvh10MKzeLD2sDaZpBfbtqX3rnCAAaC1dieYse+7xKhiSw6MlDMzmLWK3FFxwKMcrTXTiZQDK5QLnonv83EcqnIAJ+UehBxYqVwQcWCp8kwC94wmqjt+GFhKAJgrFx6VOdDXXuptqe94hqEe8M2Bz33v77cgOwEF5RJcPyyP3j2hBIho6IRgVvN0AqKOiNR1efWeJ3D3gKCvueKEVXPW+HAPFBSrsWEHFC76g3ZywuNAbsg74Ulgyd+2rxw+wMlRrQfUbvUe2K1d97tvQbTm3vhwLzGAV5HnWZzVhLOMqzyA/BzI3H8VX58Df7wBWFyk7NpwigYAAAAASUVORK5CYII=";

/***/ }),

/***/ "./resource/eraser.png":
/*!*****************************!*\
  !*** ./resource/eraser.png ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAC0UlEQVRYhe2VwUuTYRzHP48WeBm4am05OujFgzKcJdhfoMIQlIhBhBAqKl7Kswdlg0D/gg4hgoNgSlBQbBQd9JBph+FIXt/3GHUorLE3Yr2+vw6bus2tNpt12Reew/Pj+fH5Pr/n9zwP1FVX7dQA9AEX/wf8CvACsIH3QM+/hN8B9oGDnAE7N79+1uBG4GEOfAgXh8MhnZ2dkjMROCv4BeBxPhgQl8slq6urommaDA0NCfADuFtruAt4x3G5BRCfzydbW1tiGIYYhiGapsno6KgNpIFrtYJ7gY9kdy65YQ8MDNj58HwTHR0dAnwpZ6KhCrgfeANczg/6fD4WFxeV0+ksWCwixGIxkskkZI8sTonGrNRAL/ASaMnlNAAMDg4SjUZVU1PTCXgkEmF6ehqyVQJwAvcr5BXID6Q4LrkopWRsbEw0TTtRdl3XZWpqSvLX54YNPKgW3gN8LoaHQqETYMMwZG9vT2ZnZ8vBnwPnq4G7gX23213Q7QsLCyXhmqZJMBgsB09wiic65HK5fu7s7Mj4+PgBYAcCAVvXddF1vQC+ubkpfr+/GHo4EmSvbtVKTk5OHp3r/Py8rZSyJyYmCgxsb29Lb29v8a4PH6i3ZG9A1fIAB0tLS3Z+c4XDYVspJcPDw6JpmmxsbNhtbW0Wpcv+Grj0J9C5MvEmoKG1tfUooJQiGAyq5uZmZmZmxDRNtb6+rkzTbCzKFeAJEAQypzUAIJlMBkDlB/v7+/F4PIyMjIhpmqo4B3gK3AKsP8Gh/EP0CdhfWVkpBgDQ1dWllpeXlcPhKIZHgZuVwiH7pZaSBbh2d3dveL1e2tvblVKFXtxuN93d3bK2tnYYigC3yTZgxSpnAOCVZVktsVjMn0gkME0T27aVZVmkUimJx+MyNzen0un0dyAM3CPbfDVXH/AM+EDh/U4Djyj6nKpVyTP+zdqreTlfgW9/A6+rrroAfgHtW6W7+RvhCQAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./resource/eraser_dot.png":
/*!*********************************!*\
  !*** ./resource/eraser_dot.png ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAChElEQVRYhe2VT0gUURzHP08rBnQPW21rdQi8KgtLCXv0tgiLoCcvgYaKiqeuYgdZIdA9eunQKRYKdyEICiPo4iHTDuISPN8co0siRIegfL8OO5Oz4245tirEfuDxZoY3fL7ze38GWrRoHm1AFrhyHvLrwCvAAh+BvrOU3wX2gQMvgPXu75y2uB145Il9ucRiMent7RUvRO605JeBp0ExIIlEQkqlkmitZWhoSIDvwL1myxPABw7LLYCkUinZ3NwU13XFdV3RWsv4+LgFvgG3myW/CXym+uXiNTswMGCD8mCInp4eAfYahWiLIE8D74BrwYepVIrl5WUVj8drBosIa2trVCoVqE7Za+oszOMGyABvgBveO20Ag4ODrK6uKsdxjsiLxSKzs7NQrRJAHLh/TF8NaeArhyUXpZRMTEyI1vpI2Y0xMjMzI8HxXrPAw6jyPuBLWJ7P54+IXdeV3d1dmZ+fbyR/CVyMIk8C+8lksma1Ly0t1ZVrrWVkZKSRfJsTHNH5RCLxY2dnRyYnJw8Am8vlrDFGjDE18o2NDUmn02Gp37apbt3jMzc3J0BlenpaRESMMbKwsGCVUnZqaqomwNbWlmQymfBX+wfUe6o7ILJcwhhjZHFx0SqlZHh4WLTWsr6+bru7u39Sv+xvgauR5B51A4iIuK4rKysr4jiOzWaz0tHR0WjOy8Clk8iDIWyjEKVSyXZ2dv5emCH5c+DCv8h99kZHRxtWolwuSywWC8ufEXGr/RHHcWyhUKhbCWOMFItFq5TyV/sToh3tf6Xd6w/6+/vrhujq6vL/dg+aLQ/zAvgUlHvix4R+TqeJP9e3Atdny9jYmADi9edDoVA4P3mL/5JfpBcZsB/cpIwAAAAASUVORK5CYII=";

/***/ }),

/***/ "./resource/eye_off.png":
/*!******************************!*\
  !*** ./resource/eye_off.png ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA30lEQVQ4je3SvUpDQRAF4E+9VZArWFlIEAtJaSoVtLfPO/gAwUb7dCEvEF8jCGlCCrHWKqAS8acQjCIIKsFgcXchxYLaitMszJlzZs/M8B9/IOawjit84PQX3AOswgqucY/8h+QyRujGRBtDdLDwDTlHH+/Ynla8wE14a5hPkHdxiWc0YWYK3MFRyOUY4xx3yLCpsPsW6g4xyQK5hCpeMMAaHrCBLXziFWfoha8v4jF276AVrFBspoEn3KIehGLDPcXclqJAJeF3GSc4TmCz2Ec7Kg4SRZniNoYJbCIM8Qt3ny0eu9pmggAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./resource/eye_on.png":
/*!*****************************!*\
  !*** ./resource/eye_on.png ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABZ0lEQVQ4jZ3SPUjVYRQG8F9eBREXUcwuQhANrnEpidp0uzRcRKdqcGgKaYjGpsZwSQQnaWhoaLRNNykoxI9IJQcHBRHt3pQatA+H9/z19scSfOCF9z3vOc9zvgr+jzt4iRr+YOdfjk/RkLN14DOunCFCOLbkbH2YOCOuMVOdQSX/ie+nBDXjMeYwnxmv4hPKdY7FcCoHWYbnGEUXXKj76JV68RUraEc/LsV7Gsu4H9keZGnW4xA30IZJzKIb1zGEAtbQGkLHeBAKb1BCJ17hG3bxAbcxiI9BfCsLHojAh04m8TpSrKGKjSAUtY9Hf0qC8VGulBf4hR/SJDbxLmscLmIKUw3SWJZzBO8jg6aouxb3vfjfxxIuF+LxDNvSQsFqqG5jIdSeBEEPxkKgmilWpD0Yw02py3kUMYLFELqHlvo96MIw7uK3NIGfcdrC1oy3UhPX+XuRMnRIc78Wd5H6F2nUW6fEnB9Hz9lVhydI1Z8AAAAASUVORK5CYII=";

/***/ }),

/***/ "./resource/fill.png":
/*!***************************!*\
  !*** ./resource/fill.png ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAEGUlEQVRYheWXz09jVRTHP6/8aLE0iFpt1LSQEAnhhzGxuEAoaS3q4Ewyq9GVrkB2A6EBDQQ3uGH+ABEJSTH+WAiRhJiaEH4YqIOMwcEKQ9tJZNBEQpQEdILQd1y8PiydQkuZWRi/yUtf3r33fL/3nHPPuYX/O3KyXFcAPA2YgL37JydzjAECHAIfAYZsDSkJ71bgApAbN/wXcB24EydLxC3gmfi7AG8B/mxF6PgmbizxUYEwcDlJ7IdJ89aTxrPCrRQCEoV8D7wSn2sFbiSN288r4M24oZNECBAD3o7PfxT4PEGA47wCCoCv0wjQE08XkYOWhD8BDyfYegq4dBZyA1rCpXJ9LMX33+OCk21cBr4C/oyvq85UwOspSHQB+hMDbgOfAB+g1QCd+CUgCEhFRYX09vZKZWWlAF+kI86N/yZnsBr/pqJ5ZgL4FNhImlcBXFMU5UJtbS0tLS00NDRgMBgQEUKh0MvA48BWOgFfosWxIk76MzAOfAwsp1hnA3xAa2VlpamjowOXy4WiaPtQVRW73U5eXp754ODgKvBuOk+AFlMH8MQpc3KA94G90tJSta2tLba2tvZ3JBKRaDQq4XBYhoaGpLq6OjGMYc5RKXUoQCPwncVikb6+PpmfnxdAqqqqpKurSwYHB8Xlcp2UR8+fh9wGfAaIy+WSQCAg0WhUIpGI+P1+cbvdKY+rxWKR3t5esdvtAlw7yfhprjGgxe62zWa7Mjo6yvDwMGVlZYgI29vbTE9PEwwGjy0ymUwoioKiKGxubuJ0OkErcqZ7KU5HGSAej0eWlpaOdh0KhcTn84nRaDy2Y0VRpKmpSRYWFmRubk5aW1vF4XAkhsEPvMAZesZDwGJxcbEEg0EJh8Oq3+8Xm812j7tdLpdMTk5KJBIRPSF1wWNjY1JSUpJYT+4A7+gk6dQ8Asw7nc7yvb09WV1dPRaympoa2tvbaWhoONXI1NSUtLS0CHAFeA5YQjvmGbmjCq1VH9V6q9VKf38/brf76OyfBBFhf3+furo6dnZ2fCQlZCbn80e0NnwXEJ/PJ7Ozs3g8nrTkAIqiYDQa8Xq9oPWKY8i0QFwHrgJiNpsP8/PzM1z2r4jm5mbQkvDZxLGzXEpvAFszMzOvFRUVUVNTo2TiAR1Wq5WRkRHD4eHht8AP2QgALXm25ubmXt3d3TXU19dnFIZYLEZPTw8rKysq8B7wW7YCdBG/LC8vX9zY2FAaGxvJzc1NOVFEWF9fp7OzUwKBwF3gDWAmC86UeBH4o7y8XF1cXFT1s59QA9SBgQHVbDarwK+csx+chCeBmw6H43B8fFzVi8/ExIR4vV79EhMAHnsQ5DqswM3CwsJYd3e3eDweURRF3/VF7sN1PRMUoF1eVGAN7Y9K8p3xgcOA1rr/W/gHfXHTs2UHg10AAAAASUVORK5CYII=";

/***/ }),

/***/ "./resource/fillgradation.png":
/*!************************************!*\
  !*** ./resource/fillgradation.png ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAGG0lEQVRYhe2WXUxTZxzGn3N6zqFd+fCDshWYEai1hkGos8IEpRNOhVANEk1nnINkxBHEaNVAGk28KNBYkSaGeGFUnEYuLAyiGKdMlDQ6MWjVxCBmHXWY4VjrTLU0ODnvLgxdBQS/5tV+ybn6v//nec7/fc8H8D9vSElJiSUuLu5CbGzsraampg0f1DwnJ0cBgKSnp5PExEQCgGzcuPHaBwtQVVUVDYAkJCSQ7du3k5qaGgKAlJeXb3knYafT+ZFWq92+aNGihqSkpDaNRnM1Jydnj81mW2a1WunQtTabLWn16tWPOI4bjY+PJ/n5+UQsFo/s3r2be+sAer3+EE3TZMGCBUSj0RClUknkcjlhGIZIJBJ/WVnZaYvFEhPaU15ezlVXV+9TKBTPAJCoqKhFb+NNAUBycvIxQsiG1NRUUBQFkUgEjuPAcRy8Xi+6urrw+PFjlJaW6g4cONAxXsRgMKxIS0vrMZlM3jcNIAKAbdu2Rdnt9kKe5zFv3jzI5XLIZDLMmjUL8fHxyMzMBMuyaG9v31BRUXHxypUr90NF7ty547pw4UIAAMxm8zeDg4OXjEbjqc7OTs9rTQAA1Gr1bafTmaLT6aDT6YKTYBgGDMNALBbj7NmzaG9vF/Lz85nm5mYSKmQ0Gj/r6ek55HA40qVSKUQiUYfP59O9VgCn0zmb53mPQqHAunXroFKpwDAMaPrF+RMEAfX19XA4HPD7/VCr1bE9PT2DYyKFhYWX2trasmUyGXJzcyEIAux2OxEEgX6FbxCR0+kMMxgMg9nZ2VxVVRViYmIgEolAUS+Gs2/fPlRXVwPAzyqV6uuCgoIdra2tf1ZWVjJisdjo9/uv9Pb2ztXr9VAqlS/uiqIwMDBAFRQUJPT29rZNOQGtVpty7dq12zdu3AiaPn36FCaTCefPnwfP8z6r1fq5Wq3+ZazJbDZ/3NjY+NDtdmP58uWQyWQThJ8/f46WlhYIgkBNKIZAx8bGegOBACwWCy5evIg1a9YgMzMTd+/e/bGiouKLjo6OqDHz+vp6+Zw5cw7X1tY+lEqlMBgMk5r39/fDbrdDEATk5eVpp5wAALS2tm4qLS0t8nq9f2VnZ//W1dW1bfxCm832rclkOhQZGYnFixcjIiIieKejo6MICwvDzZs3ce/ePYyOjgb7oqOjWz0eT9GUAabi5MmTy0wm0/cul2tuVlYWFAoFKIoCwzDo6OiA2+2esp/juKfPnj2LeKsARUVFvtOnT0csWbIEPM+D47jgkwEAfX19OHHiBIaHhycXpygQQpCXlzcSHR1dm5yc3GAymR69VoCVK1c2nDlzZtOePXuCh3OM4eFh1NXVwefzTdqrVqvB8zwiIyPh9/thsViQlJQEl8uFmJiYP4aGhj4ZW8u8KkBYWJhNoVBsam5uxtq1awEAgUAAjY2N6O/vByFkQk9ERATMZjMkEgkIIWBZFizLYsaMGXC5XDyAn2bOnJkwNDQ0/QQA4OjRo3ElJSUDmzdvpu7fv49Tp05Nuk6pVGLr1q2YP3/+S1s0RkNDA9xu94Pr169/Or427SGsrKwsOHjwYLvP54MgCBPqhw8fRmJi4pQafr8fer0eGRkZcVevXv09tDbtq9JqtZ4pLi7WhZqHh4fDaDTi3Llz05oDgFQqRUpKCrq7u9PH10TTdgPo7u7+defOnX87HI4cpVKJpqYmqFQqiET/ttM0Hfx4cRwHsVgMiUQCqVSK8PBwyOVyXL58OTcQCFhDtafdglB27Njxg81mW33s2DGkpKSApungNf5JGY/f78fChQsneE67BaHU1dUVrVixonb9+vVwu91gWfalD9erYFkWXu+LfxWNRlPzJp6TYrVav6Mo6vn+/ftJX1/fS5fL5SIPHjwgHo+HPHnyhBBCSEtLCwFAVq1adfTIkSPydw4AALt27SqjKIp0dnaSVzEyMkKysrIIAJKRkaF9L8ah1NTUfMWyrLBly5YJ5rdu3SIURZHU1FTP8ePH57138zH27t0rmz179nBhYWFw5DzPEwCjxcXFDf+ZcSg2m02k1WoHABCapklubm7v0qVLoz+IeShlZWUlaWlpX35w43fhH0T4gcNKUi9fAAAAAElFTkSuQmCC";

/***/ }),

/***/ "./resource/flip_h.png":
/*!*****************************!*\
  !*** ./resource/flip_h.png ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAC70lEQVRYhe2VT2hcVRSHv3Pue2/ezCTt1GiEVCVQoS6sqDvJPxCpiCQKops2ujJIsopRhFKw6FLt1o24sLZKLUItlVRjpGqLVaq0mFQkSasJTdMyVix1xmbuPS7iQMi/jhZXzrd77573/c677953oU6dOnVuADOT1kJr4UYcUmthd0tLbrR4sa0c7AkLmgkWIHg0xhLSo+/Md7/7FB/4/6aBRpooRZ+LVbY05Bvo6Ogkm6QgwlzxEl8d/QKQbxuzDYNXSleO/dMmlmFmtvha4/iNJIls4LkB+2HsjE1OTdnExIRNTk3Y2alJO3jooN17/30mgmmsA7U4qyybgWqhiCyMtRYK+svvM/39/fmh54cIFgDDDMT9/VAAHwIvDr7AR4cPmUutvVLi+Jre6stdr8v0wm/rAyHX/VgPsPCJjwx/yvAnwxCEY18ep6/vWZxGvLb7dbq6uoIv6Vvc9kC2lpnQ1QaqlMsFCEIuzUAQEGFkdITRkc8wEWbnZjnz40+gEEeOwaFBEWFzZvabh1byLc3StcIBmpI/siLKpblfQUAFkjTBOYcGIZvJkMQJ4gNe4J67t2hbV2f4E/pXcy7O1LWKAKK7rk2j/vyJE18TMDzGyzt3suuVXQBsfeRRDhz4EHOCeiWY8WB7R4SFrTH0Xc+vsHxhLGbuNFeB04ePfIwYSFDiJCWbyYN4ElGaNqzDTEE9JrD9mafp3dZrFcfu5nzzrSt5q5m69MZKJJF7c3xs3Pbse9985RoqIATEHAIEFGdgBs4rGkXs2PGSxlHExXLx4dXCoZZtCOw3c9uS5O1Kxfdu2nQnPT3d5fbONt248fbk5qabfsZzizhyIUiYmTlXPHnyez313an83r17Mj6bbqdUem+1bbgiqy/K3OOx030o04gE58SLuLOZNJ1d17j+cpTERcQFpxoilTGS6NUn9+PWctZ8FixlQ0v2jsvn5zenrtIC6cIvIvVomfHm/Pz0uatc+LfuOnXq1Pl/8RfZFzz+oFu3MQAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./resource/flip_v.png":
/*!*****************************!*\
  !*** ./resource/flip_v.png ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAADA0lEQVRYhe2XzW+UVRSHn3Pu+06nY1pbK4yQol0ZP0IKJSpRgVi78zuxJgZl4cqkC/8DpVFXWLubRLeKRowLnDQxhmAonbi1UKKYthgJtXwMVKfTmXln3ntc4MYFna/Ghshve+/5ned+5N5z4HaW/aN2PKSd5P8yEmnJq6WgW626FYimA+ptebMQTU1u9LxbPY47+n+q4csycBf3XYnCHd7xCGUHDqBMOQ6WereH528slX7fcLrRY7ggEbwfqJxzqEecDxJhvrvr7hsdyeQfIu6CcxIj4lEuhk6/gNTLzeRYfwc6O193pfLnBw++WRkcGizu2bPb9/cP9KmaWswajqvX8tcfuHTpYjQznfPfTmWTC7/OEwifHY3jt14TidsDcO5QIpDM7E+zqUQyJRqDJ0bF4QExj6CgHgNq1RpffvW1jY+/RxjwUqUSZ+sBuPUGt6a2LBeiwjt/rqy6/fv2qSmoghfFqQcDxIM4vBmqAYM7H5UTP5yU5cvLPRhH2wIoVovF0Lg2O3fm+d7uXtk1NIiYA/Vcz/9F2BGiElCKilgtRhM37QorBXI/5lLpnXxSvEx1vRxaj7AKn3rR70/OnKqpCF49Ehuvjr7Cd1NTYHD43cOMf/gBDkER9j6xF/Vue+2XxI56/nUBADogkzs1rWfmznpnYE6JoiqlagWvRhzHROUIb+AN7k3fQ2wx+ShV2hCAyrbHT5hxfvLIpFVrMXh4+KEHSae3IWYMjzzLyPAImKFqrJVLoJBMrtT1bvgh6urkydWyzLz43AtyZPIjnCooaAwxcPP/E1SUiY8nyGQyRX9/dz+/rdSnaFQa6pgItmtotx3PHrcLiwu2sDhv8/PztrC4aHPnfraxt8cskQhMw3CiEc+m/+0uup4qsDoJ9tjTB/aT7tsCZpSiMqdPT7NaLGLiztJZe4YC+Q0HADjGqDsUZt+IKB/wVYTQoVVFQl9Jqnwz3Lc1l11aWmvFuykN9Az0GHan+mlLm16U3l5leT2I/6QxuRXEpvQCG9Gcbrr+BiErU0sxKHoEAAAAAElFTkSuQmCC";

/***/ }),

/***/ "./resource/fude.png":
/*!***************************!*\
  !*** ./resource/fude.png ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAClUlEQVRYhd3Xz4tVZRzH8ddxBsa4zVxKB69zURkIctFMKEaUMBsH8w+wRYI6blyUmCuljbXLhUPQok2BRIzLAcF+EWO5mC5TqAiCooMhYhFFCuOPLLxPi+dcO9g9c3+NF/IDhwOH5/t9f855nvP9Pg9PkAp4Jb13Xa/iVwR80m34y/g9hQdMtxK8rEN4GSexIvPsVrcM9OBjrOwgR0c65N/Pnr32dgP+Yg68ipe6YeDTHAO/oe9xw1fhdo6BDx43HA7mwG9i/SNjl2HjUsITXK0Dr+LdOuNX4xf0LpWBrXXgAfPyf+kDeGOpDHxUB34P2xrE7UJxKQxU/PfTv99EXIJ9nZoo4cEj8C80X0178TVea9dAdv6r+AHPNBm7QTRbxdvtGtidgX+FpxuMT8S3/TaNqeK8DgrVGlzEO2nyPPXgLZzLGL6DY3i2VWgP9qfBe7C2ARw+S6EP8GVquNQqmNhUzvT394fR0dHs3F/BjkXirqXggXagNZVxc2RkJMzOzob5+flQqVTC9PR0dWJiIohv915O7JbUQFPqyXl+ZHh4ePPU1FQyODgoSRKFQkGpVErGxsYgmZubW4sP68T+JO6KduIyFhYzkFejnyoWi/cHBgaWhxAeznmSJBYWFszMzMD9RfJ+nho5gr9xCicamclqE+4ODQ1Vy+VyKJfLYXJyMlQqlTA+Ph7EBrOpyVwXxLXzerPwmg7LlN1SqRT6+vqqOKv5Fvsc7uJHLf7/L6Sg2sqvgXe3kKNX7B2ntNEDvhf3+sfFDcjzLcYP4ijebDQwr6gU8Zd4zNqKn/Fdg1wFbBePZ6fFxvNHuwZq2oJvxCm4LDage+l1CX9indiUboir/1IjaCsGiD2gkEKzCrie3v+/+gchBdKwQke8WgAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./resource/hand.png":
/*!***************************!*\
  !*** ./resource/hand.png ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFwElEQVRYhe2XX0yTVxTAf7dOKgI2IhQsMXGGLRPBLkZXN4OQyoNparIGI1FTiUGCS0jUB5zREqPhwX/Loi5xD/7BiEYeQB7mn5hNJBpDIDMRcJrxVaIRlP5zogltld494PfZllZwe9xO0uTrPfec8/vOPffc+8F/XUSCsdlAPlCQQJcLfPEP4owCXcAvgO9DADOAR0Cu0WgU06dPj1XOmIHZbP7o6D6fj87OTsLh8M/Ad9G6T+LmrhRC5La2tlJUVIQQAinlOKlIlKypS11dHa2trTPix+MB5ppMJrF48WIALbj6PBWIaJupiO5DymQBpZQJAyUamww6PgMTnCVz4PV6GRkZ4d69e9qY2Wxm3rx5pKSkxPj5EERSgPjgKpDH42H//v1cu3YNgKysLPR6PT6fj1AoRG5uLjU1NWzcuBGdTqfZSikjHwWQiLqtrY19+/ZhNBo5dOgQy5cvx2QyIYTg5cuX+P1+mpubaWho4MSJE6SkpOBwONi2bRuRSOTtR2cg+u2bm5txuVxs376d6upq9Hp9THoNBgMGg4GFCxcSiUSw2WyEQiGOHz/O2rVrGRsbS0nke0oADx8+xOVyUVNTQ21trQYFEIlEePbsGVJKTCYTbW1tlJWVUV9fTzAY5OrVq5w7d447d+4APJ0sVmVeXp50u91SURTpdrtlf3+/LC4ulkuWLJGKosju7m7Z1NQkFUWRiqLILVu2SEAC0mKxSCGEPHPmjKa32+2aHhgDvo4OmHQbqqnt7e3l1q1b7NmzByEE7e3t7Nq1C4CRkRHOnz/Pjh07OHr0KF1dXUgpWbBgAUIIhBDajrhw4QIWi0UH/DAlAHWvt7S0UFhYqLXg6B7Q09NDMBikoqICu93OqlWrJvgAKCkpwWKxYLPZALInBYhuKPfv32fFihUxu8Ln8/Hq1SuGh4cxmUxkZWUhpWTNmjUAhEIhbe7AwABz5swBxs8SYNqkAGr6Xrx4wcDAAPn5+ZrOarVy8OBB0tPTycnJYWhoiKGhIQAKCsYPULfbrc33eDzx7t3Rf5Iugd/vp7KyEiklxcXF2vjs2bOx2+3odDqWLVuGwWDgypUrCCGYP38+aWlpPH78OMZXamoqUkp6enoAUoA/gD+BZUkBWlpaePToEWfPniU7+/2yqdkB0Ov1lJeX09jYSCgUQghBRkYG/f39wHiR+v1+rX46OzsBVtpstoUmk+kz4GhSAEVRKCgooLCwMGZcLUK1TpxOJ8+fP+fixYsArFu3DqvVipSSjIwMDhw4gNVqxev14na7qaqq4tixY2rB5sT328q8vLzGjo4Obt68SXV1NVarFafTidlsJi0tjfr6em7fvq0ZqB3v0qVL3Lhxg8zMzIQHWSQS4fr165SVlfHmzRusVisej+enpJ2wtLSUkydP0tDQwObNm9Hr9aSnp/P69Wtqa2sxGo309fXR1NTEtGnTGBsbi1kmNVvqs06nY/Xq1UgpOXz4MB6PRwKNCQFUo9LSUkpKSvD5fHR1dbF3714qKirYunUrAOXl5TgcDjZt2oTT6SQzMzNmqeIhpJS0t7dz6tQpCfwI/P7BC4kKk52djc1mY+bMmSxatCgmSFFRER0dHezcuXOCXfyJGggE2L17t5RS/gZ8D5PciOLFaDRy+vRpreJVmTVrlgaU7KYUDodlVVWV9Hq9L4FNwNuEAOFwWEYiERnvSAiBy+VicHCQ9evXc/fuXZ4+fcqDBw9wu90Eg8Gk4IODg2zYsEH09vZKwA480/zGzS0Drufk5LB06VKh1+snOFMURW0o2gsCOBwOceTIkQnznzx5gs1mk6OjoyPAt8DNaH18Ef4KfDk8PPzN5cuXv0oAGB20i/EPjgGguLu7uyHRxL6+PkZHRwFWAj3x+kS7oOfd7+ckwRPJp4FAgLq6OlJTU2M+XgKBgLqWfyUy/HdfG+9lDlAH5ACfA3Pj9P3Aat4t1/8SLX8D+hqAxFxJPLkAAAAASUVORK5CYII=";

/***/ }),

/***/ "./resource/information.png":
/*!**********************************!*\
  !*** ./resource/information.png ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAt0lEQVRIib2VWw6EIAxFW+MydXWyz/oxw7RAQdri3IRERc6ljwDCWPQwL4UzH0vgZeCfBQrrByZZoM9miD/4CrBisr0CF8xtPbnU6wZ7mHAo3Zk45X4DCU79GvpSNAkHsEZgAGeVERyo59QJbw3ywtrECW8NNJMAXDeQCsL7BjXMCQcYdVEAKvWns+jstGZEX6Ykk/nYHm8MAbgGLXk+quGPXOS8+87dGhHBRQSfKPJYJr6T+X2pbgnMNdOnO8qdAAAAAElFTkSuQmCC";

/***/ }),

/***/ "./resource/lock.png":
/*!***************************!*\
  !*** ./resource/lock.png ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAARUlEQVQ4jWNgGGjAiEP8P7HqsRmASzNWPegG/CdVjokYW/CI4TSAaDDwBiD7i1DoY9VLcy/gSmhEG0CxCyg2gGDAUuwCANwbBhtd7LHHAAAAAElFTkSuQmCC";

/***/ }),

/***/ "./resource/mask_on.png":
/*!******************************!*\
  !*** ./resource/mask_on.png ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAALUlEQVQ4jWNkwAT/0fiM+OSZsBhAEhh4AxgZSPQzuvzAe4EqYYAORtPByEsHAKoFCBuY5JqoAAAAAElFTkSuQmCC";

/***/ }),

/***/ "./resource/move.png":
/*!***************************!*\
  !*** ./resource/move.png ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAADCUlEQVRYhe3WT0hlVRwH8M97o+9p+LRwpBbVokV/XAwY08ImfQwNtRFpUUyLSinIcBYxkC5FKCoqJyKoKBdB2SLsUbh6+Gg2pmBEYAiWSZGgm9FQZgZnHN9tce97vnk5pL4ZB2K+cLj3/s6539/3/M75/c7hFvaPx/A7vkPzQTqO4xVcQR7nsYrnDkrA65Hz97CCHnwZ2T7cK1l8HwJ+Rjdewzo28AJewtI++CrCH+iqhGA/ESjFZWEEbhpuR6wSgv3+HMfzSJdxXMI3+AEXb5SAY3gfj6TTaY2NjWBjY8PExIT19XX4BceFWXJdcQpBS0tLMDY2FiwsLFzVZmdng97e3iCRSAQY2g3hoT04fxSjnZ2dseHhYU1NTSAW2w5iVVWV1tZWm5ubpqenj+Aj/7FJS7Mghk9xeodxtRhub2/PDw0NicVienp6TE1NgWw2K5vNFgV1dHTAbWgo4TiGszh8LQGn8CImdxBwAg/09fXF4vHwl7m5OcvLyyCXy8nlcttqa2t3muwCHsb3aCwYq6LncXwQKXwwaovRYOhta2vLNzc3F8arrq6WTCaL7wVhsLJS3Hu1+ATJ6Ps3HMW70WSLAgiX4Cjui75nIgEv44l0Ol30EIvFZDIZqVQKDAwMCIKgSDQ5OUlYlhfLohBE7f7yCJzFZ3gGJ/FjZL8TZ7q7u4OurqsrbkPD9vLW1NRsewgC4+PjhQlcEJ6cBbwtPLpfLRhK98BpLOPzEtuTiURCf39/vDTE10I+nzcyMhLMzMwE+Lis+wT68QZ+KhhL03ATX0edf0a25q2trZNra2uXVldX1+rq6s6nUqka4XJdxNK5c+ca5ufnL2cymc3BwcGq0dFR+ALvlAmoFRamN4XLsCscEp7/s8LLRz6ZTK7U19f/nUwml4Wn4VbUt4iv8NRuydlbKb4L9/j39WsJv+KvvTj+X+BxfFspSSUXkrtx5GYIOCysnOW2t/BQpYJ2g2eFN+A54cbrEmbAhR2E3RDEI6erwvS7gjPCLDlQ3IGnce9BO76F64p/AOYd4dsL5+wgAAAAAElFTkSuQmCC";

/***/ }),

/***/ "./resource/ng.png":
/*!*************************!*\
  !*** ./resource/ng.png ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA4klEQVRIia2VWw7EIAhF0cx3F0bXWxfWDTgfEywq8hh7kyZ96LkIpCTQVY3vXMnzsgMiopteShG5dNPAEajDLCWC74Cvcrf7E4/OJI/wq9zdhgici5gfayNFZIFX6/L44sSjWyxFOKZkBRcNpIh42qR8a1oaSIBIbVwGZCJF6oneZQBg12HLQCuop6VVg1VBPZ1mGni6xWMiGkRakZ9GStlkEO1za+3yVxGBa3smg3/AmjLANCxeETH5RKvRmWAElgCeFE2zN3AqcRaTWg0o+tVs3VFFxAq/U9D1mtpMZs+v6gsVx3EXSmjQgwAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./resource/pen1.png":
/*!***************************!*\
  !*** ./resource/pen1.png ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAADvElEQVRYhe2WX0hkZRjGf58Dzik4Q+y0OSurO9jVkotd7PZHEtuLdKJg0CBqRBaUrYUGCQdRBxwYL/Im2G4yabcWY4vBC2nFULqKJMqiRELbhjOaBBGUmdK6Wu15u/iOtbPNOXM2pat9YOAc3j/PM+/53vf94A4OBhGgFlD/N/EzwFXgBmAD3wOvAqeACj8J9qO4GliKx+P3tLW1EQqFmJ+fJ5fLsba2JsAEkAR+3geHJy7V1dXJ8vKyWJYlhUJBCoWCWJYlo6OjYpqmAJ8BAa8kvspUAjGl1JlkMkkwGESpfwqplKK1tZXx8XEMw3gIOOeVyFOdCwxgMhaLHe7t7XV1ikQibG5uqoWFhRPAG8Cfpfz+SwWypmkez2QyZR07OzsBjgJxN5/bFfAk0JfNZqmqqirrXF1dTTgcVuiq7VuAAbzV0tKi4nHXP/Q3RITBwUHW19dt4OuDEJBRSh1Jp9O+nHO5HJOTkwJkgK/2K6ARGOzv76empsbVSUQAmJiYYGhoSETkIvCKV2I/Au4FLjY3N9Pd3V1EVAqzs7Nks1kRkfPAi4C7M+UnYQB4LxQKPTszM0MkEnF1FBGmp6cZGBiQnZ2dd4Au9HguS+CFl4HepqYmKisrWVlZoba2lkAgUDR8RIS5uTn6+vpke3v7AvCCH3IoX4HPg8HgyXA4bCulAltbWyilSCQSJJNJMQxDASwuLkoikWB3d/ftW8gV8ARw2nm/CqwBH/kRB7A6PDy8szfnl5aWJJPJiGmadkNDg53P52VqakpM07SBy7fEPo7eBdvAp85vFT0RPcdzkYCRkZHrqVRK2tvbJZ1OSz6fl7GxMRuQrq6uPfIvKB42jzpEH6O35s0459ga/Aj4NhqN2hUVFdLY2CiAdHR0iGVZdn19/Q661JeBu26KMYBl4AOPvN8BZ/wIOAtILBYTy7IkkUhINBqVnp6e39Cl/ZB/t3LUEXYad6z6FXAUkHA4bKdSqRvOjrfRN6DXgHCJmLuBRfSBO17CXoG+pDznR8AJh3CP+BvgJeBImbjDwOsuAp4GrqEHnC+cBSaBHuCQ3yAPXAHePYA8tw0FXAB+Bx70EzAIvH9A5AH0UtoCHvMToNDT6lIJmwHcDzzv2JeBN3Ef66fQ63gDaPer+BjFrXQf+tRmgB8c2waQA84Dv6Kv4XtdYQCPoL/1NcfmvslK4BCwCfyC7tk/gJ+AL9GH8RjF/f+w47vu+G+gW/UK8JQXkdcyegA46TwXgE/w3u0RoMXJeR09hn/0Ir8DgL8AaYBB3tIMzbAAAAAASUVORK5CYII=";

/***/ }),

/***/ "./resource/pen2.png":
/*!***************************!*\
  !*** ./resource/pen2.png ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAEbElEQVRYhe2XX0jbVxTHP79sJHEVMkfMsoIMmYizukGp3QLSlxHmUOxE52CSVktAuz8Q9zAoWISJD0b3MAdzmXNjthmW4pgjsLdKkG6ToThYrJNkHc4urBlNZTYuzv3OHn5Jqmn+TSp72Rcuub/zO+ee77n3nJP7g//xH0PZh40ZaMzy7hfgykET+ESv158qLS3VJQWxWIxoNAqwCTwB3NzHugXhCHDn/PnzO6FQSEKhkASDQamrq5OamhqxWq0CfHxQzhXg64qKCgkEAinnU1NTAsiFCxdkbGxMgB3g8YMgcEpRFLl8+bIko19dXZWysjJpbGyUYDAogUBAzGbzv9oFXX4VQNv6d51OJ0ePHgVARJicnOT27dv09fUBYDQaOXPmDEA78Nj9IvAAMFxRUfGwy+VKCePxOOPj4/T09GCxWFLy5uZm9Hr9IeCt+0XAYTAYXhgZGcFoNAJa9KOjo8RiMdra2gBQFK2grFYrNpsN4Nn7QeBJYKSpqYna2tqUcGVlBY/HQ29vL2azOSUXEa5duyZ+v1+AzwohkKsPFAH+qqqquosXL1JSUgKAqqq0t7ejKAqXLl1Cp7sbg4iIy+W64/P5VoDjgOQj8GCOd28XFRXVud3ulHMRYXZ2lqWlJXw+H4qiICKp37W1NXw+30PAe4U4z0XgCHC2o6OD6upqRIR4PE44HObcuXPY7Xaqqqr2GIgI/f39AN8Bk4U4z0XgHeBQOBymoaGBra0tNjc32djYAMDhcNzjfGZmhrm5OQG6C3WejUAJ8NyJEydUg8Ggs9vtlJeXA1BZWUl3dzd+vx+bzZbK/Gg0ytDQkABfAN+nrWcErIn5TSC2+2WmKtgCtuvr63VDQ0O0trYCcPjwYWpqaujp6cHr9RKJRFLRDw4OEolEYsBru9YpBWaAG8D1xAiS/Z90D64cO3ZMXC6XAGIymURRFBkYGJCFhQXR6/XS2dkpwWBQhoeHRVEUFTibvgZaIqaPv4Gn8hF4A1BNJpN68uRJWV5elq6uLgHE5/OJw+EQo9EoHo9HLS4uVtGSLr2kr2YhIMB0PgKlaFsnbrdbQqGQTE9PCyATExMyPz+v6vX6HUAFviXzUQ7mIPBTUilbJ4wAHwKsr68jIuL1esViscji4qLa0tKibG9v64BFoClBJB0raDnQBXQCn+eLOh1PJxk7nU41cc4qcAv4FGhA65bZkH4kp8mwA7lQAtxJGKjAPFp7NRQewx68kolArlYcRcvsFwE/4AH+3KdzgGd2zcO5CLwK1AMLwAbgRNv2JIwJYslS2kTL+Kkczo8DryfmkkeX69zdKhV4Hu08K4G+BPv0rFYThE9zb17Ygd926cYBCzkQTVv4VxIlWeC4BXwFeIGfMxB9P5dzMhglDdUMz3+lydNt0p8DaB82OfEy8EcWAjeAj4CX0K7eJWg1vl4A4S/RGtweZLsRPQo40O4FMbQSnAd+zKL/CPAm0IJ2jUvid7Tj+AD4JpPhfj7N8sGaGDvAD/mU/wGTCPZygcR1iwAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./resource/spuit.png":
/*!****************************!*\
  !*** ./resource/spuit.png ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAACeElEQVRYhe2WPWhTURSAv2sDyUtpCTwhMU4lrg0ShGwWpOpQMVAoTv3RUBUEp0Jw07oIWQUHQZ2F2qGJUAqawVZaMEUwWXovTgpWUYpoFnuPQ5oqhTR5qXld/ODB493DOd+7/3DI9HiMjwAxIAx8//c6zYkBz4AfgADbwGPA9aN4Gvi6U3jv8wpQ3RZ43aS4ABY4dZDkR9qIie3TpoDL3RZoRbjbAh/biLkIPAJOHkSmGTdoPgcE2Prrfb0bAmHg034SjuNINpuV+fn5SjcEAM4AP/cWDgaDMjk5Kaurq2KMscaYF14TB1q09wA3gRzgND7GYjGmpqbIZDL09/dTq9VqwEPgjleBVkyw87dKKRkYGJB8Pi/ValWMMWKMkfHxcQt8AEKdFGi1CsrRaHRrbGyMQqHA0tKS9Pb2SqlU2g3IZrOilDoGXOpEoCXGmAlTp6i1vhKPx5+mUinRWu/2wvT0tHCAXvDKWaWULRaLYowRrbWUy2Xp6+uzwG2vybwexwDvgQvGmPjo6ChKKUKhEEoptby8fAJ4APxqN1knW7EAd9fW1mR9/c++Mzw8DHAcONdBTs8ooDg4OLg7FzY2NiSdTgtQ8JKokyFo8G5zc/Oa67oqmUyilCISibCwsJAAnlDforvOLcdx7MrKijXGSKVSkWg0aoG8H8WhvuzeplIp2xiKXC5ngc/4tCQBksD27OysaK2lVCpZ6jelCb8EAO4ppWRubk601jI0NCTAcz8FQsCbRCIh1WpVZmZmBPiCj8MAEAe+ZTIZWVxcbFxYz/spAHAasCMjI+K6rgBX/RaA+v1hOxAIWOD+YQgAXAdeAkcPS+A/bfMbyDkQZkEBMg0AAAAASUVORK5CYII=";

/***/ }),

/***/ "./resource/swap.png":
/*!***************************!*\
  !*** ./resource/swap.png ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAAAXNSR0IArs4c6QAAAIFJREFUSEvVlEEOwCAIBOX/j6axCY1QN62yHPSsE1gGpRUdKeK2NFhVVUReHAq4dx3hNHCE3+DeDitrq5wOtsrPAbsoMvmO8xnNmFqB3JwVYOBP3dBF1NWvBUFt7UT1RMF2+Rzd3IJUrLXTrWR4NvlV3ZAx6QVZAu94G9+kP3pUxAVWlFAXgzcoGgAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./resource/unlock.png":
/*!*****************************!*\
  !*** ./resource/unlock.png ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAATUlEQVQ4jWNgoBAw4hD/T6x6bAbg0oxVD7oB/0mVYyLGFjxiOA0gGlBsAAuJ6jG8QbELkE0kFH1Y9dI8EHGlVKINoNgFFBtAMGApdgEA7jIGIGzoTUQAAAAASUVORK5CYII=";

/***/ }),

/***/ "./resource/window_all_down.png":
/*!**************************************!*\
  !*** ./resource/window_all_down.png ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAALpJREFUSEvdlVEOgCAMQ+X+h9ZghJA6tg4cGv0yofRRNiBtY98O0xJrQwvBMByIACtQN4gnIQtVPT3AnMqCmn6mQNi7HpTyokQElPahhQrU5eESW63JjGeg1QiMD61pgZg2ZCGvAultmRFqCWd8pblniRhgW0tLX7RS91NA6VUwTa8gmPJ7wDZJ719MMZpwKRDrFJ5wKVC70kKOxVIgHvLShVINsUO1l6eO4Rb9H/j0hd363a62SFj1PgCQzVYKtNp/VQAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./resource/window_all_up.png":
/*!************************************!*\
  !*** ./resource/window_all_up.png ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAAI9JREFUSEvt1tEOgCAIBVD9/4/OueXWXMC9mNgDPRbjCKRVS/BVg72SoNbx635IdYkKfugDG7fgPHCgglEoC86VzS0385kBQGUUioJWZTCKgCymztQCvZiIWqC0D0O3RV9EguKRmDP8zVvq/lHwznAJXD1NKLxXKH25tyzkKEi1xhusVejNqW6lo+DXFb3ma5EiGhbw8xrfAAAAAElFTkSuQmCC";

/***/ }),

/***/ "./resource/window_colormaker.png":
/*!****************************************!*\
  !*** ./resource/window_colormaker.png ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAAU1JREFUSEu9lk0SgyAMhWF04aHanssjeK72UG4c6RANDSH8inXjiJAvLz6IWt1zmTOs5uGDgQY+BpeWXgYGwY2ReVo7lgfNKSwGUHkEZoeLgA4UU4AAFtxx7TpJZbFCCuaQVFLnXLm+CcN4pc2pjpQXoDmFPAdTA2NlbwLaGNVQWtZahZh0FbQrcBgGte+7GsdRbdvmPsE0TWpdV3juAXSl/TuQKAhMjgbrpbDIQHzzt5qmyDwtJ02ueSTdyk+Zlo1PE4DTJ9MtLrenAEhq697FWtMVhaBuWRaAzPMMd8mV/Ju0mMZYEEI4lADE2HxQat90DsDwSkCjQrxgRj2Oo+j9OWK+gjbmlZKWk6hOVi0NtBGfGpsYzo1CT+UdgL69bEDRNCX91VMITlOPX0lRIbXascJBcybJuTT1j4lrgyRLlEmLeTK3PLfsw0uJfAF8q5UdxHjKFQAAAA5lWElmTU0AKgAAAAgAAAAAAAAA0lOTAAAAAElFTkSuQmCC";

/***/ }),

/***/ "./resource/window_layer.png":
/*!***********************************!*\
  !*** ./resource/window_layer.png ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAANZJREFUSEvNlsEVxCAIRKU9K7IEK7I998Gqi2K8hPGtt1z8zDhAKFw+dJkX/gZYUcp3CgUWY3RnllK2llYULIRAq0IojC3TQIiVbGM7wupACIwBDTiEDSDy3XT6GAhrAW3l5Kt7/g8XniYNQrlpi16bwHLObuJTShLSx0kDgD0DPWFM6erWxufvioRtJ80toHtIlJVT8MakQSirde4sIppnqVsPtIs0kGHHtlire1NMh21TKlFdrHgD+8r6bSazgJEw0xZomFnAnsBmo3k29D40s/r6j/AHMk9TGfZf1gYAAAAOZVhJZk1NACoAAAAIAAAAAAAAANJTkwAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./resource/window_palette.png":
/*!*************************************!*\
  !*** ./resource/window_palette.png ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAATdJREFUSEu9lk0SwiAMhcuR3OuMB/F4HsQZ3XskHCihIeQHotJdC7yPF0jSsC1+wmLeZgGjY0OqpjRYQTHOMUOokqw2/ZjVJcjpda2G3+eHal4CY+AwDEgWNM0r4M62CksLsTsJGO77SLy15jEUyLGGMVza2fGZ3ymQugMYLMZQHN4EbN0JQOu2UiB1Ci4zsLkkGFjcWbB8ViWceC7nUgZOwACCofQc4QL1IR2x45yTwtpfGqcYu6za2Uf/C+wynAC1CuMybQALb65u6rUNjRZZHNKar5LIbBFv+pACVHiHe1Q5xELPCXEOTWBahN3Sd0kANqk1y+ZAAfIl8OiWzM7aklcmeIC0eIthlFJl5gxpIzb/aaZvJ9o+1/UtoDs/R34xtDz2VoTO0IhDV2UT0+OnagNiyx1+AJdvkRMD1zotAAAADmVYSWZNTQAqAAAACAAAAAAAAADSU5MAAAAASUVORK5CYII=";

/***/ }),

/***/ "./resource/window_pen.png":
/*!*********************************!*\
  !*** ./resource/window_pen.png ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAAVRJREFUSEvdlEGOgzAMRR1gw2yAPYvhKNycm8AJQGKBhAR45KiJUpLgELWVOllVJM2zv3++gA8v8WEefCUQHyoFFR906EJ2REQQQl/D3sce4GBqPxQaC5QyVlUF4zjqmkKgMUAJS5IEjuOAsixhmqZg6F2gnBkt6ibLMti2DfI8h2VZgqB3gBpmzo3AVITZ6ZW0oUAL5oJSx+u6QpqmpteeGCFAL8zhUPWpefzoz2+UA7IwRSiKAuZ51jUg4q8Q4hYwGKZM5EgcK4V8Hb4FJgtzJMnbYC6gkkBanVse+1+G+blDeZjsXdc19L2auY2OgTk7pM4oI5Xj9n23aLEwL5A2mqaBYRgkzJT3IkVIHe6ZWQeeDNO2LXRd5xole7Fv/tYMEZFS+EdHhtGp451xvrLHcfoiTWNIiMLQMEQyrgKnSz1/ipbRm+Rcda/Yf0nVdwr5/8A/pWmGHVYGxLkAAAAOZVhJZk1NACoAAAAIAAAAAAAAANJTkwAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./resource/window_subtool.png":
/*!*************************************!*\
  !*** ./resource/window_subtool.png ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAANdJREFUSEvtlNENwyAMRMliDMBEjMBEDMBiqUyL5LgYjoiQfCRfKDr5+c6GzSz+tsU88wIp8X0w9mZqSKR7CAFieu9JNwf4K6aCqakrgFr3OYUZwNH5lQTUWFt5w7OTObecNiOCNkURadAa8LQzxKkEToMVuHTKgWcXBE0+s+4Foi8KaqkW68HhI4D8SdMa6mn44jQdlkLOORNjzAnR2Vqbzymlw/+ikY3BQD4rXlzOkDdRmy8MvMVhbz7kqKeBHY6uv6Z/DnCWI6XO/9O2/OKvdngx71v+A7ETgR2iyLtGAAAADmVYSWZNTQAqAAAACAAAAAAAAADSU5MAAAAASUVORK5CYII=";

/***/ }),

/***/ "./src/html/config.txt":
/*!*****************************!*\
  !*** ./src/html/config.txt ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = "<!-- 設定タブ -->\n<div id=\"axp_config_div_menu\">\n    <div id=\"axp_config_div_content\">\n        <div id=\"axp_config_div_nav\">\n            <div id=\"axp_config_div_navButton\">\n                <button class=\"axpc_MSG axpc_ACTIVE\" data-msg=\"@CFG2001\">${_(\"@SETTINGS.MENU_CANVAS\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2002\">${_(\"@SETTINGS.MENU_TOOL_WINDOWS\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2003\">${_(\"@SETTINGS.MENU_PEN_TOOL\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2004\">${_(\"@SETTINGS.MENU_COLOR\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2005\">${_(\"@SETTINGS.MENU_SWATCHES\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2006\">${_(\"@SETTINGS.MENU_LAYER\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2007\">${_(\"@SETTINGS.MENU_MISC\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2008\">${_(\"@SETTINGS.MENU_CUSTOM_BUTTONS\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2009\">${_(\"@SETTINGS.MENU_MOUSE\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2010\">${_(\"@SETTINGS.MENU_TOUCH_PANEL\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2011\">${_(\"@SETTINGS.MENU_KEYBOARD\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2013\">${_(\"@SETTINGS.MENU_STARTUP\")}</button>\n                <button class=\"axpc_MSG\" data-msg=\"@CFG2020\"\n                    id=\"axp_config_button_version\">${_(\"@SETTINGS.MENU_VER_INFO\")}</button>\n            </div>\n        </div>\n        <div class=\"axpc_config_chapter\" id=\"axp_config_div_pageMain\">\n            <div class=\"axpc_config_section\" data-title=\"キャンバス\">\n                <div class=\"axpc_config_group\" data-title=\"キャンバスの初期化\">\n                    <u>画像サイズ</u><br>\n                    <div style=\"display: flex;\">\n                        <div class=\"axpc_number axpc_MSG\" data-msg=\"@CFG0300\">\n                            <label>横\n                                <input id=\"axp_config_number_oekakiWidth\" type=\"number\">\n                            </label>×\n                        </div>\n                        <div class=\"axpc_number axpc_MSG\" data-msg=\"@CFG0301\">\n                            <label>縦\n                                <input id=\"axp_config_number_oekakiHeight\" type=\"number\">[px]\n                            </label>\n                        </div>\n                    </div>\n                    <span id=\"axp_config_span_canvasSizeLimit\"></span><br>\n                    [履歴]<br>\n                    <ul id=\"axp_config_ul_canvasSizeHistory\" class=\"axpc_MSG\" data-msg=\"@CFG0016\">\n                    </ul>\n                    <button id=\"axp_config_button_newCanvas\" class=\"axpc_MSG axpc_button axpc_button_width260\"\n                        data-msg=\"@CFG0017\">新規キャンバス</button>\n                    <br>\n                    <button id=\"axp_config_button_changeCanvasSize\" class=\"axpc_MSG axpc_button axpc_button_width260\"\n                        data-msg=\"@CFG0018\">画像を保持したままサイズ変更</button>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"画像の書き出し\">\n                    <button class=\"axpc_MSG axpc_button axpc_button_width260\" data-msg=\"@CFG0019\"\n                        id=\"axp_config_button_pngDownload\">画像をPNG形式でファイルに保存</button>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"キャンバス全体のぼかし（アンチエイリアシング）\">\n                    <form id=\"axp_config_form_antialiasing\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0020\" data-value=\"off\" data-default=\"y\">なし</span>\n                        <span data-msg=\"@CFG0021\" data-value=\"on\">あり</span>\n                    </form>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"ポインタ座標の表示\">\n                    <form id=\"axp_config_form_displayPosition\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0022\" data-value=\"off\" data-default=\"y\">なし</span>\n                        <span data-msg=\"@CFG0023\" data-value=\"upperleft\">左上</span>\n                        <span data-msg=\"@CFG0024\" data-value=\"upperright\">右上</span>\n                        <span data-msg=\"@CFG0010\" data-value=\"lowerleft\">左下</span>\n                        <span data-msg=\"@CFG0025\" data-value=\"lowerright\">右下</span>\n                    </form>\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"ツールウィンドウ\">\n                <div class=\"axpc_config_group\" data-title=\"ツールウィンドウ位置の自動調整\">\n                    <form id=\"axp_config_form_windowAutoAdjust\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0028\" data-value=\"off\">なし</span>\n                        <span data-msg=\"@CFG0029\" data-value=\"on\" data-default=\"y\">あり</span>\n                    </form>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"位置初期化\">\n                    <button id=\"axp_config_button_resetWindow\" class=\"axpc_MSG axpc_button axpc_button_width260\"\n                        data-msg=\"@CFG0030\">全ウィンドウ位置の初期化</button>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"表示ウィンドウ\">\n                    <u>アイコンサイズ</u>\n                    <form id=\"axp_config_form_minimizeButtonType\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0036\" data-value=\"small\">小</span>\n                        <span data-msg=\"@CFG0036\" data-value=\"medium\" data-default=\"y\">中</span>\n                        <span data-msg=\"@CFG0036\" data-value=\"big\">大</span>\n                    </form>\n                    <div style=\"margin-top: 8px;\"></div>\n                    <div class=\"axpc_checkbox axpc_MSG\" data-msg=\"@CFG0037\">\n                        <label>\n                            <input id=\"axp_config_checkbox_singleWindowMode\" class=\"axpc_SAVE\"\n                                type=\"checkbox\">単一ウィンドウモードを使用する\n                        </label>\n                    </div>\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"ペンツール\" data-icon=\"axpc_icon_window_pen\">\n                <div class=\"axpc_config_group\" data-title=\"手ぶれ補正\">\n                    <u>補正の強さ</u>\n                    <form id=\"axp_config_form_stabilizerValue\" oninput=\"result.value=parseInt(volume.value)\"\n                        class=\"axpc_range axpc_range_width228 axpc_SAVE\">\n                        <input type=\"range\" name=\"volume\" value=\"2\" step=\"1\" min=\"0\" max=\"10\" class=\"axpc_MSG\"\n                            data-msg=\"@CFG0040\">\n                        <div class=\"axpc_range_label axpc_text_border\">手ぶれ補正</div>\n                        <div class=\"axpc_range_value axpc_text_border\"><output name=\"result\">2</output></div>\n                    </form>\n                    <div style=\"margin-top: 4px;\"></div>\n                    <div class=\"axpc_checkbox axpc_MSG\" data-msg=\"@CFG0041\">\n                        <label>\n                            <input id=\"axp_config_checkbox_stabilize\" class=\"axpc_SAVE\"\n                                type=\"checkbox\">ペンツールウィンドウ内にレンジスライダーを表示する\n                        </label>\n                    </div>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"スポイト\">\n                    <u>使用後ペンに切り替える</u>\n                    <form id=\"axp_config_form_autoChangeSpuitToPen\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0043\" data-value=\"off\" data-default=\"y\">なし</span>\n                        <span data-msg=\"@CFG0044\" data-value=\"on\">あり</span>\n                    </form>\n                    <br>\n                    <u>長押しスポイト</u>\n                    <form id=\"axp_config_form_useLongtap\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0045\" data-value=\"off\" data-default=\"y\">なし</span>\n                        <span data-msg=\"@CFG0046\" data-value=\"on\">あり</span>\n                    </form>\n                    <div style=\"margin-top: 16px;\"></div>\n                    <form id=\"axp_config_form_longtapDurationValue\" oninput=\"result.value=parseInt(volume.value)\"\n                        class=\"axpc_range axpc_range_width228 axpc_SAVE\">\n                        <input type=\"range\" name=\"volume\" value=\"700\" step=\"100\" min=\"500\" max=\"1500\" class=\"axpc_MSG\"\n                            data-msg=\"@CFG0047\">\n                        <div class=\"axpc_range_label axpc_text_border\">長押し反応時間</div>\n                        <div class=\"axpc_range_value axpc_text_border\"><output name=\"result\">700</output></div>[ミリ秒]\n                    </form>\n                    <form id=\"axp_config_form_longtapStabilizerValue\" oninput=\"result.value=parseInt(volume.value)\"\n                        class=\"axpc_range axpc_range_width228 axpc_SAVE\">\n                        <input type=\"range\" name=\"volume\" value=\"5\" step=\"1\" min=\"0\" max=\"10\" class=\"axpc_MSG\"\n                            data-msg=\"@CFG0048\">\n                        <div class=\"axpc_range_label axpc_text_border\">長押し受付範囲</div>\n                        <div class=\"axpc_range_value axpc_text_border\"><output name=\"result\">5</output></div>[px]\n                    </form>\n                    （※長押し操作が反応しない場合、受付範囲を大きくしてください）\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"レンジスライダー\">\n                    <u>ぼかし度</u>\n                    <form id=\"axp_config_form_blurLevel\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0200\" data-value=\"off\" data-default=\"y\">なし</span>\n                        <span data-msg=\"@CFG0201\" data-value=\"on\">あり</span>\n                    </form>\n                    <br>\n                    <u>トーン濃度</u>\n                    <form id=\"axp_config_form_ToneLevel\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0049\" data-value=\"off\" data-default=\"y\">なし</span>\n                        <span data-msg=\"@CFG0050\" data-value=\"on\">あり</span>\n                    </form>\n                    <br>\n                    <u>太さと不透明度の表示順序</u>\n                    <form id=\"axp_config_form_pentoolRangeOrder\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0051\" data-value=\"size\" data-default=\"y\">太さ->不透明度</span>\n                        <span data-msg=\"@CFG0052\" data-value=\"alpha\">不透明度->太さ</span>\n                    </form>\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"色作成\" data-icon=\"axpc_icon_window_colormaker\">\n                <div class=\"axpc_config_group\" data-title=\"使用する色作成ツール\">\n                    <u>混色パレット</u>\n                    <form id=\"axp_config_form_makeColorTypeMixed\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0053\" data-value=\"off\" data-default=\"y\">なし</span>\n                        <span data-msg=\"@CFG0054\" data-value=\"on\">あり</span>\n                    </form>\n                    <br>\n                    <u>RGBスライダー</u>\n                    <form id=\"axp_config_form_makeColorTypeRGB\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0055\" data-value=\"off\">なし</span>\n                        <span data-msg=\"@CFG0056\" data-value=\"on\" data-default=\"y\">あり</span>\n                    </form>\n                    <br>\n                    <u>カラーピッカー</u>\n                    <form id=\"axp_config_form_makeColorTypePicker\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0057\" data-value=\"off\">なし</span>\n                        <span data-msg=\"@CFG0058\" data-value=\"on\" data-default=\"y\">あり</span>\n                    </form>\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"パレット\" data-icon=\"axpc_icon_window_palette\">\n                <div class=\"axpc_config_group\" data-title=\"パレットのレイアウト\">\n                    <u>横幅（列の数）</u><br>\n                    <form id=\"axp_config_form_paletteColumnValue\" class=\"axpc_range axpc_range_width228\">\n                        <!-- axpc_SAVE 対象外 -->\n                        <input type=\"range\" class=\"axpc_MSG\" name=\"volume\" value=\"3\" step=\"1\" min=\"1\" max=\"24\"\n                            data-msg=\"@CFG0063\">\n                        <div class=\"axpc_range_label axpc_text_border\">横幅</div>\n                        <div class=\"axpc_range_value axpc_text_border\"><output name=\"result\"></output></div>[列]\n                    </form>\n                    <div style=\"margin-top: 4px;\"></div>\n                    <div class=\"axpc_checkbox axpc_MSG\" data-msg=\"@CFG0062\">\n                        <label>\n                            <input id=\"axp_config_checkbox_paletteColumnEdit\" class=\"axpc_SAVE\" type=\"checkbox\"\n                                checked>パレット編集モード時にレンジスライダーを表示する\n                        </label>\n                    </div>\n                    <div style=\"margin-top: 8px;\"></div>\n                    <!-- カラーパレットを表示するためのエリア -->\n                    <div id=\"axp_config_div_paletteText\"></div>\n                    <div id=\"axp_config_div_paletteScroll\">\n                        <div id=\"axp_config_div_paletteBox\"></div>\n                    </div>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"パレットのインポート・エクスポート／初期化\">\n                    <button id=\"axp_config_button_saveColor\" class=\"axpc_MSG axpc_button axpc_button_width260\"\n                        data-msg=\"@CFG0064\">パレットファイルに保存</button>\n                    <br>\n                    <button id=\"axp_config_button_loadColor\" class=\"axpc_MSG axpc_button axpc_button_width260\"\n                        data-msg=\"@CFG0065\">パレットファイルの読込</button>\n                    <br>\n                    <button id=\"axp_config_button_resetColor\" class=\"axpc_MSG axpc_button axpc_button_width260\"\n                        data-msg=\"@CFG0066\">パレットの初期化</button>\n                    <input type=\"file\" id=\"axp_config_file_loadColor\" accept=\".txt\" style=\"display: none;\">\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"レイヤー\" data-icon=\"axpc_icon_window_layer\">\n                <div class=\"axpc_config_group\" data-title=\"合成モードの表示\">\n                    <form id=\"axp_config_form_blendModeDisplayType\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0120\" data-value=\"none\">なし</span>\n                        <span data-msg=\"@CFG0121\" data-value=\"all\">全表示</span>\n                        <span data-msg=\"@CFG0122\" data-value=\"unusual\" data-default=\"y\">通常以外表示</span>\n                    </form>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"レイヤー名の登録\">\n                    レイヤー名の変更時、文字入力の代わりに登録した名前を使用できます。\n                    <div id=\"axp_config_div_colorTag\" class=\"axpc_MSG\" data-msg=\"@CFG0123\"></div>\n                    <button id=\"axp_config_button_resetColorTag\" class=\"axpc_MSG axpc_button axpc_button_width260\"\n                        data-msg=\"@CFG0124\">レイヤー名の初期化</button>\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"補助ツール\" data-icon=\"axpc_icon_window_subtool\">\n                <div class=\"axpc_config_group\" data-title=\"アンドゥ／リドゥ可能回数\">\n                    <form id=\"axp_config_form_undoMaxValue\" oninput=\"result.value=parseInt(volume.value)\"\n                        class=\"axpc_range axpc_range_width228 axpc_SAVE\">\n                        <input type=\"range\" name=\"volume\" value=\"25\" step=\"1\" min=\"10\" max=\"50\" class=\"axpc_MSG\"\n                            data-msg=\"@CFG0067\">\n                        <div class=\"axpc_range_label axpc_text_border\">回数</div>\n                        <div class=\"axpc_range_value axpc_text_border\"><output name=\"result\">25</output></div>[回]\n                    </form>\n                    （※変更した値を有効にするにはAXNOS Paintを再起動する必要があります）\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"拡大率\">\n                    <div id=\"axp_config_div_scale\">\n                        <div id=\"axp_config_div_scaleButton\">\n                            <input id=\"axp_config_number_scale\" type=\"number\" maxlength=\"3\" min=\"25\" max=\"1600\"\n                                value=\"125\" size=\"5\" class=\"axpc_MSG\" data-msg=\"@CFG0211\">\n                            <span>[%]</span>\n                            <button id=\"axp_config_button_addScale\" class=\"axpc_MSG axpc_button\"\n                                data-msg=\"@CFG0070\">追加</button>\n                        </div>\n                        （※最小25～最大1600）\n                        <button id=\"axp_config_button_deleteScale\" class=\"axpc_MSG axpc_button\"\n                            data-msg=\"@CFG0071\">選択した拡大率を削除</button>\n                        <ul id=\"axp_config_ul_scale\" class=\"axpc_MSG\" data-msg=\"@CFG0212\">\n                        </ul>\n                        <button id=\"axp_config_button_resetScale\" class=\"axpc_MSG axpc_button\"\n                            data-msg=\"@CFG0072\">拡大率の初期化</button>\n                    </div>\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"カスタムボタン\">\n                <div class=\"axpc_config_group\" data-title=\"カスタムボタンと機能割り当て\">\n                    <u>ボタンの表示</u>\n                    <form id=\"axp_config_form_useCustomButton\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0080\" data-value=\"off\" data-default=\"y\">なし</span>\n                        <span data-msg=\"@CFG0081\" data-value=\"on\">あり</span>\n                    </form>\n                    <br>\n                    <div id=\"axp_config_div_customButtonFunction\">\n                        <table id=\"axp_config_table_customButton\" class=\"axpc_MSG axpc_config_table\"\n                            data-msg=\"@CFG0112\">\n                            <thead>\n                                <tr>\n                                    <th>ボタン</th>\n                                    <th>機能</th>\n                                </tr>\n                            </thead>\n                            <tbody>\n                            </tbody>\n                        </table>\n                    </div>\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"マウス\">\n                <div class=\"axpc_config_group\" data-title=\"マウス右ボタン\">\n                    <form id=\"axp_config_form_mouseRightButton\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0082\" data-value=\"none\">なし</span>\n                        <span data-msg=\"@CFG0083\" data-value=\"undo\" data-default=\"y\">アンドゥ</span>\n                        <span data-msg=\"@CFG0084\" data-value=\"spuit\">スポイト</span>\n                        <span data-msg=\"@CFG0085\" data-value=\"hand\">ハンド</span>\n                        <span data-msg=\"@CFG0086\" data-value=\"loupe\">拡大率100%</span>\n                        <span data-msg=\"@CFG0087\" data-value=\"swapcolor\">ﾒｲﾝ色切替</span>\n                        <span data-msg=\"@CFG0088\" data-value=\"swaptrans\">透明色切替</span>\n                        <span data-msg=\"@CFG0400\" data-value=\"transdraw\">透明色描画</span>\n                    </form>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"マウスホイールボタン\">\n                    <form id=\"axp_config_form_mouseWheelButton\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0082\" data-value=\"none\">なし</span>\n                        <span data-msg=\"@CFG0083\" data-value=\"undo\">アンドゥ</span>\n                        <span data-msg=\"@CFG0084\" data-value=\"spuit\" data-default=\"y\">スポイト</span>\n                        <span data-msg=\"@CFG0085\" data-value=\"hand\">ハンド</span>\n                        <span data-msg=\"@CFG0086\" data-value=\"loupe\">拡大率100%</span>\n                        <span data-msg=\"@CFG0087\" data-value=\"swapcolor\">ﾒｲﾝ色切替</span>\n                        <span data-msg=\"@CFG0088\" data-value=\"swaptrans\">透明色切替</span>\n                        <span data-msg=\"@CFG0400\" data-value=\"transdraw\">透明色描画</span>\n                    </form>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"マウスホイール回転\">\n                    <form id=\"axp_config_form_mouseWheelRotate\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0089\" data-value=\"none\">なし</span>\n                        <span data-msg=\"@CFG0090\" data-value=\"loupe\" data-default=\"y\">拡大/縮小</span>\n                        <span data-msg=\"@CFG0091\" data-value=\"scroll\">スクロール</span>\n                    </form>\n                    <div class=\"axpc_checkbox axpc_MSG\" data-msg=\"@CFG0220\">\n                        <label>\n                            <input id=\"axp_config_checkbox_mouseWheelDirection\" class=\"axpc_SAVE\" type=\"checkbox\">回転方向反転\n                        </label>\n                    </div>\n                    <div class=\"axpc_checkbox axpc_MSG\" data-msg=\"@CFG0223\">\n                        <label>\n                            <input id=\"axp_config_checkbox_mouseWheelPointerTracking\" class=\"axpc_SAVE\" type=\"checkbox\"\n                                checked>ポインタ位置を中心に拡大／縮小\n                        </label>\n                    </div>\n                    <div class=\"axpc_number axpc_MSG\" data-msg=\"@CFG0221\">\n                        <label>スクロール移動量\n                            <input id=\"axp_config_number_mouseWheelMoveSize\" class=\"axpc_SAVE\" type=\"number\" min=\"1\"\n                                max=\"100\" value=\"30\">[px]（※最小1～最大100）\n                        </label>\n                    </div>\n                    <div class=\"axpc_number axpc_MSG\" data-msg=\"@CFG0222\">\n                        <label>連続入力抑止時間\n                            <input id=\"axp_config_number_mouseWheelSleepTime\" class=\"axpc_SAVE\" type=\"number\" min=\"0\"\n                                max=\"500\" value=\"0\">[ミリ秒]\n                        </label>\n                    </div>\n                    （※最小0～最大500。0を指定すると入力抑止を行いません。<br>\n                    　タッチパッドのホイール操作感度が高すぎる場合に設定してください）\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"タッチパッド\">\n                    <u>キャンバスの拡大／縮小</u>（ピンチアウト／ピンチイン）\n                    <form id=\"axp_config_form_mouseWheelZoom\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0097\" data-value=\"off\" data-default=\"y\">なし</span>\n                        <span data-msg=\"@CFG0098\" data-value=\"on\">あり</span>\n                    </form>\n                    （※「あり」設定時、環境によってマウスホイールと競合する場合があります）\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"タッチパネル\">\n                <div class=\"axpc_config_group\" data-title=\"タッチ操作\">\n                    <u>機能割り当て</u>（１本指タッチ）\n                    <form id=\"axp_config_form_touchDrawType\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0092\" data-value=\"none\">なし</span>\n                        <span data-msg=\"@CFG0093\" data-value=\"draw\" data-default=\"y\">描画</span>\n                        <span data-msg=\"@CFG0094\" data-value=\"hand\">ハンド</span>\n                    </form>\n                    <br>\n                    <u>キャンバスの移動</u>（２本指スワイプ）\n                    <form id=\"axp_config_form_touchHand\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0095\" data-value=\"off\">なし</span>\n                        <span data-msg=\"@CFG0096\" data-value=\"on\" data-default=\"y\">あり</span>\n                    </form>\n                    <br>\n                    <u>キャンバスの拡大／縮小</u>（ピンチ操作）\n                    <form id=\"axp_config_form_touchZoom\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0097\" data-value=\"off\">なし</span>\n                        <span data-msg=\"@CFG0098\" data-value=\"on\" data-default=\"y\">あり</span>\n                    </form>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"タップ操作\">\n                    <u>アンドゥ</u>（２本指タップ）\n                    <form id=\"axp_config_form_touchUndo\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0099\" data-value=\"off\">なし</span>\n                        <span data-msg=\"@CFG0100\" data-value=\"on\" data-default=\"y\">あり</span>\n                    </form>\n                    <br>\n                    <u>リドゥ</u>（３本指タップ）\n                    <form id=\"axp_config_form_touchRedo\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0101\" data-value=\"off\">なし</span>\n                        <span data-msg=\"@CFG0102\" data-value=\"on\" data-default=\"y\">あり</span>\n                    </form>\n                    <div style=\"margin-top: 16px;\"></div>\n                    <form id=\"axp_config_form_touchDurationValue\" oninput=\"result.value=parseInt(volume.value)\"\n                        class=\"axpc_range axpc_range_width228 axpc_SAVE\">\n                        <input type=\"range\" name=\"volume\" value=\"300\" step=\"100\" min=\"100\" max=\"1000\" class=\"axpc_MSG\"\n                            data-msg=\"@CFG0103\">\n                        <div class=\"axpc_range_label axpc_text_border\">タップ制限時間</div>\n                        <div class=\"axpc_range_value axpc_text_border\"><output name=\"result\">300</output></div>[ミリ秒]\n                    </form>\n                    <form id=\"axp_config_form_touchThresholdValue\" oninput=\"result.value=parseInt(volume.value)\"\n                        class=\"axpc_range axpc_range_width228 axpc_SAVE\">\n                        <input type=\"range\" name=\"volume\" value=\"5\" step=\"1\" min=\"0\" max=\"10\" class=\"axpc_MSG\"\n                            data-msg=\"@CFG0401\">\n                        <div class=\"axpc_range_label axpc_text_border\">タップ受付範囲</div>\n                        <div class=\"axpc_range_value axpc_text_border\"><output name=\"result\">5</output></div>[px]\n                    </form>\n                    （※タップ操作が反応しない場合、受付範囲を大きくしてください）\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"キーボード\">\n                <div class=\"axpc_config_group\" data-title=\"ショートカットと機能割り当て\">\n                    <div class=\"axpc_checkbox axpc_MSG\" data-msg=\"@CFG0111\">\n                        <label>\n                            <input id=\"axp_config_checkbox_shortcutKeyHiddenNofunc\" class=\"axpc_SAVE\"\n                                type=\"checkbox\">割り当て無しのキーを非表示にする\n                        </label>\n                    </div>\n                    <div style=\"margin-top: 8px;\"></div>\n                    <table id=\"axp_config_table_shortcutKey\" class=\"axpc_MSG axpc_config_table\" data-msg=\"@CFG0112\">\n                        <thead>\n                            <tr>\n                                <th>キー</th>\n                                <th>機能</th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            <tr>\n                                <td>[ SPACE ]</td>\n                                <td>ハンドツール</td>\n                            </tr>\n                            <tr>\n                                <td>[ SHIFT ]</td>\n                                <td>直線</td>\n                            </tr>\n                            <tr>\n                                <td>[ CTRL ]</td>\n                                <td>スポイト</td>\n                            </tr>\n                        </tbody>\n                    </table>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"ショートカットのインポート・エクスポート／初期化\">\n                    <button id=\"axp_config_button_saveShortcut\" class=\"axpc_MSG axpc_button axpc_button_width260\"\n                        data-msg=\"@CFG0113\">ショートカットファイルに保存</button>\n                    <br>\n                    <button id=\"axp_config_button_loadShortcut\" class=\"axpc_MSG axpc_button axpc_button_width260\"\n                        data-msg=\"@CFG0114\">ショートカットファイルの読込</button>\n                    <br>\n                    <button id=\"axp_config_button_resetShortcut\" class=\"axpc_MSG axpc_button axpc_button_width260\"\n                        data-msg=\"@CFG0115\">ショートカットの初期化</button>\n                    <input type=\"file\" id=\"axp_config_file_loadShortcut\" accept=\".txt\" style=\"display: none;\">\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"画面スクロール\">\n                    <div class=\"axpc_checkbox axpc_MSG\" data-msg=\"@CFG0230\">\n                        <label>\n                            <input id=\"axp_config_checkbox_moveDirection\" class=\"axpc_SAVE\" type=\"checkbox\">スクロール方向反転\n                        </label>\n                    </div>\n                    <div class=\"axpc_number axpc_MSG\" data-msg=\"@CFG0108\">\n                        <label>スクロール移動量\n                            <input id=\"axp_config_number_moveSize\" class=\"axpc_SAVE\" type=\"number\" min=\"1\" max=\"100\"\n                                value=\"30\">[px]（※最小1～最大100）\n                        </label>\n                    </div>\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"起動時\">\n                <div class=\"axpc_config_group\" data-title=\"前回の状態の復元\">\n                    <u>ツールウィンドウ位置</u>\n                    <form id=\"axp_config_form_saveLastWindowPosition\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0026\" data-value=\"off\">なし</span>\n                        <span data-msg=\"@CFG0027\" data-value=\"on\" data-default=\"y\">あり</span>\n                    </form>\n                    <br>\n                    <u>ペンツールの設定値</u>\n                    <form id=\"axp_config_form_saveLastPenValue\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0034\" data-value=\"off\">なし</span>\n                        <span data-msg=\"@CFG0035\" data-value=\"on\" data-default=\"y\">あり</span>\n                    </form>\n                    <br>\n                    <u>カラーパレットの色</u>\n                    <form id=\"axp_config_form_saveLastPalleteColor\" class=\"axpc_radio\">\n                        <span data-msg=\"@CFG0059\" data-value=\"off\">なし</span>\n                        <span data-msg=\"@CFG0060\" data-value=\"on\" data-default=\"y\">あり</span>\n                    </form>\n                </div>\n            </div>\n            <div class=\"axpc_config_section\" data-title=\"バージョン情報\" id=\"axp_config_div_version\">\n                <div class=\"axpc_config_group\" data-title=\"バージョン情報\">\n                    <div id=\"axp_config_div_versionInfo\"></div>\n                    © 2022 「悪の巣」部屋番号13番：「趣味の悪い大衆酒場[Mad end dance hall]」<br>\n                    <br>\n                    ◆ github<br>\n                    <a href=\"https://github.com/axnospaint/axnospaint-lib\" target=\"_blank\" rel=\"noopener\"\n                        style=\"text-decoration: none;color:#00f\">\n                        https://github.com/axnospaint/axnospaint-lib</a>\n                    <br><br>\n                    ◆ AXNOS Paint:ヘルプ - ニコニコ大百科<br>\n                    <a href=\"https://dic.nicovideo.jp/id/5703111\" target=\"_blank\" rel=\"noopener\"\n                        style=\"text-decoration: none;color:#00f\">\n                        https://dic.nicovideo.jp/id/5703111</a>\n                    <br>\n                </div>\n                <div class=\"axpc_config_group\" data-title=\"デバッグ情報表示\">\n                    <details>\n                        <summary><span style=\"color:#f00\"><b>※不具合発生時の動作検証用です。通常時は使用しないでください。</b></span></summary>\n                        <div class=\"axpc_checkbox axpc_MSG\" data-msg=\"チェックするとデバッグモードを有効になります。\">\n                            <label>\n                                <input id=\"axp_config_checkbox_useDebugMode\" class=\"axpc_SAVE\"\n                                    type=\"checkbox\">デバッグ情報を表示する\n                            </label>\n                        </div>\n                    </details>\n                </div>\n            </div>\n            <div style=\"height: calc(100vh);\"></div>\n            <div class=\"axpc_config_section\" data-title=\"ページの終端です。\">\n            </div>\n        </div>\n    </div>\n</div>";

/***/ }),

/***/ "./src/html/main.txt":
/*!***************************!*\
  !*** ./src/html/main.txt ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = "<!-- AXNOS Paintメイン -->\n<div id=\"axp_main\" class=\"axpc_main\">\n\t<!-- 切り替えタブ -->\n\t<div id=\"axp_main_div_tab\">\n\t\t<!-- ハンバーガーメニューボタン -->\n\t\t<input type=\"checkbox\" id=\"axp_main_checkbox_hamburger\">\n\t\t<label id=\"axp_main_label_hamburger\" for=\"axp_main_checkbox_hamburger\">\n\t\t\t<div class=\"axpc_icon_humburger\"></div>\n\t\t</label>\n\t\t<div id=\"axp_main_div_tab_menu\">\n\t\t\t<div data-idx=\"0\" class=\"axpc_MSG\" data-msg=\"@BAS0001\">${_(\"@TAB.CANVAS\")}</div>\n\t\t\t<div data-idx=\"1\" class=\"axpc_MSG\" data-msg=\"@BAS0002\">${_(\"@TAB.SETTINGS\")}</div>\n\t\t\t<div data-idx=\"2\" class=\"axpc_MSG\" data-msg=\"@BAS0003\">${_(\"@TAB.POST\")}</div>\n\t\t\t<div data-idx=\"3\" class=\"axpc_MSG\" data-msg=\"@BAS0004\"></div>\n\t\t</div>\n\t\t<div id=\"axp_main_div_headerText\" class=\"axpc_MSG\" data-msg=\"@BAS0005\"></div>\n\t</div>\n\n\t<!-- タブにより切り替わる画面 -->\n\t<div id=\"axp_main_div_tabContent\">\n\t\t<!-- キャンバス -->\n\t\t<article>\n\t\t\t<div id=\"axp_canvas\">\n\t\t\t\t<!-- ペンの太さを表示する補助円 -->\n\t\t\t\t<div id=\"axp_canvas_div_penCursor\"></div>\n\n\t\t\t\t<!-- ポインタ座標表示領域 -->\n\t\t\t\t<div id=\"axp_canvas_div_pointerPosition\" class=\"axpc_NONE\"></div>\n\n\t\t\t\t<!-- デバッグ情報表示 -->\n\t\t\t\t<div id=\"axp_canvas_div_debugInfo\" class=\"axpc_NONE axpc_MSG\" data-msg=\"@BAS0100\">\n\t\t\t\t\t<div></div>\n\t\t\t\t\t<div></div>\n\t\t\t\t</div>\n\n\t\t\t\t<!-- 描画エリア -->\n\t\t\t\t<div id=\"axp_canvas_div_grayBackground\">\n\t\t\t\t\t<!-- 補助線 -->\n\t\t\t\t\t<div id=\"axp_canvas_div_grid\" class=\"axpc_NONE\">\n\t\t\t\t\t\t<svg id=\"axp_canvas_svg_grid\" xmlns=\"http://www.w3.org/2000/svg\">\n\t\t\t\t\t\t\t<defs>\n\t\t\t\t\t\t\t\t<pattern id=\"axp_canvas_pattern_gridVH\" patternUnits=\"userSpaceOnUse\">\n\t\t\t\t\t\t\t\t\t<path fill=\"none\" />\n\t\t\t\t\t\t\t\t</pattern>\n\t\t\t\t\t\t\t\t<pattern id=\"axp_canvas_pattern_gridSubDivision\" patternUnits=\"userSpaceOnUse\">\n\t\t\t\t\t\t\t\t\t<path fill=\"none\" />\n\t\t\t\t\t\t\t\t</pattern>\n\t\t\t\t\t\t\t\t<pattern id=\"axp_canvas_pattern_gridDiagonal\" patternUnits=\"userSpaceOnUse\">\n\t\t\t\t\t\t\t\t\t<path fill=\"none\" />\n\t\t\t\t\t\t\t\t</pattern>\n\t\t\t\t\t\t\t\t<pattern id=\"axp_canvas_pattern_gridPixel1\" patternUnits=\"userSpaceOnUse\">\n\t\t\t\t\t\t\t\t\t<path fill=\"none\" />\n\t\t\t\t\t\t\t\t</pattern>\n\t\t\t\t\t\t\t\t<pattern id=\"axp_canvas_pattern_gridPixel2\" patternUnits=\"userSpaceOnUse\">\n\t\t\t\t\t\t\t\t\t<path fill=\"none\" />\n\t\t\t\t\t\t\t\t</pattern>\n\t\t\t\t\t\t\t</defs>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</div>\n\t\t\t\t\t<!-- canvas要素 -->\n\t\t\t\t\t<canvas id=\"axp_canvas_canvas_main\" class=\"axpc_background_mesh\"></canvas>\n\t\t\t\t</div>\n\n\t\t\t\t<!-- セーブロードサブウィンドウ -->\n\t\t\t\t<div id=\"axp_saveload\" class=\"axpc_NONE\">\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<span id=\"axp_saveload_span_message\"></span>\n\t\t\t\t\t\t<div id=\"axp_saveload_div_insertHTML\"></div>\n\t\t\t\t\t\t<button id=\"axp_saveload_button_close\" class=\"axpc_button\">${_(\"@COMMON.BUTTON_CLOSE\")}</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<!-- レイヤー名変更サブウィンドウ -->\n\t\t\t\t<div id=\"axp_renamelayer\" class=\"axpc_subwindow axpc_NONE\">\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<div class=\"axpc_button_closeContainer\">\n\t\t\t\t\t\t\t<span>${_(\"@LAYER.LAYERS_INFO\")}</span>\n\t\t\t\t\t\t\t<button id=\"axp_renamelayer_button_close\" class=\"axpc_MSG axpc_button axpc_button_close\"\n\t\t\t\t\t\t\t\tdata-msg=\"@LAY0100\"></button>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div id=\"axp_renamelayer_div_textarea\">\n\t\t\t\t\t\t\t<input id=\"axp_renamelayer_text_newLayerName\" type=\"text\" size=\"15\" maxlength=\"10\"\n\t\t\t\t\t\t\t\tautocomplete=\"off\" class=\"axpc_MSG\" data-msg=\"@LAY0101\" placeholder=\"空白にはできません\">\n\t\t\t\t\t\t\t<!-- 状態によりMSG変化 -->\n\t\t\t\t\t\t\t<button id=\"axp_renamelayer_button_confirm\"\n\t\t\t\t\t\t\t\tclass=\"axpc_button\">${_(\"@LAYER.BUTTON_RENAME_OK\")}</button>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div id=\"axp_renamelayer_div_buttonarea\">\n\t\t\t\t\t\t\t<button id=\"axp_renamelayer_button_flipH\" class=\"axpc_MSG axpc_button\"\n\t\t\t\t\t\t\t\tdata-msg=\"@LAY0110\"></button>\n\t\t\t\t\t\t\t<button id=\"axp_renamelayer_button_flipV\" class=\"axpc_MSG axpc_button\"\n\t\t\t\t\t\t\t\tdata-msg=\"@LAY0111\"></button>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div id=\"axp_renamelayer_div_colorTagContainer\">\n\t\t\t\t\t\t\t<span>${_(\"@LAYER.PRESET_NAME\")}</span>\n\t\t\t\t\t\t\t<button id=\"axp_renamelayer_button_colorReset\" class=\"axpc_MSG axpc_button\"\n\t\t\t\t\t\t\t\tdata-msg=\"@LAY0102\">${_(\"@LAYER.BUTTON_CLEAR_COLOR\")}</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div id=\"axp_renamelayer_div_colorTag\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<!-- 補助線の色変更サブウィンドウ -->\n\t\t\t\t<div id=\"axp_gridconfig\" class=\"axpc_subwindow axpc_NONE\">\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<div class=\"axpc_button_closeContainer\">\n\t\t\t\t\t\t\t<span>${_(\"@GRID.LINE_COLOR\")}</span>\n\t\t\t\t\t\t\t<button id=\"axp_gridconfig_button_confirm\" class=\"axpc_MSG axpc_button axpc_button_close\"\n\t\t\t\t\t\t\t\tdata-msg=\"@AST0122\"></button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div id=\"axp_gridconfig_div_colorPicker\" class=\"axpc_MSG\" data-msg=\"@AST0120\"></div>\n\t\t\t\t\t\t<form id=\"axp_gridconfig_form_gridColor\" class=\"axpc_range axpc_text_border\"\n\t\t\t\t\t\t\toninput=\"result.value=parseInt(volume.value)\">\n\t\t\t\t\t\t\t<input type=\"range\" id=\"axp_gridconfig_range_gridColor\" name=\"volume\" min=\"5\" max=\"100\"\n\t\t\t\t\t\t\t\tstep=\"5\" value=\"100\" class=\"axpc_MSG\" data-msg=\"@AST0121\">\n\t\t\t\t\t\t\t<div class=\"axpc_range_label\">${_(\"@COMMON.OPACITY\")}</div>\n\t\t\t\t\t\t\t<div class=\"axpc_range_value\"><output name=\"result\">100</output></div>\n\t\t\t\t\t\t</form>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</article>\n\t\t<!-- 設定 -->\n\t\t<article>\n\t\t\t<div id=\"axp_config\"></div>\n\t\t</article>\n\t\t<!-- 投稿 -->\n\t\t<article>\n\t\t\t<div id=\"axp_post\"></div>\n\t\t</article>\n\t</div>\n</div>\n<!-- フッター -->\n<div id=\"axp_footer\" class=\"axpc_MSG\" data-msg=\"@BAS0006\">\n\t<div id=\"axp_footer_div_icon\"></div>\n\t<div id=\"axp_footer_div_message\">AXNOS Paint（アクノスペイント）</div>\n</div>";

/***/ }),

/***/ "./src/html/penmode.txt":
/*!******************************!*\
  !*** ./src/html/penmode.txt ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = "<!-- ペンツールサブメニュー -->\n<div id=\"axp_penmode\" class=\"axpc_NONE\">\n    <div>\n        <span id=\"axp_penmode_span_modeName\"></span>\n        <article data-name=\"${_('@PENGROUP.PEN')}\">\n            <!-- ※idをそのままペン種別名として使用するため命名規則例外 -->\n            <button id=\"axp_penmode_round\" class=\"axpc_FUNC axpc_penmode_round\" data-idx=\"0\" data-msg=\"@PEN0100\"\n                data-function=\"func_switch_axp_penmode_round\"></button>\n            <button id=\"axp_penmode_square\" class=\"axpc_FUNC axpc_penmode_square\" data-idx=\"0\" data-msg=\"@PEN0101\"\n                data-function=\"func_switch_axp_penmode_square\"></button>\n            <button id=\"axp_penmode_dot\" class=\"axpc_FUNC axpc_penmode_dot\" data-idx=\"0\" data-msg=\"@PEN0102\"\n                data-function=\"func_switch_axp_penmode_dot\"></button>\n            <button id=\"axp_penmode_fude\" class=\"axpc_FUNC axpc_penmode_fude\" data-idx=\"0\" data-msg=\"@PEN0103\"\n                data-function=\"func_switch_axp_penmode_fude\"></button>\n            <button id=\"axp_penmode_crayon\" class=\"axpc_FUNC axpc_penmode_crayon\" data-idx=\"0\"\n                data-function=\"func_switch_axp_penmode_crayon\" data-msg=\"@PEN0104\"></button>\n            <button id=\"axp_penmode_brush\" class=\"axpc_FUNC axpc_penmode_brush\" data-idx=\"0\"\n                data-function=\"func_switch_axp_penmode_brush\" data-msg=\"@PEN0105\"></button>\n        </article>\n        <article data-name=\"${_('@PENGROUP.ERASER')}\">\n            <button id=\"axp_penmode_eraser_round\" class=\"axpc_FUNC axpc_penmode_eraser_round\" data-idx=\"1\"\n                data-function=\"func_switch_axp_penmode_eraser_round\" data-msg=\"@PEN0110\"></button>\n            <button id=\"axp_penmode_eraser_dot\" class=\"axpc_FUNC axpc_penmode_eraser_dot\" data-idx=\"1\"\n                data-function=\"func_switch_axp_penmode_eraser_dot\" data-msg=\"@PEN0111\"></button>\n        </article>\n        <article data-name=\"${_('@PENGROUP.FILL')}\">\n            <button id=\"axp_penmode_fill\" class=\"axpc_FUNC axpc_penmode_fill\" data-idx=\"2\"\n                data-function=\"func_switch_axp_penmode_fill\" data-msg=\"@PEN0120\"></button>\n            <button id=\"axp_penmode_fillgradation\" class=\"axpc_FUNC axpc_penmode_fillgradation\"\n                data-function=\"func_switch_axp_penmode_fillgradation\" data-idx=\"2\" data-msg=\"@PEN0121\"></button>\n        </article>\n        <article data-name=\"${_('@PENGROUP.TOOL')}\">\n            <button id=\"axp_penmode_hand\" class=\"axpc_FUNC axpc_penmode_hand\" data-idx=\"3\"\n                data-function=\"func_switch_axp_penmode_hand\" data-msg=\"@PEN0130\"></button>\n            <button id=\"axp_penmode_move\" class=\"axpc_FUNC axpc_penmode_move\" data-idx=\"3\"\n                data-function=\"func_switch_axp_penmode_move\" data-msg=\"@PEN0131\"></button>\n        </article>\n        <article data-name=\"${_('@PENGROUP.EYEDROPPER')}\">\n            <button id=\"axp_penmode_spuit\" class=\"axpc_penmode_spuit\" data-idx=\"4\"></button>\n        </article>\n    </div>\n</div>\n<!--追加用HTMLここまで -->";

/***/ }),

/***/ "./src/html/post.txt":
/*!***************************!*\
  !*** ./src/html/post.txt ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = "<!-- 投稿タブ -->\n<div id=\"axp_post_div_content\">\n    <div class=\"axpc_post_frame\">\n        <!-- サムネイルと拡大表示ポップアップ -->\n        <div class=\"axpc_post_canvas\">\n            <p>${_(\"@POST.THUMBNAIL\")}</p>\n            <input type=\"checkbox\" id=\"axp_post_checkbox_popup\" />\n            <label for=\"axp_post_checkbox_popup\" class=\"axpc_post_overlay\">\n                <label for=\"axp_post_checkbox_popup\" class=\"axpc_post_overlayWindow\">\n                    <label for=\"axp_post_checkbox_popup\" class=\"axpc_post_overlayCloseButton\"></label>\n                    <canvas id=\"axp_post_canvas_postingImage\" class=\"axpc_post_overlayCanvas\"></canvas>\n                </label>\n            </label>\n            <label for=\"axp_post_checkbox_popup\" class=\"axpc_post_thumbnail\">\n                <canvas id=\"axp_post_canvas_thumbnail\" class=\"axpc_background_mesh\"></canvas>\n            </label>\n            <div id=\"axp_post_div_thumbnailTitle\">\n            </div>\n            <p class=\"axpc_post_thumbnailClick\">${_(\"@POST.THUMBNAIL_CLICK\")}</p>\n        </div>\n        <!-- 罫線 -->\n        <div class=\"axpc_post_line\"></div>\n        <!-- 入力フォーム -->\n        <div id=\"axp_post_div_input\">\n            <div class=\"axpc_post_input\">\n                <div class=\"axpc_post_name_property\">${_(\"@POST.NAME\")}</div>\n                <div class=\"axpc_post_name_required axpc_NONE\">${_(\"@COMMON.REQUIRED\")}</div>\n\n                <input id=\"axp_post_text_name\" type=\"text\" spellcheck=\"false\" />\n\n                <div class=\"axpc_post_title_property\">${_(\"@POST.TITLE\")}</div>\n                <div class=\"axpc_post_title_required axpc_NONE\">${_(\"@COMMON.REQUIRED\")}</div>\n\n                <input id=\"axp_post_text_title\" type=\"text\" spellcheck=\"false\" />\n\n                <div class=\"axpc_post_message_property\">${_(\"@POST.MESSAGE\")}</div>\n                <div class=\"axpc_post_message_required axpc_NONE\">${_(\"@COMMON.REQUIRED\")}</div>\n\n                <textarea id=\"axp_post_textarea_message\" spellcheck=\"false\"></textarea>\n                <label class=\"axpc_post_watchList\">\n                    <input id=\"axp_post_checkbox_watchList\" type=\"checkbox\" />\n                    ${_(\"@POST.WATCHLIST\")}\n                </label>\n            </div>\n        </div>\n        <!-- 画像ステータス -->\n        <div class=\"axpc_post_status\">\n            <div class=\"axpc_post_status_size_property\">${_(\"@POST.STATUS.SIZE\")}</div>\n            <div class=\"axpc_post_status_size_colon\">:</div>\n            <div class=\"axpc_post_status_size_value\">\n                <span id=\"axp_post_span_imageSize\"></span>\n            </div>\n            <div class=\"axpc_post_status_bg_property\">${_(\"@POST.STATUS.BG_TRANSPARENT\")}</div>\n            <div class=\"axpc_post_status_bg_colon\">:</div>\n            <div class=\"axpc_post_status_bg_value\">\n                <span><input type=\"radio\" id=\"axp_post_radio_bgWhite\" name=\"axp_post_radio_bg\" value=\"white\"\n                        checked /><label for=\"axp_post_radio_bgWhite\">${_(\"@COMMON.BG_WHITE\")}</label></span>\n                <span><input type=\"radio\" id=\"axp_post_radio_bgTransparent\" name=\"axp_post_radio_bg\"\n                        value=\"transparent\" /><label\n                        for=\"axp_post_radio_bgTransparent\">${_(\"@COMMON.BG_TRANSPARENT\")}</label></span>\n            </div>\n            <div class=\"axpc_post_status_based_property\">${_(\"@POST.STATUS.BASED\")}</div>\n            <div class=\"axpc_post_status_based_colon\">:</div>\n            <div class=\"axpc_post_status_bg_value\">\n                <span id=\"axp_post_span_referenceOekakiId\"></span>\n            </div>\n        </div>\n    </div>\n    <!-- 注意事項 -->\n    <div id=\"axp_post_div_notice\">\n        <u>${_(\"@POST.NOTICE\")}</u>\n        <div>\n            <div>${_(\"@POST.NOTICE1\")}</div>\n            <div>${_(\"@POST.NOTICE2\")}</div>\n            <div>${_(\"@POST.NOTICE3\")}</div>\n            <div>${_(\"@POST.NOTICE4\")}</div>\n        </div>\n    </div>\n    <!-- 投稿ボタン -->\n    <div id=\"axp_post_div_button\">\n        <span id=\"axp_post_span_message\"></span>\n        <button id=\"axp_post_button_upload\" class=\"axpc_MSG axpc_button\" data-msg=\"@POS0001\">\n            <div id=\"axp_post_button_upload_label\"></div>\n            <div id=\"axp_post_button_upload_loading\" class=\"axpc_NONE\"></div>\n        </button>\n    </div>\n</div>";

/***/ }),

/***/ "./src/html/window_custom.txt":
/*!************************************!*\
  !*** ./src/html/window_custom.txt ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = "<!-- カスタムボタン -->\n<div class=\"axpc_window_content\">\n    <div id=\"axp_custom_div_buttons\">\n        <!-- メッセージテキストはconfig.jsで自動設定 -->\n        <button class=\"axpc_MSG axpc_custom_button\" data-index=\"1\">1</button>\n        <button class=\"axpc_MSG axpc_custom_button\" data-index=\"2\">2</button>\n        <button class=\"axpc_MSG axpc_custom_button\" data-index=\"3\">3</button>\n    </div>\n</div>";

/***/ }),

/***/ "./src/html/window_launcher.txt":
/*!**************************************!*\
  !*** ./src/html/window_launcher.txt ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = "<!-- ランチャー -->\n<div class=\"axpc_window_content\">\n    <div id=\"axp_launcher_div_buttons\">\n        <!-- 一括ボタン -->\n        <button class=\"axpc_MSG axpc_launcher_allButton\" data-id=\"axp_all\" data-msg=\"@LAU0001\">\n            <div class=\"axpc_icon_window_all_down\"></div>\n        </button>\n        <!-- 個別ボタン外枠 -->\n        <div id=\"axp_launcher_div_personalButtons\">\n            <div id=\"axp_launcher_div_personalButtonsEntry\">\n                <!-- 区切り -->\n                <div id=\"axp_launcher_separator\"></div>\n                <!-- 個別ボタンは自動生成 -->\n            </div>\n        </div>\n\n    </div>\n</div>";

/***/ }),

/***/ "./src/html/window_layer.txt":
/*!***********************************!*\
  !*** ./src/html/window_layer.txt ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = "<!-- レイヤー -->\n<div class=\"axpc_window_content\">\n    <select id=\"axp_layer_select_blendMode\" class=\"axpc_MSG\" data-msg=\"@LAY0001\">\n        <option value=\"source-over\">${_(\"@LAYER.OPTION_NORMAL\")}</option>\n        <option value=\"source-atop\">${_(\"@LAYER.OPTION_CLIPING\")}</option>\n        <option value=\"multiply\">${_(\"@LAYER.OPTION_MULTIPLY\")}</option>\n        <option value=\"screen\">${_(\"@LAYER.OPTION_SCREEN\")}</option>\n        <option value=\"overlay\">${_(\"@LAYER.OPTION_OVERLAY\")}</option>\n        <option value=\"darken\">${_(\"@LAYER.OPTION_DARKEN\")}</option>\n        <option value=\"lighten\">${_(\"@LAYER.OPTION_LIGHTEN\")}</option>\n        <option value=\"color-dodge\">${_(\"@LAYER.OPTION_DODGE\")}</option>\n        <option value=\"color-burn\">${_(\"@LAYER.OPTION_BURN\")}</option>\n        <option value=\"hard-light\">${_(\"@LAYER.OPTION_HARD_LIGHT\")}</option>\n        <option value=\"soft-light\">${_(\"@LAYER.OPTION_SOFT_LIGHT\")}</option>\n        <option value=\"difference\">${_(\"@LAYER.OPTION_DIFFERENCE\")}</option>\n        <option value=\"exclusion\">${_(\"@LAYER.OPTION_EXCLUSION\")}</option>\n    </select>\n    <div id=\"axp_layer_div_button1\">\n        <form id=\"axp_layer_form_alpha\" oninput=\"result.value=parseInt(volume.value)\"\n            class=\"axpc_range axpc_text_border\">\n            <input type=\"range\" id=\"axp_layer_range_alpha\" name=\"volume\" value=\"100\" min=\"0\" max=\"100\" step=\"5\"\n                class=\"axpc_MSG\" data-msg=\"@LAY0002\">\n            <div class=\"axpc_range_label\">${_(\"@COMMON.OPACITY\")}</div>\n            <div class=\"axpc_range_value\"><output name=\"result\"></output></div>\n        </form>\n        <button class=\"axpc_FUNC axpc_button\" data-function=\"func_layer_clear\" data-msg=\"@LAY0003\"\n            id=\"axp_layer_button_clear\">${_(\"@LAYER.BUTTON_CLEAR\")}</button>\n    </div>\n    <div id=\"axp_layer_div_button2\">\n        <button id=\"axp_layer_button_create\" class=\"axpc_FUNC axpc_button\" data-function=\"func_layer_create\"\n            data-msg=\"@LAY0004\">${_(\"@LAYER.BUTTON_NEW\")}</button>\n        <button id=\"axp_layer_button_integrate\" class=\"axpc_FUNC axpc_button\" data-function=\"func_layer_integrate\"\n            data-msg=\"@LAY0005\">${_(\"@LAYER.BUTTON_MERGE\")}</button>\n        <button id=\"axp_layer_button_copy\" class=\"axpc_FUNC axpc_button\" data-function=\"func_layer_copy\"\n            data-msg=\"@LAY0006\">${_(\"@LAYER.BUTTON_COPY\")}</button>\n        <button id=\"axp_layer_button_delete\" class=\"axpc_FUNC axpc_button\" data-function=\"func_layer_delete\"\n            data-msg=\"@LAY0007\">${_(\"@LAYER.BUTTON_DEL\")}</button>\n    </div>\n</div>\n<ul id=\"axp_layer_ul_layerBox\" class=\"axpc_MSG\" data-msg=\"@LAY0008\"></ul>";

/***/ }),

/***/ "./src/html/window_makecolor.txt":
/*!***************************************!*\
  !*** ./src/html/window_makecolor.txt ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = "<!-- 色作成 -->\n<div class=\"axpc_window_content\">\n    <!-- 混色パレット（オプション） -->\n    <div id=\"axp_makecolor_div_mixedPalette\">\n        <div></div>\n    </div>\n    <!-- 描画色 -->\n    <div id=\"axp_makecolor_div_drawColor\">\n        <div></div>\n        <div></div>\n        <div></div>\n        <!-- メインカラー／サブカラー、透明色 -->\n        <div id=\"axp_makecolor_div_mainColor\" class=\"axpc_FUNC axpc_colorRect\" data-function=\"func_switch_maincolor\"\n            data-msg=\"@MKC0001\" data-selected=\"true\">\n        </div>\n        <div id=\"axp_makecolor_div_subColor\" class=\"axpc_FUNC axpc_colorRect\" data-function=\"func_switch_subcolor\"\n            data-msg=\"@MKC0002\"></div>\n        <div id=\"axp_makecolor_div_transparent\" class=\"axpc_FUNC axpc_colorRect axpc_background_mesh\"\n            data-function=\"func_switch_transparent\" data-msg=\"@MKC0003\">\n        </div>\n        <!-- カラーコード -->\n        <input id=\"axp_makecolor_text_colorCode\" class=\"axpc_MSG\" data-msg=\"@MKC0004\" maxlength=\"7\" value=\"#000000\">\n        <!-- パレット登録ボタン -->\n        <div id=\"axp_makecolor_button_addColor\" class=\"axpc_MSG\" data-msg=\"@MKC0005\"></div>\n        <!-- メイン／サブ入れ替えボタン -->\n        <div id=\"axp_makecolor_button_swapColor\" class=\"axpc_MSG\" data-msg=\"@MKC0006\"></div>\n    </div>\n    <!-- RGBスライダー -->\n    <div id=\"axp_makecolor_div_RGBSlider\">\n        <div class=\"axpc_range\">\n            <span>${_(\"@COMMON.RED\")}</span><input id=\"axp_makecolor_range_red\" class=\"axpc_MSG range_color\"\n                type=\"range\" min=\"0\" max=\"255\" value=\"0\" data-msg=\"@MKC0007\"><input id=\"axp_makecolor_number_red\"\n                class=\"axpc_MSG\" type=\"number\" min=\"0\" max=\"255\" value=\"0\" maxlength=\"3\" data-msg=\"@MKC0008\">\n        </div>\n        <div class=\"axpc_range\">\n            <span>${_(\"@COMMON.GREEN\")}</span><input id=\"axp_makecolor_range_green\" class=\"axpc_MSG range_color\"\n                type=\"range\" min=\"0\" max=\"255\" value=\"0\" data-msg=\"@MKC0009\"><input id=\"axp_makecolor_number_green\"\n                class=\"axpc_MSG\" type=\"number\" min=\"0\" max=\"255\" value=\"0\" maxlength=\"3\" data-msg=\"@MKC0010\">\n        </div>\n        <div class=\"axpc_range\">\n            <span>${_(\"@COMMON.BLUE\")}</span><input id=\"axp_makecolor_range_blue\" class=\"axpc_MSG range_color\"\n                type=\"range\" min=\"0\" max=\"255\" value=\"0\" data-msg=\"@MKC0011\"><input id=\"axp_makecolor_number_blue\"\n                class=\"axpc_MSG\" type=\"number\" min=\"0\" max=\"255\" value=\"0\" maxlength=\"3\" data-msg=\"@MKC0012\">\n        </div>\n    </div>\n    <!-- カラーピッカー -->\n    <div id=\"axp_makecolor_div_colorPicker\" class=\"axpc_MSG\" data-msg=\"@MKC0013\">\n        <div></div>\n    </div>\n</div>";

/***/ }),

/***/ "./src/html/window_palette.txt":
/*!*************************************!*\
  !*** ./src/html/window_palette.txt ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = "<!-- パレット -->\n<div class=\"axpc_window_content\">\n    <!-- 列数サブウィンドウ -->\n    <div id=\"axp_palette_div_column\" class=\"axpc_NONE\">\n        <form id=\"axp_palette_form_column\" class=\"axpc_range axpc_text_border\">\n            <input type=\"range\" id=\"axp_palette_range_column\" class=\"axpc_MSG\" name=\"volume\" value=\"3\" step=\"1\" min=\"1\"\n                max=\"24\" data-msg=\"@PLT0001\">\n            <div class=\"axpc_range_label\">${_(\"@SWATCHES.COLUMNS\")}</div>\n            <div class=\"axpc_range_value\"><output name=\"result\"></output></div>\n        </form>\n    </div>\n    <div id=\"axp_palette_div_container\">\n        <!-- パレット操作ボタン（更新、登録、削除 -->\n        <div id=\"axp_palette_div_buttons\">\n            <button id=\"axp_palette_button_edit\" class=\"axpc_MSG axpc_button\"\n                data-msg=\"@PLT0002\">${_(\"@SWATCHES.EDIT\")}</button>\n            <button id=\"axp_palette_button_addColor\" class=\"axpc_MSG axpc_button\"\n                data-msg=\"@PLT0003\">${_(\"@SWATCHES.SET\")}</button>\n            <button id=\"axp_palette_button_delete\" class=\"axpc_MSG axpc_button axpc_NONE\"\n                data-msg=\"@PLT0004\">${_(\"@SWATCHES.DEL\")}</button>\n        </div>\n        <!-- カラーパレットを表示するためのエリア -->\n        <div id=\"axp_palette_div_paletteBox\"></div>\n    </div>\n</div>";

/***/ }),

/***/ "./src/html/window_pen.txt":
/*!*********************************!*\
  !*** ./src/html/window_pen.txt ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = "<!-- ペンツール -->\n<div class=\"axpc_window_content\">\n    <div id=\"axp_pen_div_content\">\n        <!-- ペンツール左側 -->\n        <div id=\"axp_pen_div_leftSide\">\n            <span id=\"axp_pen_span_penName\" class=\"axpc_MSG\" data-msg=\"@PEN0001\"></span>\n            <!-- プレビュー領域 -->\n            <div id=\"axp_pen_div_preview\" class=\"axpc_MSG\" data-msg=\"@PEN0200\">\n                <canvas id=\"axp_pen_canvas_previewPenSize\"></canvas>\n                <canvas id=\"axp_pen_canvas_previewSpuit\"></canvas>\n            </div>\n            <!-- スライダー領域 -->\n            <div id=\"axp_pen_div_slider\">\n                <!-- ペンの不透明度 -->\n                <form id=\"axp_pen_form_alpha\" class=\"axpc_range axpc_text_border\"\n                    oninput=\"result.value=parseInt(volume.value)\">\n                    <input type=\"range\" id=\"axp_pen_range_alpha\" name=\"volume\" min=\"5\" max=\"100\" value=\"100\" step=\"5\"\n                        class=\"axpc_MSG\" data-msg=\"@PEN0002\">\n                    <div class=\"axpc_range_label\">${_(\"@COMMON.OPACITY\")}</div>\n                    <div class=\"axpc_range_value\"><output name=\"result\"></output></div>\n                </form>\n                <!-- ペンの太さ -->\n                <form id=\"axp_pen_form_penSize\" class=\"axpc_range axpc_text_border\">\n                    <input type=\"range\" id=\"axp_pen_range_penSize\" name=\"volume\" min=\"1\" max=\"100\" value=\"1\" step=\"1\"\n                        class=\"axpc_MSG\" data-msg=\"@PEN0003\">\n                    <div class=\"axpc_range_label\">${_(\"@PEN.SIZE\")}</div>\n                    <div class=\"axpc_range_value\"><output name=\"result\"></output></div>\n                </form>\n                <!-- バケツの境界補正 -->\n                <form id=\"axp_pen_form_fillThreshold\" oninput=\"result.value=parseInt(volume.value)\"\n                    class=\"axpc_range axpc_text_border\">\n                    <input type=\"range\" id=\"axp_pen_range_fillThreshold\" name=\"volume\" value=\"0\" step=\"1\" min=\"0\"\n                        max=\"5\" class=\"axpc_MSG\" data-msg=\"@PEN0004\">\n                    <div class=\"axpc_range_label\">${_(\"@PEN.GROW_FILL_AREA\")}</div>\n                    <div class=\"axpc_range_value\"><output name=\"result\"></output></div>\n                </form>\n                <!-- バケツのグラデーション角度 -->\n                <form id=\"axp_pen_form_fillGradationDeg\" oninput=\"result.value=parseInt(volume.value)\"\n                    class=\"axpc_range axpc_text_border\">\n                    <input type=\"range\" id=\"axp_pen_range_fillGradationDeg\" name=\"volume\" value=\"0\" step=\"15\" min=\"0\"\n                        max=\"360\" class=\"axpc_MSG\" data-msg=\"@PEN0005\">\n                    <div class=\"axpc_range_label\">${_(\"@PEN.ANGLE\")}</div>\n                    <div class=\"axpc_range_value\"><output name=\"result\"></output></div>\n                </form>\n                <!-- クレヨンの丸み -->\n                <form id=\"axp_pen_form_radius\" oninput=\"result.value=parseInt(volume.value)\"\n                    class=\"axpc_range axpc_text_border\">\n                    <input type=\"range\" id=\"axp_pen_range_radius\" name=\"volume\" value=\"50\" step=\"1\" min=\"0\" max=\"50\"\n                        class=\"axpc_MSG\" data-msg=\"@PEN0010\">\n                    <div class=\"axpc_range_label\">${_(\"@PEN.ROUNDNESS\")}</div>\n                    <div class=\"axpc_range_value\"><output name=\"result\"></output></div>\n                </form>\n                <!-- ぼかし度（オプション） -->\n                <form id=\"axp_pen_form_blur\" oninput=\"result.value=parseInt(volume.value)\"\n                    class=\"axpc_range axpc_text_border\">\n                    <input type=\"range\" id=\"axp_pen_range_blur\" name=\"volume\" value=\"0\" step=\"1\" min=\"0\" max=\"5\"\n                        class=\"axpc_MSG\" data-msg=\"@PEN0009\">\n                    <div class=\"axpc_range_label\">${_(\"@PEN.BLUR\")}</div>\n                    <div class=\"axpc_range_value\"><output name=\"result\"></output></div>\n                </form>\n                <!-- トーン濃度（オプション） -->\n                <form id=\"axp_pen_form_toneLevel\" oninput=\"result.value=parseInt(volume.value)\"\n                    class=\"axpc_range axpc_text_border\">\n                    <input type=\"range\" id=\"axp_pen_range_toneLevel\" name=\"volume\" value=\"16\" step=\"1\" min=\"1\" max=\"16\"\n                        class=\"axpc_MSG\" data-msg=\"@PEN0006\">\n                    <div class=\"axpc_range_label\">${_(\"@PEN.TONE_DENSITY\")}</div>\n                    <div class=\"axpc_range_value\"><output name=\"result\"></output></div>\n                </form>\n                <!-- 手ぶれ補正（オプション） -->\n                <form id=\"axp_pen_form_stabilizer\" oninput=\"result.value=parseInt(volume.value)\"\n                    class=\"axpc_range axpc_text_border\">\n                    <input type=\"range\" id=\"axp_pen_range_stabilizer\" name=\"volume\" value=\"2\" step=\"1\" min=\"0\" max=\"10\"\n                        class=\"axpc_MSG\" data-msg=\"@CFG0040\">\n                    <div class=\"axpc_range_label\">${_(\"@PEN.STABILIZER\")}</div>\n                    <div class=\"axpc_range_value\"><output name=\"result\"></output></div>\n                </form>\n            </div>\n\n            <div id=\"axp_pen_div_spuitColorRGBA\">\n                <div>${_(\"@COMMON.RED\")}:<span id=\"axp_pen_span_spuitColorRed\">-</span></div>\n                <div>${_(\"@COMMON.GREEN\")}:<span id=\"axp_pen_span_spuitColorGreen\">-</span></div>\n                <div>${_(\"@COMMON.BLUE\")}:<span id=\"axp_pen_span_spuitColorBlue\">-</span></div>\n                <div>${_(\"@COMMON.ALPHA\")}:<span id=\"axp_pen_span_spuitColorAlpha\">-</span></div>\n            </div>\n\n            <div id=\"axp_pen_div_selectbox\">\n                <select id=\"axp_pen_select_drawMode\" class=\"axpc_MSG\" data-msg=\"@PEN0007\">\n                    <option value=\"option_normal\">${_(\"@PEN.OPTION_FREE_HAND\")}</option>\n                    <option value=\"option_line\">${_(\"@PEN.OPTION_STRAIGHT\")}</option>\n                    <option value=\"option_rectangle\">${_(\"@PEN.OPTION_RECT\")}</option>\n                    <option value=\"option_circle\">${_(\"@PEN.OPTION_CIRCLE\")}</option>\n                </select>\n                <select id=\"axp_pen_select_fillMode\" class=\"axpc_MSG axpc_NONE\" data-msg=\"@PEN0008\">\n                    <option value=\"option_all\">${_(\"@PEN.OPTION_FILL_SAMPLE_ALL\")}</option>\n                    <option value=\"option_layer\">${_(\"@PEN.OPTION_FILL_SAMPLE_CURRENT\")}</option>\n                </select>\n            </div>\n\n        </div>\n        <!-- ペンツール右側 -->\n        <div id=\"axp_pen_div_rightSide\">\n            <div>\n                <button data-idx=\"0\" id=\"axp_pen_button_penBase\" class=\"axpc_FUNC\" data-function=\"func_switch_pen\"\n                    data-selected=\"true\" data-msg=\"@PEN0050\"></button>\n            </div>\n            <div>\n                <button data-idx=\"1\" id=\"axp_pen_button_eraserBase\" class=\"axpc_FUNC\" data-function=\"func_switch_eraser\"\n                    data-msg=\"@PEN0051\"></button>\n            </div>\n            <div>\n                <button data-idx=\"2\" id=\"axp_pen_button_fillBase\" class=\"axpc_FUNC\" data-function=\"func_switch_fill\"\n                    data-msg=\"@PEN0052\"></button>\n            </div>\n            <div>\n                <button data-idx=\"3\" id=\"axp_pen_button_handBase\" class=\"axpc_FUNC\" data-function=\"func_switch_hand\"\n                    data-msg=\"@PEN0053\"></button>\n            </div>\n            <div>\n                <button data-idx=\"4\" id=\"axp_pen_button_spuitBase\" class=\"axpc_FUNC\" data-function=\"func_switch_spuit\"\n                    data-msg=\"@PEN0054\"></button>\n            </div>\n        </div>\n    </div>\n</div>";

/***/ }),

/***/ "./src/html/window_tool.txt":
/*!**********************************!*\
  !*** ./src/html/window_tool.txt ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = "<!-- 補助ツール -->\n<div class=\"axpc_window_content\">\n    <!-- 補助ツールメイン -->\n    <div id=\"axp_tool_div_content\">\n        <!-- 補助ツール左側 -->\n        <div id=\"axp_tool_div_leftSide\">\n            <div id=\"axp_tool_div_canvasSize\">\n                <span id=\"axp_tool_span_canvasSize\" class=\"axpc_MSG\" data-msg=\"@AST0001\"></span>\n            </div>\n            <div id=\"axp_tool_div_minimap_outer\" class=\"axpc_MSG\" data-msg=\"@AST0002\">\n                <div id=\"axp_tool_div_minimap_line\" class=\"axpc_NONE\"></div>\n                <div id=\"axp_tool_div_minimap_inner\">\n                    <canvas id=\"axp_tool_canvas_minimap\" class=\"axpc_background_mesh\"></canvas>\n                </div>\n            </div>\n\n            <button id=\"axp_tool_button_loupeDown\" class=\"axpc_FUNC axpc_button\" data-function=\"func_loupe_down\"\n                data-msg=\"@AST0003\">-</button>\n            <button id=\"axp_tool_button_loupeReset\" class=\"axpc_FUNC axpc_button\" data-function=\"func_loupe_reset\"\n                data-msg=\"@AST0004\">100%</button>\n            <button id=\"axp_tool_button_loupeUp\" class=\"axpc_FUNC axpc_button\" data-function=\"func_loupe_up\"\n                data-msg=\"@AST0005\">+</button>\n        </div>\n        <!-- 補助ツール右側 -->\n        <div id=\"axp_tool_div_rightSide\">\n            <button id=\"axp_tool_button_undo\" class=\"axpc_FUNC axpc_button\" data-function=\"func_undo\"\n                data-msg=\"@AST0006\">${_(\"@MISC.BUTTON_UNDO\")}(0)</button>\n            <button id=\"axp_tool_button_redo\" class=\"axpc_FUNC axpc_button\" data-function=\"func_redo\"\n                data-msg=\"@AST0007\">${_(\"@MISC.BUTTON_REDO\")}(0)</button>\n            <button id=\"axp_tool_button_restore\" class=\"axpc_FUNC axpc_button\" data-function=\"func_restore\"\n                data-msg=\"@AST0008\">${_(\"@MISC.BUTTON_RESTORE_AUTOSAVE\")}</button>\n\n            <button id=\"axp_tool_button_save\" class=\"axpc_FUNC axpc_button\" data-function=\"func_save\"\n                data-msg=\"@AST0009\">${_(\"@MISC.BUTTON_SAVE\")}</button>\n            <button id=\"axp_tool_button_load\" class=\"axpc_FUNC axpc_button\" data-function=\"func_load\"\n                data-msg=\"@AST0010\">${_(\"@MISC.BUTTON_LOAD\")}</button>\n\n            <button id=\"axp_tool_button_flipH\" class=\"axpc_FUNC axpc_button\" data-function=\"func_flip_h\"\n                data-msg=\"@AST0011\">${_(\"@MISC.BUTTON_FLIP_H\")}</button>\n            <button id=\"axp_tool_button_flipV\" class=\"axpc_FUNC axpc_button\" data-function=\"func_flip_v\"\n                data-msg=\"@AST0012\">${_(\"@MISC.BUTTON_FLIP_V\")}</button>\n\n            <button id=\"axp_tool_button_transparent\" class=\"axpc_FUNC axpc_button\" data-function=\"func_transparent\"\n                data-msg=\"@AST0013\">${_(\"@MISC.BUTTON_BG_ALPHA\")}</button>\n            <div id=\"axp_tool_div_gridbutton\">\n                <button id=\"axp_tool_button_grid\" class=\"axpc_FUNC axpc_button\" data-function=\"func_grid\"\n                    data-msg=\"@AST0014\">${_(\"@MISC.BUTTON_GRID\")}</button>\n                <button id=\"axp_tool_button_gridConfig\" class=\"axpc_MSG axpc_button\" data-msg=\"@AST0015\"></button>\n            </div>\n        </div>\n    </div>\n    <!-- 補助線設定サブメニュー -->\n    <div id=\"axp_tool_div_gridConfig\" class=\"axpc_NONE\">\n        <!-- 主線副線斜め -->\n        <div>\n            <!-- 左側のボタン -->\n            <div>\n                <!-- 主線 -->\n                <div class=\"axpc_tool_div_gridConfigButton\">\n                    <div>\n                        <div>${_(\"@GRID.MAIN\")}</div>\n                    </div>\n                    <div id=\"axp_tool_checkbox_gridVH\" class=\"axpc_MSG axpc_toggle_switch axp_grid_switch\"\n                        data-msg=\"@AST0103\">\n                        <input type=\"checkbox\" name=\"check\" checked />\n                    </div>\n                    <div id=\"axp_tool_color_gridVH\" class=\"axpc_MSG axpc_colorRect axp_common_inputcolor\"\n                        data-msg=\"@AST0104\" style=\"background-color: #000000\" data-colorcode=\"#00000066\"></div>\n                </div>\n                <!-- 副線 -->\n                <div class=\"axpc_tool_div_gridConfigButton\">\n                    <div>\n                        <div>${_(\"@GRID.SUB\")}</div>\n                    </div>\n                    <div id=\"axp_tool_checkbox_gridSubDivision\" class=\"axpc_MSG axpc_toggle_switch axp_grid_switch\"\n                        data-msg=\"@AST0105\">\n                        <input type=\"checkbox\" name=\"check\" checked />\n                    </div>\n                    <div id=\"axp_tool_color_gridSubDivision\" class=\"axpc_MSG axpc_colorRect axp_common_inputcolor\"\n                        data-msg=\"@AST0106\" style=\"background-color: #000000\" data-colorcode=\"#00000026\"></div>\n                </div>\n                <!-- 斜め -->\n                <div class=\"axpc_tool_div_gridConfigButton\">\n                    <div>\n                        <div>${_(\"@GRID.DIAG\")}</div>\n                    </div>\n                    <div id=\"axp_tool_checkbox_gridDiagonal\" class=\"axpc_MSG axpc_toggle_switch axp_grid_switch\"\n                        data-msg=\"@AST0107\">\n                        <input type=\"checkbox\" name=\"check\" />\n                    </div>\n                    <div id=\"axp_tool_color_gridDiagonal\" class=\"axpc_MSG axpc_colorRect axp_common_inputcolor\"\n                        data-msg=\"@AST0108\" style=\"background-color: #ff0000\" data-colorcode=\"#ff000066\"></div>\n                </div>\n            </div>\n            <!-- 右側のスライダー -->\n            <div>\n                <!-- 分割数スライダー ※縦横連動のためaxpc_SAVE対象外 -->\n                <div>\n                    <form id=\"axp_tool_form_gridH\" class=\"axpc_range axpc_text_border\"\n                        oninput=\"result.value=parseInt(volume.value)\">\n                        <input type=\"range\" id=\"axp_tool_range_gridH\" name=\"volume\" min=\"2\" max=\"16\" value=\"6\"\n                            class=\"axpc_MSG\" data-msg=\"@AST0100\">\n                        <div class=\"axpc_range_label\">${_(\"@GRID.DIVISIONS_H\")}</div>\n                        <div class=\"axpc_range_value\"><output name=\"result\">6</output></div>\n                    </form>\n                    <form id=\"axp_tool_form_gridV\" class=\"axpc_range axpc_text_border\"\n                        oninput=\"result.value=parseInt(volume.value)\">\n                        <input type=\"range\" id=\"axp_tool_range_gridV\" name=\"volume\" min=\"2\" max=\"16\" value=\"6\"\n                            class=\"axpc_MSG\" data-msg=\"@AST0101\">\n                        <div class=\"axpc_range_label\">${_(\"@GRID.DIVISIONS_V\")}</div>\n                        <div class=\"axpc_range_value\"><output name=\"result\">6</output></div>\n                    </form>\n                    <div class=\"axpc_checkbox axpc_MSG\" data-msg=\"@AST0102\">\n                        <label>\n                            <input id=\"axp_tool_checkbox_gridVHLink\" class=\"axpc_SAVE\" type=\"checkbox\"\n                                checked>${_(\"@GRID.CONSTRAIN\")}\n                        </label>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- ピクセル単位指定１ -->\n        <div class=\"axpc_tool_div_gridConfigButton\">\n            <div>\n                <div>px(1)</div>\n            </div>\n            <div id=\"axp_tool_checkbox_gridPixel1\" class=\"axpc_MSG axpc_toggle_switch axp_grid_switch\"\n                data-msg=\"@AST0109\">\n                <input type=\"checkbox\" name=\"check\" />\n            </div>\n            <div id=\"axp_tool_color_gridPixel1\" class=\"axpc_MSG axpc_colorRect axp_common_inputcolor\"\n                data-msg=\"@AST0110\" style=\"background-color: #0000ff\" data-colorcode=\"#0000ff66\">\n            </div>\n            <div>\n                <input type=\"number\" id=\"axp_tool_number_gridPixel1\" class=\"axpc_MSG\" data-msg=\"@AST0111\" min=\"1\"\n                    max=\"100\" value=\"10\" maxlength=\"3\">\n                <span>px</span>\n            </div>\n        </div>\n        <!-- ピクセル単位指定２ -->\n        <div class=\"axpc_tool_div_gridConfigButton\">\n            <div>\n                <div>px(2)</div>\n            </div>\n            <div id=\"axp_tool_checkbox_gridPixel2\" class=\"axpc_MSG axpc_toggle_switch axp_grid_switch\"\n                data-msg=\"@AST0112\">\n                <input type=\"checkbox\" name=\"check\" />\n            </div>\n            <div id=\"axp_tool_color_gridPixel2\" class=\"axpc_MSG axpc_colorRect axp_common_inputcolor\"\n                data-msg=\"@AST0113\" style=\"background-color: #0000ff\" data-colorcode=\"#0000ff26\">\n            </div>\n            <div>\n                <input type=\"number\" id=\"axp_tool_number_gridPixel2\" class=\"axpc_MSG\" data-msg=\"@AST0114\" min=\"1\"\n                    max=\"100\" value=\"1\" maxlength=\"3\">\n                <span>px</span>\n            </div>\n        </div>\n    </div>\n</div>";

/***/ }),

/***/ "./src/text/msg.txt":
/*!**************************!*\
  !*** ./src/text/msg.txt ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = "@BAS0001,キャンバス：絵を描くメイン画面です。\n@BAS0002,設定：各種機能をカスタマイズできます。\n@BAS0003,投稿：描いたイラストを掲示板に投稿します。\n@BAS0004,拡張機能：ユーザーにより定義された拡張機能を実行します。\n@BAS0005,お知らせ領域です。文章が見切れる場合、クリックし続けると全文表示します。\n@BAS0006,機能解説などのガイドメッセージが表示されるエリアです。\n@BAS0100,デバッグ情報です。非表示にするには[設定]-[バージョン情報]-[デバッグ情報表示]のチェックを外してください。\n@LAU0001,一時的にすべてのウィンドウを非表示にします。\n@PEN0001,現在選択しているペンの名前が表示されます。\n@PEN0002,ペンの不透明度を変更します。0に近づくほど透明になります。\n@PEN0003,ペンの太さを変更します。\n@PEN0004,境界付近の塗り残しドットを目立たなくします。数字が大きいほど強く補正します。\n@PEN0005,グラデーションの向きを角度で指定します。\n@PEN0006,トーン濃度を指定します。数字が大きいほど濃くなります。\n@PEN0007,図形描画モードを選択できます。\n@PEN0008,「囲まれた領域」の判定方式を選択できます。（全ﾚｲﾔｰ判定を指定すると表示見たままで塗分けができます）\n@PEN0009,ぼかしの強さを指定します。数字が大きいほど描画する線がぼやけます。\n@PEN0010,外側の角の丸さを指定します。50で正円になります。\n@PEN0050,%1%2 [ 再選択 ]:ペン種別変更。\n@PEN0051,%1%2 [ 再選択 ]:消しゴム種別変更。\n@PEN0052,%1%2 [ 再選択 ]:バケツ種別変更。\n@PEN0053,%1%2 [ 再選択 ]:ツール種別変更。\n@PEN0054,%1スポイト：指定座標の色を取得し、描画色（%drawingColorName）に設定します。[ CTRL ]:押している間スポイトに変化。\n@PEN0100,%1丸ペン：一定の太さの線が描けるペン。[ SHIFT ]:直線描画。\n@PEN0101,%1角ペン：先が四角い線が描けるペン。[ SHIFT ]:直線描画。\n@PEN0102,%1ドットペン：ドット絵調の線が描けるペン。[ SHIFT ]:直線描画。\n@PEN0103,%1筆ペン：強弱のついた線が描けるペン。\n@PEN0104,%1クレヨン：クレヨン風の塗りができるペン。[ SHIFT ]:直線描画。\n@PEN0105,%1エアブラシ：エアブラシ風の塗りができるペン。\n@PEN0110,%1消しゴム：辺が丸い消しゴム。[ SHIFT ]:直線描画。\n@PEN0111,%1角消しゴム：辺が四角い消しゴム。[ SHIFT ]:直線描画。\n@PEN0120,%1バケツ：囲まれた領域の内側を塗り潰します。\n@PEN0121,%1階調バケツ：メインカラーとサブカラーのグラデーションで、囲まれた領域の内側を塗り潰します。\n@PEN0130,%1ハンド：ドラッグでキャンバスの位置を移動します。[ SPACE ]:押している間ハンドに変化。\n@PEN0131,%1移動ツール：画像を上下左右に移動するツール（現在のレイヤーのみ対象）\n@PEN0200,%penPreviewGuide\n@PEN0201,%1のプレビュー。枠内をクリックまたはドラッグで太さを変更します。\n@PEN0202,%1の色プレビュー。\n@PEN0203,%1の色プレビュー。枠内をドラッグで角度を変更します。\n@PEN0204,ポインタ座標の画像を拡大表示します。赤枠の色がスポイトで取得されます。\n@PLT0001,カラーパレットの列数を変更します。∞を指定すると常に１行になります。\n@PLT0002,パレットの更新／位置入れ替え／削除を行うモードに切り替えます。\n@PLT0003,%addPaletteNameの色をカラーパレットに登録します。\n@PLT0004,選択しているパレットを削除します。\n@LAY0001,レイヤーの合成モードを変更します。詳細はマニュアルを参照してください。\n@LAY0002,現在のレイヤーの不透明度を変更します。0を指定すると完全に透明になります。\n@LAY0003,%1現在のレイヤーは残したまま、描画内容だけを消去します。\n@LAY0004,%1新しいレイヤーを作成します。（最大８枚まで）\n@LAY0005,%1現在のレイヤーを１つ下のレイヤーに統合します。統合後は不透明度が100%に調整されます。\n@LAY0006,%1現在のレイヤーのコピーを作成します。\n@LAY0007,%1現在のレイヤーを削除します。\n@LAY0008,描画するレイヤーを選択します。\n@LAY0100,レイヤー情報サブウィンドウを閉じます。\n@LAY0101,レイヤー名を変更する場合、ここに新しい名前を入力します。（10文字まで）\n@LAY0102,レイヤーに付与した色を解除します。（レイヤー名は変更されません）\n@LAY0110,レイヤー単体を左右反転します。\n@LAY0111,レイヤー単体を上下反転します。\n@MKC0001,%1描画色をメインカラーに切り替えます。\n@MKC0002,%1描画色をサブカラーに切り替えます。一部の機能で補助的に使用します。%2\n@MKC0003,%1描画色を透明色に切り替えます。%2\n@MKC0004,カラーコードを直接入力してメインカラーを変更します。\n@MKC0005,%addPaletteNameの色をカラーパレットに登録します。\n@MKC0006,メインカラーとサブカラーを入れ替えます。\n@MKC0007,%drawingColorNameの赤成分を変更します。(0～255)\n@MKC0008,赤成分を数値入力します。(0～255)\n@MKC0009,%drawingColorNameの緑成分を変更します。(0～255)\n@MKC0010,緑成分を数値入力します。(0～255)\n@MKC0011,%drawingColorNameの青成分を変更します。(0～255)\n@MKC0012,青成分を数値入力します。(0～255)\n@MKC0013,%drawingColorNameの色をカラーピッカーで変更します。\n@AST0001,キャンバスの大きさ。（※設定で変更可能）\n@AST0002,サムネイル表示。枠内をクリックまたはドラッグでキャンバスの位置を移動します。\n@AST0003,%1拡大率を１段階縮小します。\n@AST0004,%1拡大率とキャンバス位置をリセットします。\n@AST0005,%1拡大率を１段階拡大します。\n@AST0006,%1直前の描画を取消して元に戻します。ボタンの数字の回数だけ遡れます。\n@AST0007,%1アンドゥを取消します。ボタンの数字の回数だけ遡れます。\n@AST0008,%1自動バックアップから復元ポイントを選んで再開します。（※現在の描画内容は消去されます）\n@AST0009,%1描画内容をブラウザに一時保存し、復元ポイントを作成します。\n@AST0010,%1作成した復元ポイントから再開します（※現在の描画内容は消去されます）\n@AST0011,%1全レイヤーを左右反転します。\n@AST0012,%1全レイヤーを上下反転します。\n@AST0013,%1背景色の白地/透明色を切り替えます。（※投稿画像に反映されます）\n@AST0014,%1補助線のON/OFFを切り替えます。\n@AST0015,補助線の詳細設定ウィンドウを開閉します。\n@AST0100,補助線の横方向の分割数を変更します。\n@AST0101,補助線の縦方向の分割数を変更します。\n@AST0102,縦横の分割数の変更を連動させて同じ値にします。\n@AST0103,補助線（主線）の使用を切り替えます。分割数に応じた格子状の線を引きます。\n@AST0104,補助線（主線）の色と不透明度を変更します。\n@AST0105,補助線（副線）の使用を切り替えます。主線の内部を細分する線を引きます。\n@AST0106,補助線（副線）の色と不透明度を変更します。\n@AST0107,補助線（斜め）の使用を切り替えます。分割数に応じた斜線を引きます。\n@AST0108,補助線（斜め）の色と不透明度を変更します。\n@AST0109,補助線（ピクセル指定１）の使用を切り替えます。※表示に適さない拡大率の時、自動的に非表示になります。\n@AST0110,補助線（ピクセル指定１）の色と不透明度を変更します。\n@AST0111,補助線（ピクセル指定１）のピクセル間隔を変更します。\n@AST0112,補助線（ピクセル指定２）の使用を切り替えます。※表示に適さない拡大率の時、自動的に非表示になります。\n@AST0113,補助線（ピクセル指定２）の色と不透明度を変更します。\n@AST0114,補助線（ピクセル指定２）のピクセル間隔を変更します。\n@AST0120,補助線の色を変更します。\n@AST0121,補助線の不透明度を変更します。\n@AST0122,変更を終了して、サブメニューを閉じます。\n@POS0001,お絵カキコを投稿します。\n@CFG0010,現在のポインタ座標を表示します。（位置：左下）\n@CFG0016,過去に使用したキャンバスサイズの履歴です。直近8件まで保存されます。\n@CFG0017,新規キャンバスを作成します。（現在の描画内容はすべて消去されます）\n@CFG0018,現在の描画内容を残したまま、キャンバスのサイズを変更します。\n@CFG0019,描画内容をPNG形式ファイルとしてダウンロードします。ファイル名は現在日時が付与されます。\n@CFG0020,ぼかし（アンチエイリアシング）を無効にします。（ドット絵がボケなくなります）\n@CFG0021,ぼかし（アンチエイリアシング）を有効にします。\n@CFG0022,現在のポインタ座標を表示しません。\n@CFG0023,現在のポインタ座標を表示します。（位置：左上）\n@CFG0024,現在のポインタ座標を表示します。（位置：右上）\n@CFG0025,現在のポインタ座標を表示します。（位置：右下）\n@CFG0026,ツール起動時、ウィンドウ配置を毎回初期化します。\n@CFG0027,ツール起動時、ウィンドウ配置を前回終了時の位置に復元します。\n@CFG0028,ウィンドウ位置の自動調整を行いません。\n@CFG0029,ブラウザの画面サイズを変更したとき、ウィンドウが画面内に収まるように自動調整を行います。\n@CFG0030,すべてのツールウィンドウの配置を初期状態に戻します。\n@CFG0034,ツール起動時、ペンの太さ、不透明度などを毎回初期化します。\n@CFG0035,ツール起動時、ペンの太さ、不透明度などを前回終了時の値に復元します。\n@CFG0036,アイコンボタンのサイズを変更します。\n@CFG0037,ウィンドウを開く際に、他のウィンドウが自動的に閉じるようになります。一括開閉ボタンは無効になります。\n@CFG0040,全ペン共通の手ぶれ補正の強さを変更します。数値が大きいほど強い補正がかかります。0を指定すると補正を行いません。\n@CFG0041,ペンツールウィンドウ内にレンジスライダーを表示して、キャンバス画面でも手ぶれ補正を変更できるようにします。\n@CFG0043,自動切換機能を使用しません。\n@CFG0044,スポイトで色を取得した時、自動的にペンに切り替えます。\n@CFG0045,長押しスポイト機能を使用しません。\n@CFG0046,キャンバス上の取得したい色の位置で、ペン（またはマウスクリック）を長押しすることでスポイトが動作します。\n@CFG0047,長押し入力として認識するために、押し続ける必要がある時間を設定します。1000ミリ秒=１秒\n@CFG0048,長押し入力時に許容する手ぶれの範囲を設定します。数値が大きいほど長押しが認識されやすくなりますが、通常描画に影響がでます。\n@CFG0049,トーン濃度レンジスライダーを使用しません。\n@CFG0050,トーン濃度レンジスライダーをペンツールに追加します。\n@CFG0051,太さレンジスライダーを上に表示します。\n@CFG0052,不透明度レンジスライダーを上に表示します。\n@CFG0053,混色パレットを使用しません。\n@CFG0054,混色パレットを使用します。\n@CFG0055,RGBスライダーを使用しません。\n@CFG0056,光の三原色（赤、緑、青）強さを指定して色作成するスライダーを使用します。\n@CFG0057,カラーピッカーを使用しません。\n@CFG0058,HSV色空間（色相、彩度、明度）を指定するカラーピッカーを使用します。\n@CFG0059,ツール起動時、カラーパレットを毎回初期化します。\n@CFG0060,ツール起動時、カラーパレットを前回終了時の色に復元します。\n@CFG0062,パレット編集モード時にレンジスライダーを表示して、キャンバス画面でも横幅を変更できるようにします。\n@CFG0063,カラーパレットの列数を変更します。∞を指定すると常に１行になります。\n@CFG0064,現在のカラーパレットの内容をテキストファイルとしてダウンロードします。\n@CFG0065,色保存で作成したテキストファイルを読み込み、カラーパレットを更新します。\n@CFG0066,カラーパレットを初期状態に戻します。\n@CFG0067,アンドゥ／リドゥの可能回数を変更します。メモリ不足で動作が不安定になる場合は値を小さく設定してください。\n@CFG0070,拡大率を追加します。\n@CFG0071,選択している拡大率を削除します。\n@CFG0072,拡大率を初期状態に戻します。\n@CFG0080,カスタムボタンを使用しません。\n@CFG0081,カスタムボタンツールウィンドウを画面に追加します。\n@CFG0082,ボタンに機能を割り当てません。\n@CFG0083,ボタンでアンドゥを実行します。\n@CFG0084,ボタンでスポイトを実行します。\n@CFG0085,ボタンを押しながらドラッグでキャンバスの位置を移動します。\n@CFG0086,ボタンで拡大率とキャンバス位置をリセットします。\n@CFG0087,ボタンでメインカラーとサブカラーを切り替えます。\n@CFG0088,ボタンでメインカラーと透明色を切り替えます。\n@CFG0089,ホイールに機能を割り当てません。\n@CFG0090,ホイールでキャンバスを拡大/縮小します。\n@CFG0091,ホイールでキャンバスの位置を移動します。\n@CFG0092,操作を無効にします。タッチペン使用時、指による誤描画を防止します。\n@CFG0093,１本指タッチで描画を行います。指で線を描くことができます。\n@CFG0094,１本指タッチでハンドツールを操作します。指でキャンバスを移動できます。\n@CFG0095,操作を無効にします。\n@CFG0096,２本指スワイプ操作でキャンバスの移動を行います。\n@CFG0097,操作を無効にします。\n@CFG0098,ピンチアウト／ピンチイン操作でキャンバスの拡大／縮小を行います。\n@CFG0099,操作を無効にします。\n@CFG0100,２本指タップ操作でアンドゥを行います。\n@CFG0101,操作を無効にします。\n@CFG0102,３本指タップ操作でリドゥを行います。\n@CFG0103,タップ入力として認識するために、触れた指を離すまでの制限時間を設定します。1000ミリ秒=１秒\n@CFG0108,１回のボタン操作でスクロールする量を設定します。\n@CFG0111,機能が割り当てられていないキーを省略します。非表示のキーに機能を割り当てる場合はチェックを外してください。\n@CFG0112,キーと割り当てられている機能の対応表です。セレクトボックスから機能を選んで割り当てを変更することができます。\n@CFG0113,現在のショートカット設定をテキストファイルとしてダウンロードします。\n@CFG0114,ショートカットファイルを読み込み、ショートカット設定を更新します。\n@CFG0115,ショートカット設定を初期状態に戻します。\n@CFG0120,合成モードを表示しません。\n@CFG0121,合成モードをレイヤー名の下に表示します。\n@CFG0122,合成モードをレイヤー名の下に表示します。（合成モードが通常の場合は表示を省略します）\n@CFG0123,登録されているレイヤー名を変更します。（最大8文字）\n@CFG0124,登録されているレイヤー名を初期状態にリセットします。\n@CFG0200,ぼかし度レンジスライダーを使用しません。\n@CFG0201,ぼかし度レンジスライダーをペンツールに追加します。\n@CFG0211,追加する拡大率を入力します。\n@CFG0212,現在設定されている拡大率の一覧です。クリックで拡大率を選択します。\n@CFG0220,マウスホイールの回転方向を反転して入力を受け付けます。\n@CFG0221,１回のホイール操作でスクロールする量を設定します。\n@CFG0222,連続してマウスホイールを回転させた時、入力を抑止する時間を設定します。1000ミリ秒=１秒\n@CFG0223,マウスポインタの位置を参照し、キャンバスの狙った位置を拡大／縮小できるようにします。\n@CFG0230,画面スクロールの向きを反転します。上スクロールは下スクロールに、左スクロールは右スクロールに変換されます。\n@CFG0300,キャンバスの幅（横のサイズ）を入力します。（下のボタンで変更を確定します）\n@CFG0301,キャンバスの高さ（縦のサイズ）を入力します。（下のボタンで変更を確定します）\n@CFG0400,選択中のペンを使って透明色で描画します。（描画中だけ透明色に切り替わります）\n@CFG0401,タップ入力時に許容する手ぶれの範囲を設定します。\n@CFG2001,キャンバス全般に関する設定を行います。\n@CFG2002,ツールウィンドウ全般に関する設定を行います。\n@CFG2003,ペンツールの機能設定を行います。\n@CFG2004,色作成の機能設定を行います。\n@CFG2005,パレットの機能設定を行います。\n@CFG2006,レイヤーの機能設定を行います。\n@CFG2007,補助ツールの機能設定を行います。\n@CFG2008,カスタムボタンの機能設定を行います。\n@CFG2009,マウス／タッチパッド（トラックパッド）の設定を行います。\n@CFG2010,タッチパネルの設定を行います。\n@CFG2011,キーボードのキーコンフィグなどの設定を行います。\n@CFG2013,AXNOS Paint起動時の設定を行います。\n@CFG2020,バージョン情報を表示します。\n@COL0001,%drawingColorName RGB:(%1)\n@COL0002,透明色\n@COL0003,メインカラー RGB:(%1) / サブカラー (%2)\n@COL0004,混色パレット(%1%) RGB:(%2)\n@AXP0001,拡大率：%1%\n@AXP0003,%1の不透明度：%2\n@AXP0004,補助線分割数 横：%1 / 縦：%2\n@AXP0010,%1ペン／消しゴム切替(%2)\n@AXP2000,描画色を混色パレット(%1%)に変更します。RGB:(%2)\n@AXP3000,[編集モード] ドラッグで位置を入れ替え。色作成ウィンドウで選択中パレットの色を更新。\n@AXP3001,%drawingColorNameを指定色に変更します。RGB:(%1)\n@AXP4000,レイヤーの%1を切り替えます。(現在の状態:%2)\n@AXP4001,ドラッグで表示順序を入れ替え。ダブルクリックでレイヤー名変更。\n@AXP4010,レイヤー名の変更を決定して、サブメニューを閉じます。\n@AXP4012,登録された名前に変更し、色を付与します。\n@AXP4013,新しいレイヤー名を入力してください。\n@AXP5000,%1の太さ：%2\n@AXP5001,%1の不透明度：%2\n@AXP5002,%1の塗り残し補正：%2\n@AXP5003,%1の角度：%2\n@AXP5004,%1のトーン濃度：%2\n@AXP5005,[ CTRL ]: 押している間、ペンがスポイトに変化します。\n@AXP5006,[ SPACE ]: 押している間、ペンがハンドに変化します。\n@AXP5007,%1押している間、その場でペンの太さレンジスライダーを操作できます。\n@AXP5008,%1のぼかし度：%2\n@AXP5009,%1の丸み：%2\n@AXP5010,ペンツールの種別選択中です。\n@INF0001,%1は透明部分をロックしています。既に描画されている部分のみ上書き描画できます。\n@INF0002,拡大率とキャンバスの位置をリセットしました。\n@INF0003,ツールウィンドウの位置を初期化しました。\n@INF0005,背景のタイルプレビューを切り替えました。(現在の状態:%1)\n@INF0006,%1を全面塗り潰ししました。\n@INF0007,%1を90°回転しました。\n@INF0008,%1はクリッピングです。描画内容は%2の形に切り抜かれます。\n@INF0009,キャンバス全体のぼかしを切り替えました。(現在の状態:%1)\n@INF0050,[ %1 ]を読み込みました。(画像サイズ 横:%2 × 縦:%3)\n@INF0100,拡大率%1%を追加しました。\n@INF0101,拡大率%1%を削除しました。\n@INF0300,スロット%1にセーブしました。\n@INF0301,スロット%1をロードしました。\n@INF0302,自動保存されたデータをロードしました。\n@INF0400,%1をアンドゥしました。（残り回数：%2）\n@INF0401,%1をリドゥしました。（残り回数：%2）\n@INF1000,全レイヤーの左右を反転しました。\n@INF1001,選択中レイヤーの左右を反転しました。\n@INF1002,全レイヤーの上下を反転しました。\n@INF1003,選択中レイヤーの上下を反転しました。\n@INF1004,補助線の表示を切り替えました。（現在の状態:%1）\n@INF1005,背景を切り替えました。（現在の状態:%1）\n@INF2000,カラーコードの入力を受け付けました。%1 / RGB:(%2)\n@INF3000,パレット編集モードに切り替えました。（パレットの更新／位置入れ替え／削除が行えます）\n@INF3001,パレット編集モードを解除しました。\n@INF3002,カラーパレットを削除しました。\n@INF3003,カラーパレットを登録しました。RGB:(%1)\n@INF4000,%1をクリアしました。\n@INF4001,%1を作成しました。\n@INF4002,%1を複製して、%2を作成しました。\n@INF4003,%1を削除しました。\n@INF4004,%1と%2を統合しました。\n@INF4005,レイヤー名を[%1]に変更しました。\n@INF4006,レイヤーの%1を切り替えました。(現在の状態:%2)\n@INF4008,カラータグ名を[%1]に変更しました。\n@INF4009,レイヤーに付与した色を解除しました。\n@CAU0001,%1が%2のため、描画を禁止しています。\n@CAU0002,[ %1 ]キーには機能が割り当てられていません。（※設定で変更可能）\n@CAU0003,%1が%2のため、全面塗り潰しできません。\n@CAU0004,全面塗り潰しを使用する際は、ペン、消しゴム、バケツのいずれかを選択した状態にしてください。\n@CAU0005,%1が%2のため、90°回転できません。\n@CAU0006,%1の下層に親レイヤーが存在しないため、クリッピングが無効になっています。\n@CAU0100,追加できる拡大率は%1個までです。\n@CAU0101,拡大率%1%は既に追加されています。\n@CAU0102,追加できる拡大率は%1～%2%です。\n@CAU0103,削除する拡大率が選択されていません。\n@CAU0104,拡大率100%は変更できません。\n@CAU0200,%1の不透明度は変更できません。\n@CAU0201,%1の不透明度は100が最大値です。\n@CAU0202,%1の不透明度は5が最小値です。\n@CAU0203,%1の太さは変更できません。\n@CAU0204,%1の太さは200が最大値です。\n@CAU0205,%1の太さは1が最小値です。\n@CAU0206,補助線が表示されているときに有効なショートカットです。\n@CAU0300,現在セーブ/ロード機能は使用できません。ヘルプをご確認下さい。\n@CAU0301,スロット%1にはデータがありません。\n@CAU0400,これ以上アンドゥできません。\n@CAU0401,これ以上リドゥできません。\n@CAU0500,%1は透明色を使用できません。\n@CAU2000,カラーコードが正しくありません。入力例：#ffffff または #fff（#は省略可）\n@CAU3000,すべてのパレットを削除することはできません。\n@CAU3001,登録できるパレット数は%1個までです。\n@CAU4000,%1がロック状態のため、クリアできません。\n@CAU4001,%1は空白のレイヤーです。\n@CAU4002,レイヤーは%1枚までです。\n@CAU4003,%1がロック状態のため、削除できません。\n@CAU4004,レイヤーをすべて削除することはできません。\n@CAU4005,最下層のレイヤーは統合できません。\n@CAU4006,%1が%2のため、統合できません。\n@CAU4007,レイヤー名を空白にすることはできません。\n@CAU4008,カラータグ名を空白にすることはできません。\n@CAU5000,[ CTRL ]キーでスポイトに変化中です。別のペンは選択できません。\n@CAU5001,[ SPACE ]キーでハンドに変化中です。別のペンは選択できません。\n@CAU5002,スポイトを使用するにはキャンバス内を指定してください。";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_axpobj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./js/axpobj.js */ "./src/js/axpobj.js");
/* harmony import */ var _js_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/lang.js */ "./src/js/lang.js");
/* harmony import */ var _js_alert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/alert.js */ "./src/js/alert.js");
/* harmony import */ var _js_etc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./js/etc.js */ "./src/js/etc.js");
/* harmony import */ var _html_main_txt__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./html/main.txt */ "./src/html/main.txt");
/*
 * AXNOS Paint
 * (c) 2022「悪の巣」部屋番号13番：「趣味の悪い大衆酒場[Mad end dance hall]」
 * Licensed under MPL 2.0
 */






// htmlデータ

// css適用
__webpack_require__(/*! ./css/axnospaint.css */ "./src/css/axnospaint.css");
__webpack_require__(/*! ./css/common.css */ "./src/css/common.css");
__webpack_require__(/*! ./css/icon.css */ "./src/css/icon.css");
__webpack_require__(/*! ./css/window.css */ "./src/css/window.css");
__webpack_require__(/*! ./css/saveload.css */ "./src/css/saveload.css");
__webpack_require__(/*! ./css/input_range.css */ "./src/css/input_range.css");
__webpack_require__(/*! ./css/input_radio.css */ "./src/css/input_radio.css");
__webpack_require__(/*! ./css/input_checkbox.css */ "./src/css/input_checkbox.css");
__webpack_require__(/*! ./css/input_number.css */ "./src/css/input_number.css");
__webpack_require__(/*! ./css/input_button.css */ "./src/css/input_button.css");
__webpack_require__(/*! ./css/input_toggle.css */ "./src/css/input_toggle.css");
__webpack_require__(/*! ./css/alert.css */ "./src/css/alert.css");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (class {
    axpObj;
    constructor(option) {
        console.log('version:', "2.4.0");
        console.log('build:', "2026-01-11T10:33:35.901Z");
        (async () => {
            // 追加辞書オプションチェック
            let additionalDictionaryJSON = null;
            if (typeof option.dictionary !== 'undefined') {
                // 辞書オプションにnull以外の値が指定されている場合、そのファイルのfetchを試みる。
                if (option.dictionary !== null) {
                    let result = await (0,_js_lang_js__WEBPACK_IMPORTED_MODULE_1__.getDictionaryJSON)(option.dictionary);
                    if (result === 'NOT_FOUND') {
                        alert(`ERROR:起動オプションdictionaryで指定されたファイル\n[ ${option.dictionary} ] が見つかりません。\n通常辞書で起動します。`);
                    } else if (result === 'SYNTAX_ERROR') {
                        alert(`ERROR:起動オプションdictionaryで指定されたファイル\n[ ${option.dictionary} ] に問題があります。\n通常辞書で起動します。`);
                    } else {
                        additionalDictionaryJSON = result;
                    }
                }
            }

            // ツール基幹インスタンス作成
            this.axpObj = new _js_axpobj_js__WEBPACK_IMPORTED_MODULE_0__.AXPObj(additionalDictionaryJSON);

            // 使用辞書情報表示
            console.log('Dictionary:', this.axpObj._('@LANGUAGE'));

            // 起動オプションチェック
            if (typeof option.bodyId === 'undefined') {
                alert('ERROR:起動オプションbodyIdが指定されていません');
                return;
            }
            this.axpObj.paintBodyElement = document.getElementById(option.bodyId);
            if (this.axpObj.paintBodyElement === null) {
                alert('ERROR:起動オプションbodyIdの指定が正しくありません');
                return;
            }
            // スタイル設定
            this.axpObj.paintBodyElement.style.display = 'flex';
            this.axpObj.paintBodyElement.style.flexGrow = '1';
            this.axpObj.paintBodyElement.style.flexDirection = 'column';
            this.axpObj.paintBodyElement.style.overflow = 'hidden';

            // 投稿用プログラムの定義
            this.axpObj.FUNCTION.post = option.post || null;
            // 同一掲示板チェックの有効化
            this.axpObj.checkSameBBS = option.checkSameBBS || false;
            // お絵カキコデータ（基にしてお絵カキコする用）が存在するURL
            this.axpObj.oekakiURL = option.oekakiURL || null;
            // 下書き機能画像ファイル名
            this.axpObj.draftImageFile = option.draftImageFile || null;
            // お絵カキコデータ読込タイムアウト時間
            this.axpObj.oekakiTimeout = isNaN(option.oekakiTimeout) ? 15000 : option.oekakiTimeout;

            // 許容するキャンバスサイズ
            // 起動オプション指定がある場合、コンストラクタで設定済みのデフォルト値を上書き
            if (typeof option.minWidth === 'number') {
                if ((0,_js_etc_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(option.minWidth, this.axpObj.CONST.MIN_SYSTEM_WIDTH, this.axpObj.CONST.MAX_SYSTEM_WIDTH)) {
                    this.axpObj.minWidth = option.minWidth;
                } else {
                    alert(`ERROR:\n起動オプションminWidthの指定が正しくありません。\n有効範囲は${this.axpObj.CONST.MIN_SYSTEM_WIDTH}～${this.axpObj.CONST.MAX_SYSTEM_WIDTH}です。`);
                    return;
                }
            }
            if (typeof option.minHeight === 'number') {
                if ((0,_js_etc_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(option.minHeight, this.axpObj.CONST.MIN_SYSTEM_HEIGHT, this.axpObj.CONST.MAX_SYSTEM_HEIGHT)) {
                    this.axpObj.minHeight = option.minHeight;
                } else {
                    alert(`ERROR:\n起動オプションminHeightの指定が正しくありません。\n有効範囲は${this.axpObj.CONST.MIN_SYSTEM_HEIGHT}～${this.axpObj.CONST.MAX_SYSTEM_HEIGHT}です。`);
                    return;
                }
            }
            if (typeof option.maxWidth === 'number') {
                if ((0,_js_etc_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(option.maxWidth, this.axpObj.CONST.MIN_SYSTEM_WIDTH, this.axpObj.CONST.MAX_SYSTEM_WIDTH)) {
                    this.axpObj.maxWidth = option.maxWidth;
                } else {
                    alert(`ERROR:\n起動オプションmaxWidthの指定が正しくありません。\n有効範囲は${this.axpObj.CONST.MIN_SYSTEM_WIDTH}～${this.axpObj.CONST.MAX_SYSTEM_WIDTH}です。`);
                    return;
                }
            }
            if (typeof option.maxHeight === 'number') {
                if ((0,_js_etc_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(option.maxHeight, this.axpObj.CONST.MIN_SYSTEM_HEIGHT, this.axpObj.CONST.MAX_SYSTEM_HEIGHT)) {
                    this.axpObj.maxHeight = option.maxHeight;
                } else {
                    alert(`ERROR:\n起動オプションmaxHeightの指定が正しくありません。\n有効範囲は${this.axpObj.CONST.MIN_SYSTEM_HEIGHT}～${this.axpObj.CONST.MAX_SYSTEM_HEIGHT}です。`);
                    return;
                }
            }
            // 論理チェック
            // console.log(
            //     this.axpObj.minWidth,
            //     this.axpObj.minHeight,
            //     this.axpObj.maxWidth,
            //     this.axpObj.maxHeight
            // );
            if (this.axpObj.minWidth > this.axpObj.maxWidth || this.axpObj.minHeight > this.axpObj.maxHeight) {
                alert(`ERROR:\n起動オプションminWidth,minHeight,maxWidth,maxHeightの指定の組み合わせが正しくありません。`);
                return;
            }

            // お絵カキコサイズ
            this.axpObj.option_height = option.height || null;
            this.axpObj.option_width = option.width || null;

            // 下書き機能使用時のキャンバスサイズ変更制限
            this.axpObj.restrictDraftCanvasResizing = option.restrictDraftCanvasResizing || false;

            // 投稿制限
            this.axpObj.restrictPost = option.restrictPost || false;

            // 拡張機能タブ
            this.axpObj.expansionTab = option.expansionTab || null;

            // 投稿フォームカスタマイズ
            let isErrorDetected = false;
            let errorMessage = null;
            // 判定関数
            const isBoolean = (value) => typeof value === 'boolean';
            const isText = (value) => typeof value === 'string';
            const isRangeLength = (value) => typeof value === 'number' && (0,_js_etc_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(value, 1, 1024);
            const checkOptionValue = (value, condition, message) => {
                // 正しい値が指定されているか判定
                if (condition(value)) {
                    return true;
                } else {
                    isErrorDetected = true;
                    errorMessage = `ERROR:\n起動オプションの指定が正しくありません。\nキー: ${message}\n値: ${value}`;
                    return false;
                }
            }
            if (typeof option.postForm !== 'undefined') {
                // 投稿フォーム
                if ('input' in option.postForm && !isErrorDetected) {
                    if ('isDisplay' in option.postForm.input && !isErrorDetected) {
                        if (checkOptionValue(
                            option.postForm.input.isDisplay,
                            isBoolean,
                            'postForm.input.isDisplay')) {
                            this.axpObj.postForm.input.isDisplay = option.postForm.input.isDisplay;
                        }
                    }
                    // 投稿者名
                    if ('strName' in option.postForm.input && !isErrorDetected) {
                        if ('isDisplay' in option.postForm.input.strName && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strName.isDisplay,
                                isBoolean,
                                'postForm.input.strName.isDisplay')) {
                                this.axpObj.postForm.input.strName.isDisplay = option.postForm.input.strName.isDisplay;
                            }
                        }
                        if ('isInputRequired' in option.postForm.input.strName && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strName.isInputRequired,
                                isBoolean,
                                'postForm.input.strName.isInputRequired')) {
                                this.axpObj.postForm.input.strName.isInputRequired = option.postForm.input.strName.isInputRequired;
                            }
                        }
                        if ('maxLength' in option.postForm.input.strName && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strName.maxLength,
                                isRangeLength,
                                'postForm.input.strName.maxLength')) {
                                this.axpObj.postForm.input.strName.maxLength = option.postForm.input.strName.maxLength;
                            }
                        }
                        if ('placeholder' in option.postForm.input.strName && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strName.placeholder,
                                isText,
                                'postForm.input.strName.placeholder')) {
                                this.axpObj.postForm.input.strName.placeholder = option.postForm.input.strName.placeholder;
                            }
                        }
                    }
                    // タイトル
                    if ('strTitle' in option.postForm.input && !isErrorDetected) {
                        if ('isDisplay' in option.postForm.input.strTitle && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strTitle.isDisplay,
                                isBoolean,
                                'postForm.input.strTitle.isDisplay')) {
                                this.axpObj.postForm.input.strTitle.isDisplay = option.postForm.input.strTitle.isDisplay;
                            }
                        }
                        if ('isInputRequired' in option.postForm.input.strTitle && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strTitle.isInputRequired,
                                isBoolean,
                                'postForm.input.strTitle.input.isInputRequired')) {
                                this.axpObj.postForm.input.strTitle.isInputRequired = option.postForm.input.strTitle.isInputRequired;
                            }
                        }
                        if ('maxLength' in option.postForm.input.strTitle && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strTitle.maxLength,
                                isRangeLength,
                                'postForm.input.strTitle.maxLength')) {
                                this.axpObj.postForm.input.strTitle.maxLength = option.postForm.input.strTitle.maxLength;
                            }
                        }
                        if ('placeholder' in option.postForm.input.strTitle && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strTitle.placeholder,
                                isText,
                                'postForm.input.strTitle.placeholder')) {
                                this.axpObj.postForm.input.strTitle.placeholder = option.postForm.input.strTitle.placeholder;
                            }
                        }
                    }
                    // 本文
                    if ('strMessage' in option.postForm.input && !isErrorDetected) {
                        if ('isDisplay' in option.postForm.input.strMessage && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strMessage.isDisplay,
                                isBoolean,
                                'postForm.input.strMessage.isDisplay')) {
                                this.axpObj.postForm.input.strMessage.isDisplay = option.postForm.input.strMessage.isDisplay;
                            }
                        }
                        if ('isInputRequired' in option.postForm.input.strMessage && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strMessage.isInputRequired,
                                isBoolean,
                                'postForm.input.strMessage.isInputRequired')) {
                                this.axpObj.postForm.input.strMessage.isInputRequired = option.postForm.input.strMessage.isInputRequired;
                            }
                        }
                        if ('maxLength' in option.postForm.input.strMessage && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strMessage.maxLength,
                                isRangeLength,
                                'postForm.input.strMessage.maxLength')) {
                                this.axpObj.postForm.input.strMessage.maxLength = option.postForm.input.strMessage.maxLength;
                            }
                        }
                        if ('placeholder' in option.postForm.input.strMessage && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strMessage.placeholder,
                                isText,
                                'postForm.input.strMessage.placeholder')) {
                                this.axpObj.postForm.input.strMessage.placeholder = option.postForm.input.strMessage.placeholder;
                            }
                        }
                    }
                    // ウォッチリスト登録
                    if ('strWatchList' in option.postForm.input && !isErrorDetected) {
                        if ('isDisplay' in option.postForm.input.strWatchList && !isErrorDetected) {
                            if (checkOptionValue(
                                option.postForm.input.strWatchList.isDisplay,
                                isBoolean,
                                'postForm.input.strWatchList.isDisplay')) {
                                this.axpObj.postForm.input.strWatchList.isDisplay = option.postForm.input.strWatchList.isDisplay;
                            }
                        }
                    }
                }
                // 注意事項
                if ('notice' in option.postForm && !isErrorDetected) {
                    if ('isDisplay' in option.postForm.notice && !isErrorDetected) {
                        if (checkOptionValue(
                            option.postForm.notice.isDisplay,
                            isBoolean,
                            'postForm.notice.isDisplay')) {
                            this.axpObj.postForm.notice.isDisplay = option.postForm.notice.isDisplay;
                        }
                    }
                }
            }
            // 起動オプションに誤りがある場合はエラーメッセージを表示して強制終了
            if (isErrorDetected) {
                alert(errorMessage);
                return;
            }

            // htmlを生成
            this.axpObj.paintBodyElement.insertAdjacentHTML('afterbegin', this.axpObj.translateHTML(_html_main_txt__WEBPACK_IMPORTED_MODULE_4__));

            let targetElements_tab = document.querySelectorAll('#axp_main_div_tab > div > div');
            // 投稿制限ありなら投稿タブは非表示
            if (this.axpObj.restrictPost) {
                targetElements_tab[2].style.display = 'none';
            }

            // 拡張機能タブ生成
            if (this.axpObj.expansionTab !== null) {
                // タブの名前
                if (this.axpObj.expansionTab.name) {
                    if (this.axpObj.expansionTab.link) {
                        // リンク生成
                        const anchor = document.createElement('a');
                        anchor.setAttribute('href', this.axpObj.expansionTab.link);
                        anchor.setAttribute('target', '_blank');
                        anchor.setAttribute('rel', 'noopener');
                        anchor.setAttribute('style', 'width:100%;text-decoration:none;color:#fff');
                        const div = document.createElement('div');
                        div.textContent = this.axpObj.expansionTab.name;
                        anchor.appendChild(div);
                        targetElements_tab[3].appendChild(anchor);
                    } else {
                        // 関数呼び出し
                        targetElements_tab[3].textContent = this.axpObj.expansionTab.name;
                    }

                }
                // タブのヘルプ
                if (this.axpObj.expansionTab.msg) {
                    targetElements_tab[3].dataset.msg = this.axpObj.expansionTab.msg;
                }
            } else {
                // 定義がない場合、拡張機能タブを非表示
                targetElements_tab[3].style.display = 'none';
            }

            // タブ横のテキスト表示エリア
            // 文字列か判定
            const isString = (value) => {
                if (typeof value === "string" || value instanceof String) {
                    return true;
                } else {
                    return false;
                }
            }
            let text;
            if (isString(option.headerText)) {
                // 最大1024文字まで）
                if (option.headerText.length > 1024) {
                    text = option.headerText.slice(0, 1024);
                } else {
                    text = option.headerText;
                }
            } else {
                text = '';
            }
            document.getElementById('axp_main_div_headerText').textContent = text;

            // 標準アラートのオーバーライド
            if (document.getElementById) {
                window.alert = function (txt) {
                    (0,_js_alert_js__WEBPACK_IMPORTED_MODULE_2__.createCustomAlert)(txt);
                }
            }
            // ブラウザ
            this.axpObj.browser = (0,_js_etc_js__WEBPACK_IMPORTED_MODULE_3__.getBrowserType)();
            console.log('Browser:', this.axpObj.browser);
            if (this.axpObj.browser === 'Safari') {
                // safariの場合、キャンバス描画時の不具合回避用の処理を行う必要があるため、フラグを立てておく
                this.axpObj.ENV.multiCanvas = true;
            }
            // 画面幅
            // console.log('screen.width:', window.screen.width + 'px');
            if (window.screen.width < 600) {
                // デバイスの画面幅が600未満の場合の特別処理用
                this.axpObj.ENV.isMobileWidth = true;
            }
            // 本体起動
            this.axpObj.exec();
            // ロード中マスクの解除
            document.getElementById('axp_main').style.display = 'flex';
        })();
    }
    // バージョン
    version() {
        return `${this.axpObj.CONST.APP_TITLE} version ${"2.4.0"} (${"2026-01-11T10:33:35.901Z"})`;
    }
    // 画面の表示／非表示
    on() {
        this.axpObj.paintBodyElement.style.display = 'flex';
        this.axpObj.isClose = false;
    }
    off() {
        this.axpObj.paintBodyElement.style.display = 'none';
        this.axpObj.isClose = true;
    }
    static ver() {
        return `version ${"2.4.0"} (${"2026-01-11T10:33:35.901Z"})`;
    }
});


})();

__webpack_exports__ = __webpack_exports__["default"];
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=axnospaint.js.map